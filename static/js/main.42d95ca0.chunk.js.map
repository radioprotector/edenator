{"version":3,"sources":["store/TrackAnalysis.ts","store/analyzer.ts","store/themes.ts","store/visualizerStore.ts","components/AppStyles.tsx","utils.ts","components/BassTunnel.tsx","components/BeatQueue.tsx","components/FrequencyGrid.tsx","components/TrebleQueue.tsx","components/BackgroundManager.tsx","components/VfxManager.tsx","components/Visualizer.tsx","components/App.tsx","reportWebVitals.ts","index.tsx"],"names":["OpenKey","TrackAnalysis","title","artist","bpm","length","key","subBass","bass","beat","treble","trackHash","isEmpty","this","low","high","getTrackSeededRandomInt","seed","random","Math","sin","floor","min","max","EmptyTrackAnalysis","ANALYZER_SAMPLE_RATE","RECOGNIZED_KEY_VALUES","Object","values","KEY_CONVERSION_CHART","G_Sharp_Minor","B_Major","D_Sharp_Minor","F_Sharp_Major","B_Flat_Minor","D_Flat_Major","F_Minor","A_Flat_Major","C_Minor","E_Flat_Major","G_Minor","B_Flat_Major","D_Minor","F_Major","A_Minor","C_Major","E_Minor","G_Major","B_Minor","D_Major","F_Sharp_Minor","A_Major","C_Sharp_Minor","E_Major","OffKey","getTrackTags","file","Promise","resolve","reject","Reader","read","onSuccess","tagData","onError","error","wrappedError","Error","info","name","findTagValue","tagCollection","standardTags","customTagDescriptions","standardTagName","tags","customTags","Array","isArray","targetDescription","customTag","data","id","description","getBpmTagValue","bpmTag","bpmValue","parseFloat","Number","isFinite","getKeyTagValue","keyTag","keyValue","toString","replace","includes","trim","getTrackVolume","audioData","window","OfflineAudioContext","decodeAudioData","then","decodedData","audioContext","bufferSource","createBufferSource","buffer","connect","destination","start","startRendering","renderedBuffer","rawSamples","getChannelData","smoothedVolume","Float32Array","SAMPLE_WINDOW","volume","frameIdx","rms","sum","windowedIndex","sqrt","getPeaks","overallVolume","analysisArgs","lastNode","minFrequency","minFrequencyFilter","BiquadFilterNode","type","Q","frequency","maxFrequency","maxFrequencyFilter","frames","peaksList","peaksHistogram","absoluteIntensity","abs","relativeIntensity","initialAbsoluteThreshold","initialRelativeThreshold","newPeak","time","intensity","intensityNormalized","end","sustainAbsoluteThreshold","sustainRelativeThreshold","push","roundedIntensity","toFixed","ceil","expectedMaximumPeaks","expectedMaxPeaksPerMinute","duration","sortedBuckets","keys","map","k","count","sort","a","b","intensityIndex","intensityCutoff","totalPeaks","filter","p","getBpmFromPeaks","beats","trackLength","minimumBeats","intervalHistogram","forEach","index","relativeIndex","interval","roundedInterval","tempoHistogram","tempoForInterval","roundedTempoForInterval","sortedTempos","intervals","modeIntervals","totalWeightedTempo","totalIntervals","tempo","averageTempo","medianIntervals","medianTempoIdx","arrayBuffer","byteBuffer","all","tagResult","subBassResult","bassResult","beatResult","trebleResult","keyFromTags","detectedBpm","analysis","lastModified","size","BLACK_COLOR","THREE","WHITE_COLOR","getLumaComponent","floatColor","pow","getLuma","color","r","g","LIGHT_LUMA_THRESHOLD","generateThemeForColor","baseColor","secondaryColor","uiTextColor","uiDisabledBgColor","uiFocusBgColor","tertiaryColor","lerp","wireframeColor","panelColor","spriteColor","spriteTexture","process","lightColor","frequencyGrid","lineColor","background","fillColor","sunColor","burstLineColor","starColor","starFlashColor","ui","textColor","backgroundColor","disabledBackgroundColor","focusBackgroundColor","borderColor","defaultTheme","magentaTheme","indigoTheme","darkBlueTheme","midBlueTheme","lightBlueTheme","blueGreenTheme","greenTheme","yellowGreenTheme","yellowTheme","orangeTheme","redTheme","pinkTheme","hotdogStandTheme","fluorescentTheme","plasmaPowerSaverTheme","ALL_THEMES","useStore","create","subscribeWithSelector","set","theme","audioLastSeeked","setAnalysis","newAnalysis","state","setTheme","newTheme","indicateAudioSeeked","Date","now","bevelPath","Path2D","waveformPath","firstStarPath","secondStarPath","AppStyles","uiTheme","useEffect","subscribe","newUiTheme","document","querySelector","setAttribute","getStyle","canvasElem","createElement","ctx","getContext","alpha","desynchronized","fillStyle","fill","strokeStyle","lineWidth","stroke","iconUrl","toDataURL","remove","css","generateNumericArray","total","from","QUARTER_TURN","PI","SEGMENT_HEIGHT","boxLineGeometry","setFromPoints","SegmentDisplay","boxLineMaterial","panelFillGeometry","panelFillMaterial","side","transparent","opacity","randomizeTunnelSegment","segmentIndex","segment","planeForSegment","trackAnalysis","currentTrackTime","visible","PlaneHidden","MIN","MAX","SegmentHidden","PlaneLeft","scale","position","rotation","PlaneRight","SEGMENT_WIDTH","PlaneFront","SEGMENT_DEPTH","PlaneTop","PlaneBottom","getDepthForSegment","BassTunnel","props","nextBassIndex","nextSubBassIndex","newLineColor","newFillColor","tunnelSegments","useRef","tunnelSegmentBoxes","tunnelSegmentPlanes","tunnelSegmentElements","useMemo","SEGMENTS_PER_SIDE","ref","grp","current","seg","geometry","material","plane","tunnelTraversalPeriodSeconds","secondsPerMeasure","groupForSegment","segmentDepth","useFrame","WRAP_DEPTH","timeDepthOffset","bassScalingFactor","subBassScalingFactor","audio","currentTime","bassIndex","curBass","startTime","endTime","effectiveIntensity","mapLinear","subBassIndex","curSubBass","z","getBasePosition","sideIdx","totalSides","angle","cos","multiplyScalar","beatGeometry","beatMeshMaterial","shininess","BeatQueue","nextUnrenderedPeakIndex","nextAvailableMeshIndex","availableMeshesRing","newBeatColor","availableMeshElements","SIDES","sideNumber","mesh","_state","delta","audioTime","lastRenderTime","peakIdx","curPeak","peakDisplayStart","userData","meshForPeak","peakData","undefined","peakDisplayEnd","setScalar","frequencyLineMaterial","FrequencyGrid","DEPTH_SPACING","pointSet","points","currentX","i","LINE_BUCKETS","frequencyGeometry","rowLines","rowElements","rowIndex","line","FREQUENCY_ROWS","object","analyser","frequencies","Uint8Array","frequencyBinCount","getByteFrequencyData","y","leftmostFrequency","rightmostFrequency","ANCHOR_POINTS","measurePercentage","lineRow","baseDepth","computeBoundingBox","TrebleQueue","nextAvailableGroupIndex","availableTrebleGroupsRing","trebleTheme","useTexture","availableSpriteElements","depthWrite","blending","blendEquation","blendSrc","blendDst","castShadow","distance","groupForPeak","DEG2RAD","radius","x","itemIdx","spriteForPeak","children","lightForPeak","FULL_RADIANS","buildLineRingGeometry","innerRadius","maxOuterRadius","perturbAngle","extraLength","pointNum","outerRadius","backdropGeometry","BackgroundManager","textures","star_first","star_first_glow","star_second","star_second_glow","star_third","star_third_glow","horizon","tex","wrapS","wrapT","repeat","backgroundTheme","firstRingGeometry","secondRingGeometry","thirdRingGeometry","ringCycleSeconds","starCycleSeconds","horizonLayer","firstStarLayer","firstStarGlowLayer","secondStarLayer","secondStarGlowLayer","thirdStarLayer","thirdStarGlowLayer","ringGroup","firstLineRing","secondLineRing","thirdLineRing","scene","currentTrackDuration","ringPercentage","ringRotation","starPercentage","starRotation","ringOpacityFactor","ringScaleFactor","horizonOpacityFactor","starGlowFactor","horizonDampenedOpacity","starGlowDampenedOpacity","newStarGlowOpacity","ringDampenedScale","newRingScale","ringGroupScale","frustumCulled","args","fog","precision","VfxManager","godRaysEffect","godRaysMaterial","godRaysPass","getFullscreenMaterial","godRaysScale","uniforms","decay","value","exposure","width","Resizer","AUTO_SIZE","height","kernelSize","KernelSize","MEDIUM","luminanceThreshold","luminanceSmoothing","sun","sunMesh","blur","blendFunction","BlendFunction","Screen","samples","density","weight","clampMax","sunMaterial","Visualizer","getState","newSunColor","camera","isSafari","navigator","userAgent","indexOf","App","playingFileUrl","setStoreAnalysis","store","setStoreTheme","setStoreAudioSeeked","AudioContext","introElement","sourceFileElement","dummyFileButtonElement","useState","fileError","setFileError","audioPlayerElement","audioAnalyser","mediaElementSourceNodes","WeakMap","audioPlayerRef","useCallback","node","audioSource","has","get","MediaElementAudioSourceNode","mediaElement","AnalyserNode","fftSize","className","hidden","onClick","src","resume","play","click","accept","onChange","files","disabled","innerText","readOnly","pause","controls","trackFile","analyzeTrack","analyzerResult","newAudioUrl","URL","createObjectURL","load","initialContextPromise","initialPlayerPromise","setTimeout","revokeObjectURL","track","keyIndex","getTrackRandomInt","getThemeForTrack","reason","console","nextTheme","currentTheme","currentThemeIndex","getNextTheme","onSeeked","fallback","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.42d95ca0.chunk.js","sourcesContent":["import Peak from \"./Peak\";\r\n\r\n/**\r\n * The different key values that are supported\r\n * by Open Key Notation.\r\n * @see {@link https://www.beatunes.com/en/open-key-notation.html}\r\n */\r\n export enum OpenKey {\r\n  C_Major = '1d',\r\n  A_Minor = '1m',\r\n\r\n  G_Major = '2d',\r\n  E_Minor = '2m',\r\n\r\n  D_Major = '3d',\r\n  B_Minor = '3m',\r\n\r\n  A_Major = '4d',\r\n  F_Sharp_Minor = '4m',\r\n\r\n  E_Major = '5d',\r\n  C_Sharp_Minor = '5m',\r\n\r\n  B_Major = '6m',\r\n  G_Sharp_Minor = '6d',\r\n\r\n  F_Sharp_Major = '7d',\r\n  D_Sharp_Minor = '7m',\r\n\r\n  D_Flat_Major = '8d',\r\n  B_Flat_Minor = '8m',\r\n\r\n  A_Flat_Major = '9d',\r\n  F_Minor = '9m',\r\n\r\n  E_Flat_Major = '10d',\r\n  C_Minor = '10m',\r\n\r\n  B_Flat_Major = '11d',\r\n  G_Minor = '11m',\r\n\r\n  F_Major = '12d',\r\n  D_Minor = '12m',\r\n\r\n  OffKey = '0'\r\n}\r\n\r\n/**\r\n * An analysis of a track to be played and visualized.\r\n */\r\nexport class TrackAnalysis\r\n{\r\n  public title: string = '';\r\n\r\n  public artist: string = '';\r\n\r\n  public bpm: number = 120;\r\n\r\n  public get secondsPerMeasure(): number {\r\n    // Assuming 4 beats per measure, BPM / 4 => measures/minute / 60 => BPM/240 for measures per second\r\n    // Use the inverse to get seconds per measure\r\n    return 240 / this.bpm;\r\n  }\r\n\r\n  /**\r\n   * The length of the song, in seconds.\r\n   */\r\n  public length: number = 0;\r\n\r\n  /**\r\n   * The key that was detected for the track, or null if not detected.\r\n   */\r\n  public key: OpenKey | null = null;\r\n\r\n  public subBass: Peak[] = [];\r\n\r\n  public bass: Peak[] = [];\r\n\r\n  public beat: Peak[] = [];\r\n\r\n  public treble: Peak[] = [];\r\n\r\n  /**\r\n   * The hash to identify the track. This is not guaranteed to be unique, but is\r\n   * intended to help ensure deterministic results for the same track.\r\n   * \r\n   * This should be a positive non-zero finite integer.\r\n   */\r\n  public trackHash: number = 1;\r\n\r\n  /**\r\n   * Used to indicate \"empty\" instances for special default displays.\r\n   */\r\n  public isEmpty: boolean = false;\r\n\r\n  /**\r\n   * Gets a random integer that is deterministic for the track.\r\n   * @param low The minimum possible integer value.\r\n   * @param high The maximum possible integer value.\r\n   */\r\n  public getTrackRandomInt(low: number, high: number): number {\r\n    return this.getTrackSeededRandomInt(low, high, 0);\r\n  }\r\n\r\n  /**\r\n   * Gets a random integer that is deterministic for the track and specified seed.\r\n   * @param low The minimum possible integer value.\r\n   * @param high The maximum possible integer value.\r\n   * @param seed The seed to use.\r\n   */\r\n  public getTrackSeededRandomInt(low: number, high: number, seed: number): number {\r\n    // Because our random number seeds aren't as clustered around pi, this should vary *enough* for our purposes\r\n    // Something like THREE.MathUtils.seededRandom exhibits very little variation between small seed increments of 1,\r\n    // which doesn't work well for our purposes.\r\n    const random = (Math.sin(this.trackHash + seed) + 1) / 2;\r\n\r\n    // Because we're using Math.floor on the random result, we need to go 1 *above* the high\r\n    return low + Math.floor(random * (high - low + 1));\r\n  }\r\n\r\n  /**\r\n   * Gets a random float that is deterministic for the track and specified seed.\r\n   * @param min The minimum possible floating-point value.\r\n   * @param max The maximum possible floating-point value.\r\n   * @param seed The seed to use.\r\n   */\r\n  public getTrackSeededRandomFloat(min: number, max: number, seed: number) {\r\n    // Because our random number seeds aren't as clustered around pi, this should vary *enough* for our purposes\r\n    // Something like THREE.MathUtils.seededRandom exhibits very little variation between small seed increments of 1,\r\n    // which doesn't work well for our purposes.\r\n    const random = (Math.sin(this.trackHash + seed) + 1) / 2;\r\n\r\n    return min + (random * (max - min));    \r\n  }\r\n}\r\n\r\nexport const EmptyTrackAnalysis = new TrackAnalysis();\r\nEmptyTrackAnalysis.isEmpty = true;\r\n","import { Reader } from \"jsmediatags\";\r\nimport { FrameType, TagType } from \"jsmediatags/types\";\r\nimport Peak from \"./Peak\";\r\nimport { OpenKey, TrackAnalysis } from \"./TrackAnalysis\";\r\n\r\nconst ANALYZER_SAMPLE_RATE = 44100;\r\n\r\nconst RECOGNIZED_KEY_VALUES = Object.values(OpenKey);\r\n\r\n/**\r\n * Converts various key formats into a corresponding Open Key Notation representation.\r\n * @see {@link https://id3.org/id3v2.3.0|TKEY value definition} (TKEY)\r\n * @see {@link https://mixedinkey.com/harmonic-mixing-guide/|Camelot mixing keys}\r\n */\r\nconst KEY_CONVERSION_CHART: { [key: string]: OpenKey } = {\r\n  // A-flat/G-sharp minor\r\n  '1A': OpenKey.G_Sharp_Minor,\r\n  'G#m': OpenKey.G_Sharp_Minor,\r\n  'Abm': OpenKey.G_Sharp_Minor,\r\n\r\n  // B major\r\n  '1B': OpenKey.B_Major,\r\n  'B': OpenKey.B_Major,\r\n\r\n  // E-flat/D-sharp minor\r\n  '2A': OpenKey.D_Sharp_Minor,\r\n  'D#m': OpenKey.D_Sharp_Minor,\r\n  'Ebm': OpenKey.D_Sharp_Minor,\r\n\r\n  // F-sharp/G-flat major\r\n  '2B': OpenKey.F_Sharp_Major,\r\n  'F#': OpenKey.F_Sharp_Major,\r\n  'Gb': OpenKey.F_Sharp_Major,\r\n\r\n  // B-flat/A-sharp minor\r\n  '3A': OpenKey.B_Flat_Minor,\r\n  'A#m': OpenKey.B_Flat_Minor,\r\n  'Bbm': OpenKey.B_Flat_Minor,\r\n\r\n  // D-flat/C-sharp major\r\n  '3B': OpenKey.D_Flat_Major,\r\n  'C#': OpenKey.D_Flat_Major,\r\n  'Db': OpenKey.D_Flat_Major,\r\n\r\n  // F minor\r\n  '4A': OpenKey.F_Minor,\r\n  'Fm': OpenKey.F_Minor,\r\n\r\n  // A-flat/G-sharp major\r\n  '4B': OpenKey.A_Flat_Major,\r\n  'G#': OpenKey.A_Flat_Major,\r\n  'Ab': OpenKey.A_Flat_Major,\r\n\r\n  // C minor\r\n  '5A': OpenKey.C_Minor,\r\n  'Cm': OpenKey.C_Minor,\r\n\r\n  // E-flat/D-sharp major\r\n  '5B': OpenKey.E_Flat_Major,\r\n  'D#': OpenKey.E_Flat_Major,\r\n  'Eb': OpenKey.E_Flat_Major,\r\n\r\n  // G minor\r\n  '6A': OpenKey.G_Minor,\r\n  'Gm': OpenKey.G_Minor,\r\n\r\n  // B-flat/A-sharp major\r\n  '6B': OpenKey.B_Flat_Major,\r\n  'A#': OpenKey.B_Flat_Major,\r\n  'Bb': OpenKey.B_Flat_Major,\r\n\r\n  // D minor\r\n  '7A': OpenKey.D_Minor,\r\n  'Dm': OpenKey.D_Minor,\r\n\r\n  // F major\r\n  '7B': OpenKey.F_Major,\r\n  'F': OpenKey.F_Major,\r\n\r\n  // A minor\r\n  '8A': OpenKey.A_Minor,\r\n  'Am': OpenKey.A_Minor,\r\n\r\n  // C major\r\n  '8B': OpenKey.C_Major,\r\n  'C': OpenKey.C_Major,\r\n\r\n  // E minor\r\n  '9A': OpenKey.E_Minor,\r\n  'Em': OpenKey.E_Minor,\r\n\r\n  // G major\r\n  '9B': OpenKey.G_Major,\r\n  'G': OpenKey.G_Major,\r\n\r\n  // B minor\r\n  '10A': OpenKey.B_Minor,\r\n  'Bm': OpenKey.B_Minor,\r\n\r\n  // D major\r\n  '10B': OpenKey.D_Major,\r\n  'D': OpenKey.D_Major,\r\n\r\n  // G-flat/F-sharp minor\r\n  '11A': OpenKey.F_Sharp_Minor,\r\n  'F#m': OpenKey.F_Sharp_Minor,\r\n  'Gbm': OpenKey.F_Sharp_Minor,\r\n\r\n  // A major\r\n  '11B': OpenKey.A_Major,\r\n  'A': OpenKey.A_Major,\r\n\r\n  // D-flat/C-sharp minor\r\n  '12A': OpenKey.C_Sharp_Minor,\r\n  'C#m': OpenKey.C_Sharp_Minor,\r\n  'Dbm': OpenKey.C_Sharp_Minor,\r\n\r\n  // E major\r\n  '12B': OpenKey.E_Major,\r\n  'E': OpenKey.E_Major,\r\n\r\n  // Map off-key items to '0' placeholder\r\n  'o': OpenKey.OffKey,\r\n  'O': OpenKey.OffKey\r\n};\r\n\r\n/**\r\n * Describes the parameters to use for a specific song peak analysis pass.\r\n */\r\ninterface PeakAnalysisArgs {\r\n  minFrequency: number | null;\r\n  \r\n  maxFrequency: number | null;\r\n  \r\n  expectedMaxPeaksPerMinute: number;\r\n\r\n  initialAbsoluteThreshold: number;\r\n\r\n  initialRelativeThreshold: number;\r\n\r\n  sustainAbsoluteThreshold: number;\r\n\r\n  sustainRelativeThreshold: number;\r\n}\r\n\r\n/**\r\n * Attempts to get all media tags for the specified file.\r\n * @param file The file to open.\r\n * @returns A promise to retrieve all tags for the file.\r\n */\r\n function getTrackTags(file: File): Promise<TagType> {\r\n  return new Promise((resolve, reject) => {\r\n    new Reader(file)\r\n      .read({\r\n        onSuccess: (tagData) => {\r\n          resolve(tagData)\r\n        },\r\n        onError: (error) => {\r\n          // Wrap the jsmediatagsError into a true error object\r\n          // XXX: This won't let us use options.cause\r\n          const wrappedError = new Error(error.info);\r\n          wrappedError.name = 'MediaTagsError';\r\n\r\n          reject(wrappedError);\r\n        }\r\n      })\r\n  });\r\n}\r\n\r\n/**\r\n * Attempts to retrieve a tag value that could reside in any number of standard or custom tag values.\r\n * @param tagCollection The collection of tags to search through.\r\n * @param standardTags The standard tags to search for, in priority order.\r\n * @param customTagDescriptions The collection of user descriptions to search for, in priority order, in custom tags if no standard tags were found.\r\n * @returns The specified tag and value, if found; otherwise, null.\r\n */\r\nfunction findTagValue(tagCollection: TagType, standardTags: string[] | null, customTagDescriptions: string[] | null): FrameType | null {\r\n  // First check standard tags\r\n  if (standardTags !== null) {\r\n    for (let standardTagName of standardTags) {\r\n      if (standardTagName in tagCollection.tags) {\r\n        return tagCollection.tags[standardTagName];\r\n      }\r\n    }\r\n  }\r\n\r\n  // Then look for custom tags if any are defined\r\n  if (customTagDescriptions !== null) {\r\n    if ('TXXX' in tagCollection.tags) {\r\n      let customTags: FrameType[] = [];\r\n\r\n      // See if this is already an array\r\n      if (Array.isArray(tagCollection.tags['TXXX'])) {\r\n        customTags = tagCollection.tags['TXXX'];\r\n      }\r\n      else {\r\n        // Wrap the single tag in an array\r\n        customTags = [tagCollection.tags['TXXX']];\r\n      }\r\n\r\n      // Iterate through our custom descriptions\r\n      // XXX: This is technically quadratic but I don't know how long customTagDescriptions will be, realistically\r\n      for (let targetDescription of customTagDescriptions) {\r\n        for (let customTag of customTags) {\r\n          // In this case, the description and value we want is wrapped further in customTag.data\r\n          if ('user_description' in customTag.data && 'data' in customTag.data && customTag.data['user_description'] === targetDescription) {\r\n            return {\r\n              id: targetDescription,\r\n              description: targetDescription,\r\n              data: customTag.data['data']\r\n            };\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Attempts to retrieve the BPM of the track as stored in its metadata tags.\r\n * @param tagCollection The collection of tags to search.\r\n * @returns The fractional BPM, if found; otherwise, null.\r\n */\r\nfunction getBpmTagValue(tagCollection: TagType): number | null {\r\n  // Look for, in order of preference: BPM, TBPM, TMPO\r\n  // In addition, we want to support fBPM as set by programs like Traktor\r\n  let bpmTag = findTagValue(tagCollection, ['BPM', 'TBPM', 'TMPO'], ['fBPM']);\r\n  let bpmValue: any = '';\r\n\r\n  if (bpmTag === null) {\r\n    return null;\r\n  }\r\n  else {\r\n    bpmValue = bpmTag.data;\r\n  }\r\n\r\n  // Coalesce to a float value\r\n  if (typeof bpmValue === 'string') {\r\n    bpmValue = parseFloat(bpmValue);\r\n  }\r\n\r\n  // Make sure it's a finite number greater than zero\r\n  if (typeof bpmValue === 'number' && Number.isFinite(bpmValue) && bpmValue > 0) {\r\n    return bpmValue;\r\n  }\r\n  else {\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Attempts to retrieve the key of the track as stored in its metadata tags.\r\n * @param tagCollection The collection of tags to search.\r\n * @returns The OpenKey representation of the key, if found; otherwise, null.\r\n */\r\nfunction getKeyTagValue(tagCollection: TagType): OpenKey | null {\r\n  let keyTag = findTagValue(tagCollection, ['KEY', 'TKEY'], ['INITIAL KEY', 'INITIAL_KEY']);\r\n  let keyValue: string = '';\r\n\r\n  if (keyTag === null) {\r\n    return null;\r\n  }\r\n  else {\r\n    keyValue = keyTag.data.toString();\r\n  }\r\n\r\n  // Remove spaces\r\n  keyValue = keyValue.replace(/ /, '');\r\n\r\n  // Convert appropriate values to open key notation\r\n  if (keyValue in KEY_CONVERSION_CHART) {\r\n    keyValue = KEY_CONVERSION_CHART[keyValue];\r\n  }\r\n\r\n  // See if this matches a recognized key value\r\n  if (keyValue !== null && RECOGNIZED_KEY_VALUES.includes(keyValue.trim() as OpenKey)) {\r\n    return keyValue as OpenKey;\r\n  }\r\n  else {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      console.debug(`unrecognized key value: ${keyValue}`);\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Gets the track volume for the specified audio data.\r\n * @param audioData The raw encoded audio data.\r\n * @returns A promise for the equivalent mono track volume, smoothed and sampled at periodic \r\n */\r\nfunction getTrackVolume(audioData: ArrayBuffer): Promise<Float32Array> {\r\n  // For processing, downmix to mono\r\n  // HACK: We need to use one audio context just so we can decode the audio (and get the correct buffer length)\r\n  // After that, we use a *separate* audio context with the correct buffer length\r\n  // XXX: Look at getting webkitOfflineAudioContext supported as well\r\n  const dummyAudioContext = new window.OfflineAudioContext(1, ANALYZER_SAMPLE_RATE, ANALYZER_SAMPLE_RATE);\r\n\r\n  return dummyAudioContext.decodeAudioData(audioData)\r\n  .then((decodedData: AudioBuffer) => {\r\n    // if (process.env.NODE_ENV !== 'production') {\r\n    //   console.debug('audio decoded', decodedData);\r\n    // }\r\n    const audioContext = new window.OfflineAudioContext(1, decodedData.length, ANALYZER_SAMPLE_RATE);\r\n    const bufferSource = audioContext.createBufferSource();\r\n    bufferSource.buffer = decodedData;\r\n\r\n    // Now wire up the destination\r\n    bufferSource.connect(audioContext.destination);\r\n    bufferSource.start(0);\r\n    return audioContext.startRendering();\r\n  })\r\n  .then((renderedBuffer: AudioBuffer) => {\r\n    const rawSamples = renderedBuffer.getChannelData(0);\r\n\r\n    // Convert the channel data to the equivalent volume\r\n    // Code based on https://webaudio.github.io/web-audio-api/#vu-meter-mode\r\n    const smoothedVolume = new Float32Array(rawSamples);\r\n    const SAMPLE_WINDOW = Math.floor(ANALYZER_SAMPLE_RATE / 50);\r\n    const DECAY_FACTOR = 0.9;\r\n    let volume = 0.0;\r\n\r\n    for (let frameIdx = 0; frameIdx < rawSamples.length; frameIdx = frameIdx + SAMPLE_WINDOW)\r\n    {\r\n      // Calculate RMS across the sample window\r\n      let sum = 0;\r\n      let rms = 0;\r\n      let windowedIndex = 0;\r\n\r\n      for (windowedIndex = 0; windowedIndex < SAMPLE_WINDOW && (frameIdx + windowedIndex) < rawSamples.length; windowedIndex++) {\r\n        sum += rawSamples[frameIdx + windowedIndex] * rawSamples[frameIdx + windowedIndex];\r\n      }\r\n\r\n      rms = Math.sqrt(sum / (windowedIndex + 1));\r\n\r\n      // Update the volume\r\n      volume = Math.max(rms, volume * DECAY_FACTOR);\r\n\r\n      // Fill our sample window with that smoothed volume\r\n      for (windowedIndex = 0; windowedIndex < SAMPLE_WINDOW && (frameIdx + windowedIndex) < rawSamples.length; windowedIndex++) {\r\n        smoothedVolume[frameIdx + windowedIndex] = volume;\r\n      }\r\n    }\r\n\r\n    // if (process.env.NODE_ENV !== 'production') {\r\n    //   console.debug('volume analyzed', renderedBuffer, smoothedVolume);\r\n    // }\r\n    return smoothedVolume;\r\n  });\r\n}\r\n\r\n/**\r\n * Gets peaks from the provided audio data that meet the specified criteria.\r\n * @param audioData The raw encoded audio data.\r\n * @param overallVolume The mono volume progression for the entire track.\r\n * @param analysisArgs The parameters to use for the analysis.\r\n * @returns A promise for the relevant peak collection.\r\n */\r\nfunction getPeaks(audioData: ArrayBuffer, overallVolume: Float32Array, analysisArgs: PeakAnalysisArgs): Promise<Peak[]> {\r\n  // For processing, downmix to mono\r\n  // XXX: Look at getting webkitOfflineAudioContext supported as well\r\n  const audioContext = new window.OfflineAudioContext(1, overallVolume.length, ANALYZER_SAMPLE_RATE);\r\n  \r\n  return audioContext.decodeAudioData(audioData)\r\n    .then((decodedData: AudioBuffer) => {\r\n      const bufferSource = audioContext.createBufferSource();\r\n      let lastNode: AudioNode = bufferSource;\r\n\r\n      bufferSource.buffer = decodedData;\r\n\r\n      // Add a minimum frequency filter if we need it\r\n      if (analysisArgs.minFrequency != null) {\r\n        const minFrequencyFilter = new BiquadFilterNode(audioContext, { type: 'highpass', Q: 1, frequency: analysisArgs.minFrequency });\r\n\r\n        lastNode.connect(minFrequencyFilter);\r\n        lastNode = minFrequencyFilter;\r\n      }\r\n\r\n      // Do the same for the maximum frequency\r\n      if (analysisArgs.maxFrequency != null) {\r\n        const maxFrequencyFilter = new BiquadFilterNode(audioContext, { type: 'lowpass', Q: 1, frequency: analysisArgs.maxFrequency });\r\n\r\n        lastNode.connect(maxFrequencyFilter);\r\n        lastNode = maxFrequencyFilter;\r\n      }\r\n\r\n      // Now wire up the destination\r\n      lastNode.connect(audioContext.destination);\r\n      bufferSource.start(0);\r\n      return audioContext.startRendering();\r\n    })\r\n    .then((renderedBuffer: AudioBuffer) => {    \r\n      // if (process.env.NODE_ENV !== 'production') {\r\n      //   console.debug(`buffer for ${analysisArgs.minFrequency} to ${analysisArgs.maxFrequency}`, renderedBuffer);\r\n      // }\r\n      const frames = renderedBuffer.getChannelData(0);\r\n      const peaksList: Peak[] = [];\r\n      const peaksHistogram: { [roundedIntensity: string]: number } = {};\r\n\r\n      for(let frameIdx = 0; frameIdx < frames.length;)\r\n      {\r\n        // Make sure we have audio data on this frame\r\n        if (overallVolume[frameIdx] === 0) {\r\n          frameIdx++;\r\n          continue;\r\n        }\r\n\r\n        let absoluteIntensity = Math.abs(frames[frameIdx]);\r\n        let relativeIntensity = absoluteIntensity / overallVolume[frameIdx];\r\n\r\n        // See if we're ready to start a new peak\r\n        if (absoluteIntensity >= analysisArgs.initialAbsoluteThreshold && relativeIntensity >= analysisArgs.initialRelativeThreshold)\r\n        {\r\n          // Start a new peak, and mark when it was encountered\r\n          const newPeak: Peak = {\r\n            time: frameIdx / ANALYZER_SAMPLE_RATE,\r\n            intensity: 0,\r\n            intensityNormalized: 0,\r\n            end: 0 // To be calculated\r\n          };\r\n\r\n          // Determine the maximum intensity and number of frames it was above the threshold\r\n          do {\r\n            // See if this peak reached a new intensity\r\n            newPeak.intensity = Math.max(newPeak.intensity, absoluteIntensity)\r\n            newPeak.intensityNormalized = Math.max(newPeak.intensityNormalized, relativeIntensity)\r\n\r\n            // Look at the next frame.\r\n            // If we have audio data, recalculate the current intensity (both absolute and normalized)\r\n            // and see whether we can keep going based on the *sustain* thresholds\r\n            frameIdx++;\r\n\r\n            if (frameIdx >= frames.length || overallVolume[frameIdx] === 0) {\r\n              break;\r\n            }\r\n\r\n            absoluteIntensity = Math.abs(frames[frameIdx]);\r\n            relativeIntensity = absoluteIntensity / overallVolume[frameIdx];\r\n          } while(absoluteIntensity >= analysisArgs.sustainAbsoluteThreshold && relativeIntensity >= analysisArgs.sustainRelativeThreshold)\r\n\r\n          // Now calculate the end of the peak\r\n          newPeak.end = frameIdx / ANALYZER_SAMPLE_RATE;\r\n\r\n          // Store the peak\r\n          peaksList.push(newPeak);\r\n\r\n          // Update the histogram\r\n          const roundedIntensity = newPeak.intensityNormalized.toFixed(2);\r\n\r\n          if (roundedIntensity in peaksHistogram) {\r\n            peaksHistogram[roundedIntensity]++;\r\n          }\r\n          else {\r\n            peaksHistogram[roundedIntensity] = 1;\r\n          }\r\n\r\n          // Move forward 1/16 of a second\r\n          frameIdx += Math.ceil(ANALYZER_SAMPLE_RATE / 16);\r\n        }\r\n\r\n        frameIdx++;\r\n      }\r\n  \r\n      if (process.env.NODE_ENV !== 'production') {\r\n        console.debug(`peak histogram for ${analysisArgs.minFrequency} to ${analysisArgs.maxFrequency}`, peaksHistogram);\r\n      }\r\n\r\n      // See if we have too many peaks - if so, trim\r\n      const expectedMaximumPeaks = Math.ceil(analysisArgs.expectedMaxPeaksPerMinute * renderedBuffer.duration / 60);\r\n\r\n      if (peaksList.length > expectedMaximumPeaks) {\r\n        // Look at the histogram to figure out the cutoff.\r\n        // Convert each truncated bucket back to its actual intensity float, and sort intensity in decreasing order\r\n        const sortedBuckets = Object.keys(peaksHistogram)\r\n          .map((k) => {\r\n            return { \r\n              intensity: parseFloat(k), \r\n              count: peaksHistogram[k]\r\n            };\r\n          })\r\n          .sort((a, b) => b.intensity - a.intensity);\r\n\r\n        // Start at the maximum intensity, and keep decreasing until we get more peaks\r\n        let intensityIndex = 0;\r\n        let intensityCutoff = sortedBuckets[0].intensity;\r\n        let totalPeaks = sortedBuckets[0].count;\r\n\r\n        while(totalPeaks < expectedMaximumPeaks && intensityIndex < sortedBuckets.length - 1)\r\n        {\r\n          intensityIndex++;\r\n          intensityCutoff = sortedBuckets[intensityIndex].intensity;\r\n          totalPeaks += sortedBuckets[intensityIndex].count;\r\n        }\r\n\r\n        // Once we determine the cutoff, filter out elements that don't match\r\n        if (process.env.NODE_ENV !== 'production') {\r\n          console.debug(`cutting off peaks for ${analysisArgs.minFrequency} to ${analysisArgs.maxFrequency} at ${intensityCutoff}`);\r\n        }\r\n\r\n        return peaksList.filter((p) => p.intensityNormalized >= intensityCutoff);\r\n      }\r\n\r\n      return peaksList;\r\n    });\r\n}\r\n\r\n/**\r\n * Attempts to detect the BPM from the provided collection of peaks.\r\n * @param beats The collection of beats that are used to determine the peaks.\r\n * @param trackLength The length of the track, in seconds.\r\n * @returns The resulting BPM, if successfully detected; otherwise, null.\r\n */\r\nfunction getBpmFromPeaks(beats: Peak[], trackLength: number) : number | null {\r\n  const MINIMUM_INTERVAL = 0.25;\r\n\r\n  if (!beats) {\r\n    return null;\r\n  }\r\n\r\n  // If we don't have many beats (assume we want probably 45 per minute) also exit out\r\n  const minimumBeats = 45 * (trackLength / 60);\r\n\r\n  if (beats.length < minimumBeats) {\r\n    return null;\r\n  }\r\n\r\n  // Generate a histogram of the average distance between beats\r\n  const intervalHistogram: { [roundedInterval: string]: number } = {};\r\n\r\n  beats.forEach((beat, index) => {\r\n    for(let relativeIndex = 1; relativeIndex < 10; relativeIndex++) {\r\n      // Make sure we don't skip too far out\r\n      if (index + relativeIndex >= beats.length) {\r\n        break;\r\n      }\r\n\r\n      // Instead of counting all beats equally, count ones with more intensity\r\n      const interval = beats[index + relativeIndex].time - beat.time;\r\n      const roundedInterval = interval.toFixed(2);\r\n      // const averageIntensity = (beats[index + relativeIndex].intensityNormalized + beat.intensityNormalized) / 2;\r\n\r\n      // Skip over beats that happen too soon\r\n      if (interval < MINIMUM_INTERVAL) {\r\n        continue;\r\n      }\r\n\r\n      if (roundedInterval in intervalHistogram) {\r\n        // intervalHistogram[roundedInterval] += averageIntensity;\r\n        intervalHistogram[roundedInterval]++;\r\n      }\r\n      else {\r\n        // intervalHistogram[roundedInterval] = averageIntensity;\r\n        intervalHistogram[roundedInterval] = 1;\r\n      }\r\n    }\r\n  });\r\n\r\n  // Map that to an equivalent tempo histogram\r\n  const tempoHistogram: { [roundedTempo: string]: number } = {};\r\n\r\n  Object.keys(intervalHistogram).forEach((roundedInterval) => {\r\n    const intervalFloat = parseFloat(roundedInterval);\r\n    let tempoForInterval = 60 / (intervalFloat / ANALYZER_SAMPLE_RATE);\r\n\r\n    // Adjust to fit within the typical range of 90-180 BPM\r\n    while (tempoForInterval < 90) {\r\n      tempoForInterval *= 2;\r\n    }\r\n\r\n    while (tempoForInterval > 180) {\r\n      tempoForInterval /= 2;\r\n    }\r\n\r\n    // Round the tempo and add all of its intervals\r\n    const roundedTempoForInterval = tempoForInterval.toFixed(0);\r\n\r\n    if (roundedTempoForInterval in tempoHistogram) {\r\n      tempoHistogram[roundedTempoForInterval] += intervalHistogram[roundedInterval];\r\n    }\r\n    else {\r\n      tempoHistogram[roundedTempoForInterval] = intervalHistogram[roundedInterval];\r\n    }\r\n  });\r\n\r\n  // Now get the assumed maximum\r\n  const sortedTempos = Object.keys(tempoHistogram)\r\n    .map((k) => {\r\n      return { \r\n        bpm: parseFloat(k), \r\n        intervals: tempoHistogram[k]\r\n      };\r\n    })\r\n    .sort((a, b) => b.bpm - a.bpm);\r\n\r\n  let modeTempo = 0.0;\r\n  let modeIntervals = 0;\r\n  let totalWeightedTempo = 0.0;\r\n  let totalIntervals = 0.0;\r\n\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    console.debug(`histogram for BPM detection`, sortedTempos);\r\n  }\r\n\r\n  sortedTempos.forEach((tempo) => {\r\n    if (tempo.intervals > modeIntervals) {\r\n      modeTempo = tempo.bpm;\r\n      modeIntervals = tempo.intervals;\r\n    }\r\n\r\n    totalWeightedTempo += (tempo.bpm * tempo.intervals);\r\n    totalIntervals += tempo.intervals;\r\n  });\r\n\r\n  const averageTempo = (totalWeightedTempo / totalIntervals);\r\n\r\n  // Calculate median\r\n  let medianTempo = 0;\r\n\r\n  if (totalIntervals > 2 && sortedTempos.length > 1) {\r\n    // Keep advancing through the sorted tempos list until we've hit halfway in the intervals.\r\n    // Essentially if we have:\r\n    // [{bpm: 120, intervals: 2}, {bpm: 125, intervals: 2}, {bpm: 130, intervals: 2}]\r\n    // then we expect our median BPM to be 125.\r\n    // We'd also expect the same result for:\r\n    // [{bpm: 120, intervals: 2}, {bpm: 130, intervals: 2}]\r\n    let medianIntervals = Math.floor(totalIntervals / 2);\r\n    let medianTempoIdx = 0;\r\n\r\n    while (medianIntervals > 0 && medianTempoIdx < sortedTempos.length) {\r\n      medianIntervals -= sortedTempos[medianTempoIdx].intervals;\r\n      medianTempoIdx++;\r\n    }\r\n\r\n    // If we hit *exactly* zero, average with the next tempo bucket - otherwise, use the current tempo\r\n    if (medianIntervals === 0) {\r\n      medianTempo = (sortedTempos[medianTempoIdx - 1].bpm + sortedTempos[medianTempoIdx].bpm) / 2;\r\n    }\r\n    else {\r\n      medianTempo = sortedTempos[medianTempoIdx - 1].bpm;\r\n    }\r\n  }\r\n\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    console.debug(`calculated BPM mode: ${modeTempo}\\tmean: ${averageTempo}\\tmedian: ${medianTempo}`);\r\n  }\r\n\r\n  return averageTempo;\r\n}\r\n\r\nexport async function analyzeTrack(file: File): Promise<TrackAnalysis> {\r\n  let tags: TagType;\r\n\r\n  try {\r\n    tags = await getTrackTags(file);\r\n  }\r\n  catch (error) {\r\n    return Promise.reject(error);\r\n  }\r\n\r\n  const overallVolume = await file.arrayBuffer().then((byteBuffer) => getTrackVolume(byteBuffer));\r\n\r\n  const subBass = file.arrayBuffer().then((byteBuffer) => getPeaks(byteBuffer, overallVolume, {\r\n    minFrequency: 20,\r\n    maxFrequency: 50,\r\n    expectedMaxPeaksPerMinute: 60,\r\n    initialAbsoluteThreshold: 0.4,\r\n    initialRelativeThreshold: 0.5,\r\n    sustainAbsoluteThreshold: 0.4,\r\n    sustainRelativeThreshold: 0.5\r\n  }));\r\n\r\n  const bass = file.arrayBuffer().then((byteBuffer) => getPeaks(byteBuffer, overallVolume, {\r\n    minFrequency: 50,\r\n    maxFrequency: 90,\r\n    expectedMaxPeaksPerMinute: 120,\r\n    initialAbsoluteThreshold: 0.4,\r\n    initialRelativeThreshold: 0.5,\r\n    sustainAbsoluteThreshold: 0.4,\r\n    sustainRelativeThreshold: 0.5\r\n  }));\r\n\r\n  const beat = file.arrayBuffer().then((byteBuffer) => getPeaks(byteBuffer, overallVolume, {\r\n    minFrequency: 90,\r\n    maxFrequency: 200,\r\n    expectedMaxPeaksPerMinute: 300,\r\n    initialAbsoluteThreshold: 0.4,\r\n    initialRelativeThreshold: 0.5,\r\n    sustainAbsoluteThreshold: 0.4,\r\n    sustainRelativeThreshold: 0.5\r\n  }));\r\n\r\n  const treble = file.arrayBuffer().then((byteBuffer) => getPeaks(byteBuffer, overallVolume, {\r\n    minFrequency: 2048,\r\n    maxFrequency: null,\r\n    expectedMaxPeaksPerMinute: 120,\r\n    initialAbsoluteThreshold: 0.4,\r\n    initialRelativeThreshold: 0.5,\r\n    sustainAbsoluteThreshold: 0.25,\r\n    sustainRelativeThreshold: 0.35\r\n  }));\r\n\r\n  return Promise.all([tags, subBass, bass, beat, treble])\r\n    .then((values): TrackAnalysis => {\r\n      const [tagResult, subBassResult, bassResult, beatResult, trebleResult] = values;\r\n      const trackLength = overallVolume.length / ANALYZER_SAMPLE_RATE;\r\n      const keyFromTags = getKeyTagValue(tagResult);\r\n\r\n      let detectedBpm = getBpmTagValue(tagResult);\r\n\r\n      // Attempt to detect the BPM from the peaks if either:\r\n      // 1) We couldn't find it in tags\r\n      // 2) We're in development (so we can compare results easily)\r\n      if (!detectedBpm) {\r\n        detectedBpm = getBpmFromPeaks(beatResult, trackLength);\r\n      }\r\n      else if (process.env.NODE_ENV !== 'production') {\r\n        let bpmFromPeaks = getBpmFromPeaks(beatResult, trackLength);\r\n        console.debug(`tag BPM: ${detectedBpm}\\tcalculated BPM: ${bpmFromPeaks}`);\r\n      }\r\n\r\n      const analysis = new TrackAnalysis()\r\n      analysis.title = tagResult.tags.title ?? 'Unknown Title';\r\n      analysis.artist = tagResult.tags.artist ?? 'Unknown Artist';\r\n      analysis.bpm = detectedBpm ?? 120;\r\n      analysis.length = trackLength;\r\n      analysis.key = keyFromTags;\r\n      analysis.subBass = subBassResult;\r\n      analysis.bass = bassResult;\r\n      analysis.beat = beatResult;\r\n      analysis.treble = trebleResult;\r\n      analysis.trackHash = Math.floor(file.lastModified + file.size) + 1;\r\n\r\n      return analysis;\r\n    });\r\n}\r\n","import * as THREE from 'three';\r\nimport { OpenKey, TrackAnalysis } from './TrackAnalysis';\r\n\r\n/**\r\n * A theme to use for the visualizer.\r\n */\r\nexport interface Theme {\r\n  name: string;\r\n\r\n  /**\r\n   * Contains theming information relevant to the BassTunnel component.\r\n   */\r\n  bass: {\r\n    /**\r\n     * The color to use for wireframes that form the \"tunnel\".\r\n     */\r\n    wireframeColor: THREE.Color;\r\n\r\n    /**\r\n     * The color to use for panels that fill different parts of the tunnel.\r\n     */\r\n    panelColor: THREE.Color;\r\n  },\r\n\r\n  /**\r\n   * Contains theming information relevant to the BeatQueue component.\r\n   */\r\n  beat: {\r\n    /**\r\n     * The color to use for incoming beat peaks.\r\n     */\r\n    color: THREE.Color;\r\n  },\r\n\r\n  /**\r\n   * Contains theming information relevant to the TrebleQueue component.\r\n   */\r\n  treble: {\r\n    /**\r\n     * The sprite color to use for incoming treble peaks.\r\n     */\r\n    spriteColor: THREE.Color;\r\n\r\n    /**\r\n     * The path to the sprite texture to use for incoming treble peaks.\r\n     */\r\n    spriteTexture: string;\r\n\r\n    /**\r\n     * The light color to use for incoming treble peaks.\r\n     */\r\n    lightColor: THREE.Color;\r\n  },\r\n\r\n  /**\r\n   * Contains theming information relevant to the FrequencyGrid component.\r\n   */\r\n  frequencyGrid: {\r\n    /**\r\n     * The color to use for drawing frequency lines.\r\n     */\r\n    lineColor: THREE.Color;\r\n  },\r\n\r\n  /**\r\n   * Contains theming information relevant to the overall visualizer and BackgroundManager component.\r\n   */\r\n  background: {\r\n    /**\r\n     * The color to use for filling the background scene.\r\n     */\r\n    fillColor: THREE.Color;\r\n\r\n    /**\r\n     * The color to use for the sun.\r\n     */\r\n    sunColor: THREE.Color;\r\n\r\n    /**\r\n     * The color to use for the \"burst\" lines that rotate around the sun.\r\n     */\r\n    burstLineColor: THREE.Color;\r\n\r\n    /**\r\n     * The standard color to use for stars in the background.\r\n     */\r\n    starColor: THREE.Color;\r\n\r\n    /**\r\n     * The color to use for \"flashed\" stars in the background.\r\n     */\r\n    starFlashColor: THREE.Color;\r\n  },\r\n\r\n  /**\r\n   * Contains theming information for the overall application UI.\r\n   */\r\n  ui: {\r\n    textColor: THREE.Color;\r\n\r\n    backgroundColor: THREE.Color;\r\n\r\n    disabledBackgroundColor: THREE.Color;\r\n\r\n    focusBackgroundColor: THREE.Color;\r\n\r\n    borderColor: THREE.Color;\r\n  }\r\n}\r\n\r\nconst BLACK_COLOR = new THREE.Color(0x000000);\r\nconst WHITE_COLOR = new THREE.Color(0xFFFFFF);\r\n\r\n/**\r\n * Gets the sRGB value to use in luma calculations for the specified color component.\r\n * @param floatColor The color component, on a 0.0-1.0 scale.\r\n * @returns The corresponding luma component.\r\n * @see {@link https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef}\r\n */\r\nfunction getLumaComponent(floatColor: number): number {\r\n  const cutoff = 0.03928;\r\n\r\n  if (floatColor <= cutoff) {\r\n    return floatColor / 12.92;\r\n  }\r\n  else {\r\n    return Math.pow(((floatColor + 0.055) / 1.055), 2.4);\r\n  }\r\n}\r\n\r\n/**\r\n * Gets the luma value for the specified color.\r\n * @param color The color.\r\n * @returns The corresponding luma value.\r\n * @see {@link https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef}\r\n */\r\nfunction getLuma(color: THREE.Color): number {\r\n  return (0.2126 * getLumaComponent(color.r)) + (0.7152 * getLumaComponent(color.g)) + (0.0722 * getLumaComponent(color.b));\r\n}\r\n\r\n/**\r\n * The threshold against which the color is considered dark enough to support legible white text.\r\n * @see {@link https://lesscss.org/functions/#color-operations-contrast}\r\n */\r\nconst LIGHT_LUMA_THRESHOLD = 0.43;\r\n\r\n/**\r\n * Gets a black or white color to contrast against the provided color.\r\n * @param color The color to check against.\r\n * @returns The equivalent contrasting color.\r\n */\r\nexport function getContrast(color: THREE.Color): THREE.Color {\r\n  if (getLuma(color) < LIGHT_LUMA_THRESHOLD) {\r\n    return WHITE_COLOR;\r\n  }\r\n  else {\r\n    return BLACK_COLOR;\r\n  }\r\n}\r\n\r\nfunction generateThemeForColor(name: string, baseColor: THREE.Color, secondaryColor: THREE.Color, tertiaryColor: THREE.Color | null = null): Theme {\r\n  // Default the tertiary color if not specified\r\n  if (tertiaryColor === null) {\r\n    tertiaryColor = new THREE.Color(baseColor).lerp(secondaryColor, 0.5);\r\n  }\r\n\r\n  // Determine the UI text color to use\r\n  let uiTextColor: THREE.Color;\r\n  let uiDisabledBgColor: THREE.Color;\r\n  let uiFocusBgColor: THREE.Color;\r\n\r\n  if (getLuma(baseColor) < LIGHT_LUMA_THRESHOLD) {\r\n    uiTextColor = WHITE_COLOR;\r\n    uiDisabledBgColor = new THREE.Color(baseColor).lerp(BLACK_COLOR, 0.3);\r\n    uiFocusBgColor = new THREE.Color(baseColor).lerp(WHITE_COLOR, 0.2);\r\n  }\r\n  else {\r\n    uiTextColor = BLACK_COLOR;\r\n    uiDisabledBgColor = new THREE.Color(baseColor).lerp(WHITE_COLOR, 0.3);\r\n    uiFocusBgColor = new THREE.Color(baseColor).lerp(BLACK_COLOR, 0.2);\r\n  }\r\n\r\n  return {\r\n    name: name,\r\n    bass: {\r\n      wireframeColor: new THREE.Color(tertiaryColor).lerp(BLACK_COLOR, 0.3),\r\n      panelColor: new THREE.Color(tertiaryColor)\r\n    },\r\n    beat: {\r\n      color: new THREE.Color(baseColor)\r\n    },\r\n    treble: {\r\n      spriteColor: new THREE.Color(baseColor).lerp(WHITE_COLOR, 0.65),\r\n      spriteTexture: process.env.PUBLIC_URL + '/textures/extendring.png',\r\n      lightColor: new THREE.Color(baseColor).lerp(WHITE_COLOR, 0.75),\r\n    },\r\n    frequencyGrid: {\r\n      lineColor: new THREE.Color(secondaryColor)\r\n    },\r\n    background: {\r\n      fillColor: new THREE.Color(baseColor).lerp(BLACK_COLOR, 0.97),\r\n      sunColor: new THREE.Color(baseColor).lerp(secondaryColor, 0.75).lerp(WHITE_COLOR, 0.5),\r\n      burstLineColor: new THREE.Color(baseColor).lerp(secondaryColor, 0.75).lerp(WHITE_COLOR, 0.25),\r\n      starColor: new THREE.Color(baseColor).lerp(secondaryColor, 0.75).lerp(WHITE_COLOR, 0.1),\r\n      starFlashColor: new THREE.Color(baseColor).lerp(secondaryColor, 0.75)\r\n    },\r\n    ui: {\r\n      textColor: uiTextColor,\r\n      backgroundColor: new THREE.Color(baseColor),\r\n      disabledBackgroundColor: uiDisabledBgColor,\r\n      focusBackgroundColor: uiFocusBgColor,\r\n      borderColor: new THREE.Color(secondaryColor)\r\n    }\r\n  };\r\n}\r\n\r\nexport const defaultTheme = generateThemeForColor('default', new THREE.Color(0xff6600), new THREE.Color(0xff3333), new THREE.Color(0xff9933));\r\n\r\nconst magentaTheme = generateThemeForColor('magenta', new THREE.Color(0xff66ff), new THREE.Color(0xff3399), new THREE.Color(0x0033ff));\r\nconst indigoTheme = generateThemeForColor('indigo', new THREE.Color(0xcc00ff), new THREE.Color(0x6666ff), new THREE.Color(0x6633ff));\r\nconst darkBlueTheme = generateThemeForColor('deep blue', new THREE.Color(0x0033ff), new THREE.Color(0xcc9900), new THREE.Color(0x00cccc));\r\nconst midBlueTheme = generateThemeForColor('mid blue', new THREE.Color(0x6699ff), new THREE.Color(0x66cc66), new THREE.Color(0x3366ff));\r\nconst lightBlueTheme = generateThemeForColor('light blue', new THREE.Color(0x99ccff), new THREE.Color(0xff66ff), new THREE.Color(0x33ff33));\r\nconst blueGreenTheme = generateThemeForColor('blue-green', new THREE.Color(0x00ffff), new THREE.Color(0xcc6600), new THREE.Color(0x339999));\r\nconst greenTheme = generateThemeForColor('green', new THREE.Color(0x00ff00), new THREE.Color(0xFF0099), new THREE.Color(0x00ff99));\r\nconst yellowGreenTheme = generateThemeForColor('yellow-green', new THREE.Color(0x99ffcc), new THREE.Color(0xffcc33), new THREE.Color(0x33cc00));\r\nconst yellowTheme = generateThemeForColor('yellow', new THREE.Color(0xffcc00), new THREE.Color(0x3333FF), new THREE.Color(0xcccc33));\r\nconst orangeTheme = generateThemeForColor('orange', new THREE.Color(0xff6600), new THREE.Color(0x33FFFF), new THREE.Color(0xff0000));\r\nconst redTheme = generateThemeForColor('red', new THREE.Color(0xff0000), new THREE.Color(0x99FFcc), new THREE.Color(0xff6699));\r\nconst pinkTheme = generateThemeForColor('pink', new THREE.Color(0xff99cc), new THREE.Color(0xff3333), new THREE.Color(0xcc33cc));\r\n\r\nconst hotdogStandTheme = generateThemeForColor('hotdog stand', new THREE.Color(0xff0000), new THREE.Color(0xffff00));\r\nconst fluorescentTheme = generateThemeForColor('fluorescent', new THREE.Color(0xff00ff), new THREE.Color(0x00ff00));\r\nconst plasmaPowerSaverTheme = generateThemeForColor('plasma power saver', new THREE.Color(0x0000ff), new THREE.Color(0xff00ff), new THREE.Color(0xcc0066));\r\n\r\n/**\r\n * An array of all themes that can be assigned randomly by getThemeForTrack.\r\n */\r\nexport const ALL_THEMES = [\r\n  defaultTheme,\r\n  magentaTheme,\r\n  indigoTheme,\r\n  darkBlueTheme,\r\n  midBlueTheme,\r\n  lightBlueTheme,\r\n  blueGreenTheme,\r\n  greenTheme,\r\n  yellowGreenTheme,\r\n  yellowTheme,\r\n  orangeTheme,\r\n  redTheme,\r\n  pinkTheme,\r\n  hotdogStandTheme,\r\n  fluorescentTheme,\r\n  plasmaPowerSaverTheme\r\n];\r\n\r\nexport function getThemeForTrack(track: TrackAnalysis): Theme {\r\n  if (track === null) {\r\n    return defaultTheme;\r\n  }\r\n\r\n  // Randomly assign a key if we didn't detect one \r\n  if (track.key === null) {\r\n    const keyIndex = track.getTrackRandomInt(0, ALL_THEMES.length - 1);\r\n    return ALL_THEMES[keyIndex];\r\n  }\r\n\r\n  // Map keys to specific themes\r\n  switch(track.key) {\r\n    case OpenKey.C_Major:\r\n    case OpenKey.A_Minor:\r\n      return magentaTheme;\r\n\r\n    case OpenKey.G_Major:\r\n    case OpenKey.E_Minor:\r\n      return indigoTheme;\r\n\r\n    case OpenKey.D_Major:\r\n    case OpenKey.B_Minor:\r\n      return darkBlueTheme;\r\n\r\n    case OpenKey.A_Major:\r\n    case OpenKey.F_Sharp_Minor:\r\n      return midBlueTheme;\r\n\r\n    case OpenKey.E_Major:\r\n    case OpenKey.C_Sharp_Minor:\r\n      return lightBlueTheme;\r\n\r\n    case OpenKey.B_Major:\r\n    case OpenKey.G_Sharp_Minor:\r\n      return blueGreenTheme;\r\n\r\n    case OpenKey.F_Sharp_Major:\r\n    case OpenKey.D_Sharp_Minor:\r\n      return greenTheme;\r\n\r\n    case OpenKey.D_Flat_Major:\r\n    case OpenKey.B_Flat_Minor:\r\n      return yellowGreenTheme;\r\n\r\n    case OpenKey.A_Flat_Major:\r\n    case OpenKey.F_Minor:\r\n      return yellowTheme;\r\n\r\n    case OpenKey.E_Flat_Major:\r\n    case OpenKey.C_Minor:\r\n      return orangeTheme;\r\n\r\n    case OpenKey.B_Flat_Major:\r\n    case OpenKey.G_Minor:\r\n      return redTheme;\r\n\r\n    case OpenKey.F_Major:\r\n    case OpenKey.D_Minor:\r\n      return pinkTheme;\r\n\r\n    case OpenKey.OffKey:\r\n      return hotdogStandTheme;\r\n\r\n    default:\r\n      return defaultTheme;\r\n  }\r\n}\r\n\r\nexport function getNextTheme(currentTheme: Theme): Theme {\r\n  const currentThemeIndex = ALL_THEMES.indexOf(currentTheme);\r\n\r\n  // Return the first theme if we didn't find a match or we need to wrap around\r\n  if (currentThemeIndex === -1 || currentThemeIndex === ALL_THEMES.length - 1) {\r\n    return ALL_THEMES[0];\r\n  }\r\n\r\n  return ALL_THEMES[currentThemeIndex + 1];\r\n}\r\n","import create, { GetState, SetState } from 'zustand';\r\nimport { StoreApiWithSubscribeWithSelector, subscribeWithSelector } from 'zustand/middleware'\r\n\r\nimport { EmptyTrackAnalysis, TrackAnalysis } from './TrackAnalysis';\r\nimport { defaultTheme, Theme } from './themes';\r\n\r\ninterface VisualizerState {\r\n  /**\r\n   * The analysis for the current track being played.\r\n   */\r\n  analysis: TrackAnalysis;\r\n\r\n  /**\r\n   * The theme to use.\r\n   */\r\n  theme: Theme;\r\n\r\n  /**\r\n   * A time stamp to indicate that the current track's audio has been seeked.\r\n   */\r\n  audioLastSeeked: number;\r\n\r\n  setAnalysis: (newAnalysis: TrackAnalysis) => void;\r\n\r\n  setTheme: (newTheme: Theme) => void;\r\n\r\n  indicateAudioSeeked: () => void;\r\n}\r\n\r\nexport const useStore = create<\r\n  VisualizerState,\r\n  SetState<VisualizerState>,\r\n  GetState<VisualizerState>,\r\n  StoreApiWithSubscribeWithSelector<VisualizerState>\r\n>(subscribeWithSelector((set) => ({\r\n  analysis: EmptyTrackAnalysis,\r\n  theme: defaultTheme,\r\n  audioLastSeeked: 0,\r\n\r\n  setAnalysis: (newAnalysis) => set(state => { state.analysis = newAnalysis }),\r\n  setTheme: (newTheme) => set(state => { state.theme = newTheme }),\r\n  indicateAudioSeeked: () => set(state => { state.audioLastSeeked = Date.now() })\r\n})));","import { useEffect } from 'react';\r\nimport { css } from \"styled-components\";\r\n\r\nimport { useStore } from '../store/visualizerStore';\r\n\r\n/**\r\n * A path for a round-rect background to use for dynamic icon generation.\r\n * Extracted from a 64x64 version of the logo SVG.\r\n */\r\nconst bevelPath = new Path2D('M64,12.8C64,5.735 58.265,0 51.2,0L12.8,0C5.735,0 0,5.735 0,12.8L0,51.2C0,58.265 5.735,64 12.8,64L51.2,64C58.265,64 64,58.265 64,51.2L64,12.8Z');\r\n\r\n/**\r\n * A path for a waveform to use for dynamic icon generation.\r\n * Extracted from a 64x64 version of the logo SVG.\r\n */\r\nconst waveformPath = new Path2D('M-0.063,32C-0.063,32 0.1,14.756 0.706,14.762C1.308,14.768 1.352,48.687 2.623,48.679C3.713,48.672 4.033,19.674 6.498,19.72C8.476,19.757 9.898,44.125 11.665,44.137C13.269,44.148 15.225,27.314 18.123,27.262C19.97,27.228 22.316,34.293 24.748,34.262C26.547,34.239 29.486,30.126 31.915,30.179C33.821,30.22 36.836,32.346 39.185,32.262C41.258,32.188 44.23,31.313 45.976,31.262C47.511,31.217 51.354,32.125 53.396,32.058C55.048,32.004 58.987,31.707 60.222,31.672C61.416,31.638 62.61,31.788 63.804,31.845');\r\n\r\n/**\r\n * A path for a star shape to use for dynamic icon generation.\r\n * Extracted from a 64x64 version of the logo SVG.\r\n */\r\nconst firstStarPath = new Path2D('M25.418,10.25L27.74,9.882L27.993,11.48L29.435,10.745L30.502,12.84L29.06,13.575L30.204,14.719L28.542,16.381L27.398,15.237L26.663,16.679L24.568,15.612L25.303,14.17L23.705,13.917L24.073,11.595L25.671,11.848L25.418,10.25Z');\r\n\r\n/**\r\n * A path for a star shape to use for dynamic icon generation.\r\n * Extracted from a 64x64 version of the logo SVG.\r\n */\r\nconst secondStarPath = new Path2D('M44.075,49.242L45.903,47.762L46.921,49.02L47.802,47.663L49.774,48.943L48.893,50.3L50.456,50.719L49.847,52.99L48.284,52.571L48.369,54.187L46.021,54.31L45.936,52.694L44.426,53.274L43.583,51.079L45.094,50.499L44.075,49.242Z');\r\n\r\nfunction AppStyles(): JSX.Element {\r\n  const uiTheme = useStore((state) => state.theme.ui);\r\n\r\n  useEffect(() => useStore.subscribe(\r\n    (state) => state.theme.ui,\r\n    (newUiTheme) => {\r\n      // Update the theme-color meta tag to match our main color\r\n      document.querySelector('meta[name=\"theme-color\"]')?.setAttribute('content', newUiTheme.backgroundColor.getStyle());\r\n\r\n      // Create a dummy canvas\r\n      const canvasElem = document.createElement('canvas') as HTMLCanvasElement;\r\n      canvasElem.setAttribute('width', '64px');\r\n      canvasElem.setAttribute('height', '64px');\r\n\r\n      // Try to get a 2D rendering context\r\n      const ctx = canvasElem.getContext('2d', { alpha: true, desynchronized: true });\r\n\r\n      if (ctx) {\r\n        // If found, fill our bevel style and stroke in the waveform and stars.\r\n        ctx.fillStyle = newUiTheme.backgroundColor.getStyle();\r\n        ctx.fill(bevelPath);\r\n\r\n        ctx.strokeStyle = newUiTheme.textColor.getStyle();\r\n        ctx.lineWidth = 2;\r\n        ctx.stroke(waveformPath);\r\n\r\n        ctx.lineWidth = 1;\r\n        ctx.stroke(firstStarPath);\r\n        ctx.stroke(secondStarPath);\r\n\r\n        // Convert to a data URL and use it to generate the favicon\r\n        const iconUrl = canvasElem.toDataURL('image/png');\r\n        document.querySelector('link[rel=\"icon\"]')?.setAttribute('href', iconUrl);\r\n      }\r\n\r\n      canvasElem.remove();\r\n    }),\r\n    []);\r\n\r\n  // Because we want to make this a reactive component, we can't manually use something like createGlobalStyle,\r\n  // which handles component generation.\r\n  return (\r\n    <style\r\n      type=\"text/css\">\r\n      {css`\r\n        html {\r\n          --ui-color-text: ${uiTheme.textColor.getStyle()};\r\n          --ui-color-contrast: ${uiTheme.backgroundColor.getStyle()};\r\n          --ui-color-contrast-disabled: ${uiTheme.disabledBackgroundColor.getStyle()};\r\n          --ui-color-contrast-focus: ${uiTheme.focusBackgroundColor.getStyle()};\r\n          --ui-color-border: ${uiTheme.borderColor.getStyle()};\r\n      }`}\r\n    </style>\r\n  );\r\n}\r\n\r\nexport default AppStyles;\r\n","/**\r\n * Generates a numeric array consisting of the numbers spanning the range [0, total) in sequential order.\r\n * @param total The total number of elements to return.\r\n * @returns The corresponding array.\r\n */\r\nexport function generateNumericArray(total: number): number[] {\r\n  return Array.from(Array(total).keys());\r\n}\r\n","import { RefObject, useEffect, useMemo, useRef } from 'react';\r\nimport * as THREE from 'three';\r\nimport { useFrame } from '@react-three/fiber';\r\n\r\nimport { generateNumericArray } from '../utils';\r\nimport { TrackAnalysis } from '../store/TrackAnalysis';\r\nimport { useStore } from '../store/visualizerStore';\r\n\r\nconst QUARTER_TURN = Math.PI / 2;\r\n\r\nconst SEGMENT_DEPTH = 5;\r\nconst SEGMENT_WIDTH = 2;\r\nconst SEGMENT_HEIGHT = 15;\r\n\r\nconst SEGMENTS_PER_SIDE = 20;\r\nconst START_DEPTH = SEGMENT_DEPTH;\r\n\r\n// When we normally try to display a standard box geometry using wireframes,\r\n// it will display each side using two triangles. We want pure lines,\r\n// so we'll use a set of lines (with appropriate scaling) to approximate quads.\r\nconst boxLineGeometry = new THREE.BufferGeometry();\r\n\r\nboxLineGeometry.setFromPoints([\r\n  // Right line, front face\r\n  new THREE.Vector3(0.5, -0.5, 0.5),\r\n  new THREE.Vector3(0.5, 0.5, 0.5),\r\n\r\n  // Top line, front face\r\n  new THREE.Vector3(0.5, 0.5, 0.5),\r\n  new THREE.Vector3(-0.5, 0.5, 0.5),\r\n\r\n  // Left line, front face\r\n  new THREE.Vector3(-0.5, 0.5, 0.5),\r\n  new THREE.Vector3(-0.5, -0.5, 0.5),\r\n\r\n  // Bottom line, front face\r\n  new THREE.Vector3(-0.5, -0.5, 0.5),\r\n  new THREE.Vector3(0.5, -0.5, 0.5),\r\n\r\n  // Top-left faces connector\r\n  new THREE.Vector3(-0.5, 0.5, 0.5),\r\n  new THREE.Vector3(-0.5, 0.5, -0.5),\r\n\r\n  // Bottom-left faces connector\r\n  new THREE.Vector3(-0.5, -0.5, 0.5),\r\n  new THREE.Vector3(-0.5, -0.5, -0.5),\r\n\r\n  // Top-right faces connector\r\n  new THREE.Vector3(0.5, 0.5, 0.5),\r\n  new THREE.Vector3(0.5, 0.5, -0.5),\r\n\r\n  // Bottom-right faces connector\r\n  new THREE.Vector3(0.5, -0.5, 0.5),\r\n  new THREE.Vector3(0.5, -0.5, -0.5),\r\n\r\n  // Right line, back face\r\n  new THREE.Vector3(0.5, -0.5, -0.5),\r\n  new THREE.Vector3(0.5, 0.5, -0.5),\r\n\r\n  // Top line, back face\r\n  new THREE.Vector3(0.5, 0.5, -0.5),\r\n  new THREE.Vector3(-0.5, 0.5, -0.5),\r\n\r\n  // Left line, back face\r\n  new THREE.Vector3(-0.5, 0.5, -0.5),\r\n  new THREE.Vector3(-0.5, -0.5, -0.5),\r\n\r\n  // Bottom line, back face\r\n  new THREE.Vector3(-0.5, -0.5, -0.5),\r\n  new THREE.Vector3(0.5, -0.5, -0.5),\r\n]);\r\n\r\n/**\r\n * The material to use for all wireframe lines.\r\n */\r\nconst boxLineMaterial = new THREE.LineBasicMaterial();\r\n\r\n/**\r\n  * The geometry to use for all filler panels.\r\n  */\r\nconst panelFillGeometry = new THREE.PlaneGeometry();\r\n \r\n/**\r\n  * The material to use for all filler panels.\r\n  */\r\nconst panelFillMaterial = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, transparent: true, opacity: 0.6 });\r\n\r\nconst enum SegmentDisplay {\r\n  SegmentHidden = 0,\r\n  MIN = SegmentHidden,\r\n  PlaneLeft = 1,\r\n  PlaneRight = 2,\r\n  PlaneFront = 3,\r\n  PlaneTop = 4,\r\n  PlaneBottom = 5,\r\n  PlaneHidden = 6,\r\n  MAX = PlaneHidden\r\n}\r\n\r\n/**\r\n * Randomizes the presentation of the provided tunnel segment based on the current track and time.\r\n * @param segmentIndex The index of the segment.\r\n * @param segment The group containing the wireframe box and the filler plane.\r\n * @param planeForSegment The mesh for the filler plane.\r\n * @param trackAnalysis The track information.\r\n * @param currentTrackTime The current track time.\r\n */\r\nfunction randomizeTunnelSegment(segmentIndex: number, segment: THREE.Group, planeForSegment: THREE.Mesh, trackAnalysis: TrackAnalysis, currentTrackTime: number): void {\r\n  // In most cases both the segment and filler plane will be visible, so default those.\r\n  segment.visible = true;\r\n  planeForSegment.visible = true;\r\n\r\n  // Randomly determine how this segment might appear based on the current time.\r\n  // If we're changing two segments in the same frame, we might run into overlap, \r\n  // and so it's a good idea to also incorporate the segment index so there are still variances\r\n  let segmentDisplayMode: SegmentDisplay;\r\n  \r\n  if (!trackAnalysis.isEmpty) {\r\n    segmentDisplayMode = trackAnalysis.getTrackSeededRandomInt(SegmentDisplay.MIN, SegmentDisplay.MAX, currentTrackTime + segmentIndex);\r\n  }\r\n  else {\r\n    segmentDisplayMode = SegmentDisplay.PlaneHidden;\r\n  }\r\n\r\n  switch(segmentDisplayMode) {\r\n    case SegmentDisplay.SegmentHidden:\r\n      segment.visible = false;\r\n      planeForSegment.visible = false;\r\n      break;\r\n\r\n    case SegmentDisplay.PlaneLeft:\r\n      planeForSegment.scale.set(SEGMENT_DEPTH, SEGMENT_HEIGHT, 1);\r\n      planeForSegment.position.set(-SEGMENT_WIDTH / 2, 0, 0);\r\n      planeForSegment.rotation.set(0, QUARTER_TURN, 0);\r\n      break;\r\n\r\n    case SegmentDisplay.PlaneRight:\r\n      planeForSegment.scale.set(SEGMENT_DEPTH, SEGMENT_HEIGHT, 1);\r\n      planeForSegment.position.set(SEGMENT_WIDTH / 2, 0, 0);\r\n      planeForSegment.rotation.set(0, QUARTER_TURN, 0);\r\n      break;\r\n\r\n    case SegmentDisplay.PlaneFront:\r\n      planeForSegment.scale.set(SEGMENT_WIDTH, SEGMENT_HEIGHT, 1);\r\n      planeForSegment.position.set(0, 0, SEGMENT_DEPTH / 2);\r\n      planeForSegment.rotation.set(0, 0, 0);\r\n      break;\r\n\r\n    case SegmentDisplay.PlaneTop:\r\n      planeForSegment.scale.set(SEGMENT_WIDTH, SEGMENT_DEPTH, 1);\r\n      planeForSegment.position.set(0, SEGMENT_HEIGHT / 2, 0);\r\n      planeForSegment.rotation.set(QUARTER_TURN, 0, 0);\r\n      break;\r\n\r\n    case SegmentDisplay.PlaneBottom:\r\n      planeForSegment.scale.set(SEGMENT_WIDTH, SEGMENT_DEPTH, 1);\r\n      planeForSegment.position.set(0, -SEGMENT_HEIGHT / 2, 0);\r\n      planeForSegment.rotation.set(QUARTER_TURN, 0, 0);\r\n      break;\r\n\r\n    case SegmentDisplay.PlaneHidden:\r\n      planeForSegment.visible = false;\r\n      break;\r\n\r\n    default:\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        console.trace(`unexpected display mode: ${segmentDisplayMode} for segment ${segmentIndex}`);\r\n      }\r\n      planeForSegment.visible = false;\r\n      break;\r\n  }\r\n}\r\n\r\nfunction getDepthForSegment(segmentIndex: number): number {\r\n  return START_DEPTH - (SEGMENT_DEPTH * (segmentIndex % SEGMENTS_PER_SIDE))\r\n}\r\n\r\nfunction BassTunnel(props: { audio: RefObject<HTMLAudioElement> }): JSX.Element {\r\n  const HORIZ_OFFSET = 12;\r\n  let nextBassIndex = 0;\r\n  let nextSubBassIndex = 0;\r\n  \r\n  const trackAnalysis = useStore(state => state.analysis);\r\n\r\n  // Because the wireframe/filler materials are cached across multiple renders, just ensure the colors reflects the state.\r\n  boxLineMaterial.color = useStore().theme.bass.wireframeColor;\r\n  panelFillMaterial.color = useStore().theme.bass.panelColor;\r\n  \r\n  useEffect(() => useStore.subscribe(\r\n    state => state.theme.bass.wireframeColor,\r\n    (newLineColor) => {\r\n      boxLineMaterial.color = newLineColor;\r\n    }),\r\n    []);\r\n  \r\n  useEffect(() => useStore.subscribe(\r\n    state => state.theme.bass.panelColor,\r\n    (newFillColor) => {\r\n      panelFillMaterial.color = newFillColor;\r\n    }),\r\n    []);\r\n\r\n  // Store references to each tunnel segment group and its constituent elements (box/plane)\r\n  const tunnelSegments = useRef<THREE.Group[]>([]);\r\n  const tunnelSegmentBoxes = useRef<THREE.LineSegments[]>([]);\r\n  const tunnelSegmentPlanes = useRef<THREE.Mesh[]>([]);\r\n\r\n  const tunnelSegmentElements = useMemo(() => {\r\n    return generateNumericArray(SEGMENTS_PER_SIDE * 2)\r\n      .map((segmentIndex) => {\r\n        return <group\r\n          ref={(grp: THREE.Group) => tunnelSegments.current[segmentIndex] = grp}\r\n          key={segmentIndex}\r\n        >\r\n          <lineSegments\r\n            ref={(seg: THREE.LineSegments) => tunnelSegmentBoxes.current[segmentIndex] = seg}\r\n            scale={[SEGMENT_WIDTH, SEGMENT_HEIGHT, SEGMENT_DEPTH]}\r\n            geometry={boxLineGeometry}\r\n            material={boxLineMaterial}\r\n          />\r\n          <mesh\r\n            ref={(plane: THREE.Mesh) => tunnelSegmentPlanes.current[segmentIndex] = plane}\r\n            geometry={panelFillGeometry}\r\n            material={panelFillMaterial}\r\n          />\r\n        </group>\r\n      });\r\n    }, []);\r\n\r\n  // Determine the amount of time it should take for a segment to scroll the length of the tunnel\r\n  const tunnelTraversalPeriodSeconds = useMemo(() => {\r\n      return trackAnalysis.secondsPerMeasure * 0.5 * SEGMENTS_PER_SIDE;\r\n    },\r\n    [trackAnalysis]);\r\n\r\n  // Reset the initial arrangement when the track analysis changes\r\n  useEffect(() => {\r\n    for(let segmentIndex = 0; segmentIndex < tunnelSegments.current.length; segmentIndex++) {\r\n      const groupForSegment = tunnelSegments.current[segmentIndex];\r\n      const planeForSegment = tunnelSegmentPlanes.current[segmentIndex];\r\n\r\n      // Position the overall group for the segment.\r\n      // The first half of the segments will be on the left side, the remainder will be on the right\r\n      // Each half will be positioned one behind the other\r\n      const segmentDepth = getDepthForSegment(segmentIndex);\r\n\r\n      if (segmentIndex < SEGMENTS_PER_SIDE) {\r\n        groupForSegment.position.set(-HORIZ_OFFSET, 0, segmentDepth);\r\n      }\r\n      else {\r\n        groupForSegment.position.set(HORIZ_OFFSET, 0, segmentDepth);\r\n      }\r\n\r\n      // Randomize the presentation for initial display\r\n      randomizeTunnelSegment(segmentIndex, groupForSegment, planeForSegment, trackAnalysis, 0); \r\n    }\r\n  }, [trackAnalysis, tunnelSegments, tunnelSegmentPlanes]);\r\n\r\n  // Ensure we reset the next bass endpoint when the track gets seeked -\r\n  // useFrame will recalculate as needed \r\n  useEffect(() => useStore.subscribe(\r\n    state => [state.analysis, state.audioLastSeeked],\r\n    () => {\r\n      // eslint-disable-next-line react-hooks/exhaustive-deps\r\n      nextBassIndex = 0;\r\n\r\n      // eslint-disable-next-line react-hooks/exhaustive-deps\r\n      nextSubBassIndex = 0;\r\n    }),\r\n    []);\r\n\r\n  useFrame(() => {\r\n    // Determine the depth offset to apply to all segments\r\n    const TOTAL_DEPTH = SEGMENT_DEPTH * SEGMENTS_PER_SIDE;\r\n    const WRAP_DEPTH = getDepthForSegment(0) + (2 * SEGMENT_DEPTH);\r\n    let timeDepthOffset = 0;\r\n    let currentTrackTime = 0;\r\n    let bassScalingFactor = 0;\r\n    let subBassScalingFactor = 0;\r\n\r\n    if (props.audio.current !== null) {\r\n      currentTrackTime = props.audio.current.currentTime;\r\n      timeDepthOffset = TOTAL_DEPTH * (currentTrackTime % tunnelTraversalPeriodSeconds) / tunnelTraversalPeriodSeconds;\r\n    }\r\n\r\n    // See if we're currently during a bass period\r\n    for(let bassIndex = nextBassIndex; bassIndex < trackAnalysis.bass.length; bassIndex++) {\r\n      const curBass = trackAnalysis.bass[bassIndex];\r\n      // Ease in and out of the bass peak\r\n      const startTime = curBass.time - 0.25;\r\n      const endTime = curBass.end + 0.5;\r\n      let effectiveIntensity = curBass.intensity;\r\n\r\n      // If this is too early, stop looping\r\n      if (startTime > currentTrackTime) {\r\n        break;\r\n      }\r\n\r\n      // If we've already passed this bass peak, make sure we'll skip over it in subsequent frames\r\n      if (endTime < currentTrackTime) {\r\n        nextBassIndex++;\r\n        continue;\r\n      }\r\n\r\n      // We are somewhere during this peak period - because of that, update the intensity\r\n      // However, apply it less strongly if we're outside the actual peak\r\n      if (currentTrackTime < curBass.time) {\r\n        effectiveIntensity = THREE.MathUtils.mapLinear(currentTrackTime, startTime, curBass.time, 0, effectiveIntensity);\r\n      }\r\n      else if (currentTrackTime > curBass.end) {\r\n        effectiveIntensity = THREE.MathUtils.mapLinear(currentTrackTime, curBass.end, endTime, effectiveIntensity, 0);\r\n      }\r\n\r\n      // Use Math.max so that if we have multiple concurrent peaks, the strongest peak is what gets used\r\n      bassScalingFactor = Math.max(effectiveIntensity, bassScalingFactor);\r\n    }\r\n\r\n    // See if we're currently during a bass period\r\n    for(let subBassIndex = nextSubBassIndex; subBassIndex < trackAnalysis.subBass.length; subBassIndex++) {\r\n      const curSubBass = trackAnalysis.subBass[subBassIndex];\r\n      // Ease in and out of the sub-bass peak\r\n      const startTime = curSubBass.time - 0.5;\r\n      const endTime = curSubBass.end + 1.5;\r\n      let effectiveIntensity = curSubBass.intensity;\r\n\r\n      // If this is too early, stop looping\r\n      if (startTime > currentTrackTime) {\r\n        break;\r\n      }\r\n\r\n      // If we've already passed this peak, make sure we'll skip over it in subsequent frames\r\n      if (endTime < currentTrackTime) {\r\n        nextSubBassIndex++;\r\n        continue;\r\n      }\r\n\r\n      // We are somewhere during this peak period - because of that, update the intensity\r\n      // However, apply it less strongly if we're outside the actual peak\r\n      if (currentTrackTime < curSubBass.time) {\r\n        effectiveIntensity = THREE.MathUtils.mapLinear(currentTrackTime, startTime, curSubBass.time, 0, effectiveIntensity);\r\n      }\r\n      else if (currentTrackTime > curSubBass.end) {\r\n        effectiveIntensity = THREE.MathUtils.mapLinear(currentTrackTime, curSubBass.end, endTime, effectiveIntensity, 0);\r\n      }\r\n\r\n      // Use Math.max so that if we have multiple concurrent peaks, the strongest peak is what gets used\r\n      subBassScalingFactor = Math.max(effectiveIntensity, subBassScalingFactor);\r\n    }\r\n\r\n    for(let segmentIndex = 0; segmentIndex < tunnelSegments.current.length; segmentIndex++) {\r\n      const segment = tunnelSegments.current[segmentIndex];\r\n      let segmentDepth = getDepthForSegment(segmentIndex) + timeDepthOffset;\r\n\r\n      // Hide all segments when we don't have a track analysis\r\n      segment.visible = !trackAnalysis.isEmpty;\r\n\r\n      // Wrap the group if it's past the camera\r\n      if (segmentDepth > WRAP_DEPTH) {\r\n        segmentDepth -= TOTAL_DEPTH;\r\n\r\n        // If this is the first time we've had to re-position the wrapped element, randomize the segment's appearance\r\n        if (segmentDepth < segment.position.z) {\r\n          const planeForSegment = tunnelSegmentPlanes.current[segmentIndex];\r\n          randomizeTunnelSegment(segmentIndex, segment, planeForSegment, trackAnalysis, currentTrackTime);\r\n        }\r\n      }\r\n\r\n      segment.position.z = segmentDepth;\r\n\r\n      // Scale each segment based on the bass (y)/sub-bass (x) intensity\r\n      segment.scale.set(1 + (subBassScalingFactor), 1 + (bassScalingFactor * 0.75), 1);\r\n    }\r\n  })\r\n\r\n  return (\r\n    <group>\r\n      {tunnelSegmentElements}\r\n    </group>\r\n  );\r\n}\r\n\r\nexport default BassTunnel;\r\n","import { RefObject, useEffect, useRef } from 'react';\r\nimport * as THREE from 'three';\r\nimport { useFrame } from '@react-three/fiber';\r\n\r\nimport { useStore } from '../store/visualizerStore';\r\nimport { generateNumericArray } from '../utils';\r\nimport Peak from '../store/Peak';\r\n\r\nfunction getBasePosition(sideIdx: number, totalSides: number, scale: number): THREE.Vector3 {\r\n  // Modulo the side index so that we'll always get a value that maps within [0, 360) degree range\r\n  let angle = ((sideIdx % totalSides) / totalSides) * 2 * Math.PI;\r\n\r\n  // For alternating sets, further perturb the angle\r\n  if (Math.ceil(sideIdx / totalSides) % 2 === 0) {\r\n    angle += Math.PI / totalSides;\r\n  } \r\n\r\n  return new THREE.Vector3(Math.cos(angle), Math.sin(angle), 0).multiplyScalar(scale);\r\n}\r\n\r\n/**\r\n * The geometry to use for all beat meshes.\r\n */\r\nconst beatGeometry = new THREE.SphereGeometry();\r\n\r\n/**\r\n * The material to use for all beat meshes.\r\n */\r\nconst beatMeshMaterial = new THREE.MeshPhongMaterial({ shininess: 0.5 });\r\n\r\nfunction BeatQueue(props: { audio: RefObject<HTMLAudioElement> }): JSX.Element {\r\n  let nextUnrenderedPeakIndex = 0;\r\n  let nextAvailableMeshIndex = 0;\r\n  const availableMeshesRing = useRef<THREE.Mesh[]>([]);\r\n  const SIDES = 6;\r\n  const RADIUS = 5;\r\n  const LOOKAHEAD_PERIOD = 1.5;\r\n  const DECAY_PERIOD = 0.25;\r\n  const PEAK_DEPTH_START = -200;\r\n  const PEAK_DEPTH_END = -10;\r\n\r\n  const trackAnalysis = useStore(state => state.analysis);\r\n\r\n  // Because the beat material is cached across multiple renders, just ensure the color reflects the state.\r\n  beatMeshMaterial.color = useStore().theme.beat.color;\r\n\r\n  useEffect(() => useStore.subscribe(\r\n    state => state.theme.beat.color,\r\n    (newBeatColor) => {\r\n      beatMeshMaterial.color = newBeatColor;\r\n    }),\r\n    []);\r\n\r\n  // Generate available meshes for use in a ring buffer\r\n  const availableMeshElements = \r\n    generateNumericArray(SIDES * 6).map((sideNumber) => {\r\n      return <mesh\r\n        key={sideNumber}\r\n        ref={(mesh: THREE.Mesh) => availableMeshesRing.current[sideNumber] = mesh}\r\n        visible={false}\r\n        position={getBasePosition(sideNumber, SIDES, RADIUS)}\r\n        geometry={beatGeometry}\r\n        material={beatMeshMaterial}\r\n      />\r\n    });\r\n\r\n  // Ensure we reset the next peak index when analysis changes (or we seeked).\r\n  // We're okay with just blowing away these values and letting useFrame re-calculate when it needs to\r\n  useEffect(() => useStore.subscribe(\r\n    state => [state.analysis, state.audioLastSeeked],\r\n    () => {\r\n      // eslint-disable-next-line react-hooks/exhaustive-deps\r\n      nextUnrenderedPeakIndex = 0;\r\n      \r\n      // eslint-disable-next-line react-hooks/exhaustive-deps\r\n      nextAvailableMeshIndex = 0;\r\n    }),\r\n    []);\r\n\r\n  useFrame((_state, delta) => {\r\n    if (props.audio.current === null) {\r\n      return;\r\n    }\r\n\r\n    const audioTime = props.audio.current.currentTime;\r\n    const lastRenderTime = Math.max(audioTime - delta, 0);\r\n\r\n    // Determine if we need to fill the ring buffer with any new meshes\r\n    for (let peakIdx = nextUnrenderedPeakIndex; peakIdx < trackAnalysis.beat.length; peakIdx++) {\r\n      const curPeak = trackAnalysis.beat[peakIdx];\r\n      const peakDisplayStart = curPeak.time - LOOKAHEAD_PERIOD;\r\n      const peakDisplayEnd = curPeak.end + DECAY_PERIOD;\r\n\r\n      // See if we're already too late for this peak - if so, skip ahead\r\n      if (lastRenderTime > peakDisplayEnd) {\r\n        nextUnrenderedPeakIndex++;\r\n        continue;\r\n      }\r\n\r\n      // Now see if we're too early for this peak - if so, exit out\r\n      if (peakDisplayStart > audioTime) {\r\n        break;\r\n      }\r\n\r\n      // Now we have a new peak to render. Assign it to the next available mesh\r\n      const meshForPeak = availableMeshesRing.current[nextAvailableMeshIndex];\r\n      meshForPeak.userData['peak'] = curPeak;\r\n      \r\n      // Switch around to the next mesh in the ring buffer\r\n      nextAvailableMeshIndex = (nextAvailableMeshIndex + 1) % availableMeshesRing.current.length;\r\n\r\n      // Ensure we're rendering the next peak\r\n      nextUnrenderedPeakIndex++;\r\n    }\r\n\r\n    // Now update the items in the ring buffer\r\n    for (let meshForPeak of availableMeshesRing.current)\r\n    {\r\n      const peakData = meshForPeak.userData['peak'] as Peak;\r\n\r\n      if (peakData === null || peakData === undefined) {\r\n        meshForPeak.visible = false;\r\n        continue;\r\n      }\r\n\r\n      const peakDisplayStart = peakData.time - LOOKAHEAD_PERIOD;\r\n      const peakDisplayEnd = peakData.end + DECAY_PERIOD;\r\n\r\n      // See if we've finished peaking, which means we should hide the mesh\r\n      if (peakDisplayStart > audioTime || peakDisplayEnd < lastRenderTime) {\r\n        meshForPeak.visible = false;\r\n        delete meshForPeak.userData['peak'];\r\n        continue;\r\n      }\r\n\r\n      // Make the mesh visible and lerp it to zoom in\r\n      meshForPeak.visible = true;\r\n      meshForPeak.position.z = THREE.MathUtils.mapLinear(audioTime, peakDisplayStart, peakDisplayEnd, PEAK_DEPTH_START, PEAK_DEPTH_END);\r\n\r\n      // Tweak scaling if we're during the actual beat\r\n      if (audioTime >= peakData.time && audioTime < peakDisplayEnd) {\r\n        meshForPeak.scale.setScalar(THREE.MathUtils.mapLinear(audioTime, peakData.time, peakDisplayEnd, 1.0, 2.0));\r\n      }\r\n      else {\r\n        meshForPeak.scale.setScalar(1);\r\n      }\r\n    }\r\n  });\r\n\r\n  return (\r\n    <group>\r\n      {availableMeshElements}\r\n    </group>\r\n  );\r\n}\r\n\r\nexport default BeatQueue;\r\n","import { RefObject, useEffect, useMemo, useRef } from 'react';\r\nimport * as THREE from 'three';\r\nimport { useFrame } from '@react-three/fiber';\r\n\r\nimport { generateNumericArray } from '../utils';\r\nimport { useStore } from '../store/visualizerStore';\r\n\r\n/**\r\n * The material to use for all frequency lines.\r\n */\r\nconst frequencyLineMaterial = new THREE.LineBasicMaterial();\r\n\r\nfunction FrequencyGrid(props: { audio: RefObject<HTMLAudioElement>, analyser: RefObject<AnalyserNode> }): JSX.Element {\r\n  // Track how many rows we have, where the first row starts, depth-wise, and the spacing between each row  \r\n  const FREQUENCY_ROWS: number = 10;\r\n  const STARTING_DEPTH: number = -10;\r\n  const DEPTH_SPACING: number = -20;\r\n\r\n  // XXX: LINE_BUCKETS should be equal to analyzer.frequencyBinCount\r\n  const LINE_BUCKETS = 64;\r\n  const BUCKET_WIDTH = 0.5;\r\n  const BUCKET_HEIGHT = 5.0;\r\n\r\n  // On either end, we want a set number of points to ease down the minimum/maximum frequencies to 0\r\n  // and avoid sharp cliffs\r\n  const ANCHOR_POINTS = 8;\r\n\r\n  // Pull our store items\r\n  const trackAnalysis = useStore(state => state.analysis);\r\n\r\n  // Because the line material is cached across multiple renders, just ensure the color reflects the state.\r\n  frequencyLineMaterial.color = useStore().theme.frequencyGrid.lineColor;\r\n\r\n  useEffect(() => useStore.subscribe(\r\n    state => state.theme.frequencyGrid.lineColor,\r\n    (newLineColor) => {\r\n      frequencyLineMaterial.color = newLineColor;\r\n    }),\r\n    []);\r\n\r\n  // Construct the set of points to use for each line\r\n  const pointSet = useMemo(() => {\r\n    const points: THREE.Vector3[] = [];\r\n\r\n    // Start by adding anchor points on the left-hand side and use a different scale just for the anchors\r\n    // Ideally we want something like\r\n    // |--25% anchors--|----50% points----|--25% anchors--|\r\n    const anchorIncrement = (LINE_BUCKETS * BUCKET_WIDTH) / (4 * ANCHOR_POINTS);\r\n    let currentX = -(anchorIncrement * ANCHOR_POINTS) - (LINE_BUCKETS * BUCKET_WIDTH / 2);\r\n\r\n    for (let i = 0; i < ANCHOR_POINTS; i++) {\r\n      points.push(new THREE.Vector3(currentX, 0, 0));\r\n      currentX += anchorIncrement;\r\n    }\r\n\r\n    // Now start distributing the \"normal\" points around zero\r\n    for(let i = 0; i < LINE_BUCKETS; i++) {\r\n      points.push(new THREE.Vector3(currentX, 0, 0));\r\n      currentX += BUCKET_WIDTH;\r\n    }\r\n\r\n    // Add the ending anchors\r\n    for (let i = 0; i < ANCHOR_POINTS; i++) {\r\n      points.push(new THREE.Vector3(currentX, 0, 0));\r\n      currentX += anchorIncrement;\r\n    }    \r\n\r\n    return points;\r\n  }, []);\r\n\r\n  // Construct the geometry from those points\r\n  const frequencyGeometry = useMemo(() => {\r\n    const geometry = new THREE.BufferGeometry();\r\n    geometry.setFromPoints(pointSet);\r\n    return geometry;\r\n  }, [pointSet]);\r\n\r\n  // Construct multiple lines from the geometry\r\n  const rowLines = useRef<THREE.Line[]>([]);\r\n  const rowElements = useMemo(() => {\r\n    return generateNumericArray(FREQUENCY_ROWS).map((rowIndex) => {\r\n      const line = new THREE.Line(frequencyGeometry, frequencyLineMaterial);\r\n      line.position.set(0, -10, STARTING_DEPTH + (DEPTH_SPACING * rowIndex));\r\n      line.scale.set(0.6, THREE.MathUtils.mapLinear(rowIndex, 0, FREQUENCY_ROWS - 1, 1.0, 0.1), 1.0);\r\n\r\n      // Ensure the line is stored in a mesh\r\n      rowLines.current[rowIndex] = line;\r\n\r\n      // Convert the line to the equivalent JSX element\r\n      return <primitive \r\n        object={line}\r\n        key={rowIndex}\r\n      />\r\n    })\r\n    }, [frequencyGeometry, STARTING_DEPTH, DEPTH_SPACING, FREQUENCY_ROWS]);\r\n\r\n  useFrame((state, delta) => {\r\n    if (props.analyser.current === null || props.audio.current === null) {\r\n      return;\r\n    }\r\n\r\n    const frequencies = new Uint8Array(props.analyser.current.frequencyBinCount);\r\n    props.analyser.current.getByteFrequencyData(frequencies);\r\n\r\n    // Skip over the four anchor points at the beginning and the four anchor points at the end\r\n    for(let i = 0; i < frequencies.length; i++) {\r\n      // Ensure that we're skipping over the anchors when accessing points, so that\r\n      // frequencies[0] will correspond with pointSet[ANCHOR_POINTS]\r\n      pointSet[i + ANCHOR_POINTS].y = (frequencies[i] / 255.0) * BUCKET_HEIGHT;\r\n    }\r\n\r\n    // Use the anchor points to scale down the edges\r\n    let leftmostFrequency = (frequencies[0] / 255.0) * BUCKET_HEIGHT;\r\n    let rightmostFrequency = (frequencies[frequencies.length - 1] / 255.0) * BUCKET_HEIGHT;\r\n\r\n    // Move outward on the lefthand side (but don't touch the bucket at 0)\r\n    for(let i = ANCHOR_POINTS - 1; i > 0; i--) {\r\n      leftmostFrequency = leftmostFrequency / 1.618;\r\n      pointSet[i].y = leftmostFrequency;\r\n    }\r\n\r\n    // Move outward on the righthand side (but again skip over the last bucket)\r\n    for (let i = LINE_BUCKETS + ANCHOR_POINTS; i < pointSet.length - 1; i++) {\r\n      rightmostFrequency = rightmostFrequency / 1.618;\r\n      pointSet[i].y = rightmostFrequency;\r\n    }\r\n\r\n    // Calculate how much of the measure, by percentage has elapsed by now\r\n    let measurePercentage = 0;\r\n    const secondsPerMeasure = trackAnalysis.secondsPerMeasure;\r\n\r\n    if (props.audio.current.currentTime > 0) {\r\n      measurePercentage = (props.audio.current.currentTime % secondsPerMeasure) / secondsPerMeasure;\r\n    }\r\n\r\n    // Update all of the rows\r\n    for(let rowIndex = 0; rowIndex < rowLines.current.length; rowIndex++) {\r\n      // Apply the point set to all line rows\r\n      const lineRow = rowLines.current[rowIndex];\r\n      const baseDepth = STARTING_DEPTH + (DEPTH_SPACING * rowIndex);\r\n\r\n      // Hide all line rows when we don't have a track analysis\r\n      lineRow.visible = !trackAnalysis.isEmpty;\r\n\r\n      lineRow.geometry.setFromPoints(pointSet);\r\n      lineRow.geometry.computeBoundingBox();\r\n\r\n      // Move forward the Z by the row spacing * the % of the measure completed.\r\n      // This ensures that each row will approach the previous row's starting point,\r\n      // but will snap back to the starting point once the new measure starts\r\n      if (props.audio.current.currentTime > 0) {\r\n        lineRow.position.z = baseDepth - (DEPTH_SPACING * measurePercentage);\r\n      }\r\n      else {\r\n        lineRow.position.z = baseDepth;\r\n      }\r\n    }\r\n  });\r\n\r\n  return (\r\n    <group>\r\n      {rowElements}\r\n    </group>\r\n  );\r\n}\r\n\r\nexport default FrequencyGrid;\r\n","import { RefObject, useEffect, useRef } from 'react';\r\nimport * as THREE from 'three';\r\nimport { useFrame } from '@react-three/fiber';\r\nimport { useTexture } from '@react-three/drei';\r\n\r\nimport { useStore } from '../store/visualizerStore';\r\nimport { generateNumericArray } from '../utils';\r\nimport Peak from '../store/Peak';\r\n\r\nfunction TrebleQueue(props: { audio: RefObject<HTMLAudioElement> }): JSX.Element {\r\n  let nextUnrenderedPeakIndex = 0;\r\n  let nextAvailableGroupIndex = 0;\r\n  const availableTrebleGroupsRing = useRef<THREE.Group[]>([]);\r\n  const QUEUE_SIZE = 20;\r\n  const LOOKAHEAD_PERIOD = 0.1;\r\n  const DECAY_PERIOD = 0.5;\r\n  const PEAK_DEPTH_START = -200;\r\n  const PEAK_DEPTH_END = 10;\r\n  const BASE_LIGHT_INTENSITY = 20;\r\n  const BASE_LIGHT_DISTANCE = 20;\r\n  const MIN_DISTRIBUTION_RADIUS = 12;\r\n  const MAX_DISTRIBUTION_RADIUS = 20;\r\n\r\n  const trackAnalysis = useStore(state => state.analysis);\r\n  const trebleTheme = useStore(state => state.theme.treble);\r\n  const spriteTexture = useTexture(trebleTheme.spriteTexture);\r\n\r\n  // Generate available sprites for use in a ring buffer\r\n  const availableSpriteElements = \r\n    generateNumericArray(QUEUE_SIZE).map((index) => {\r\n      return <group\r\n        key={index}\r\n        visible={false}\r\n        ref={(grp: THREE.Group) => availableTrebleGroupsRing.current[index] = grp}\r\n      >\r\n        {/* XXX: Don't change the order/contents without updating the useEffect that looks at the group's children */}\r\n        <sprite\r\n          scale={[15, 15, 1]}\r\n        >\r\n          <spriteMaterial\r\n            color={trebleTheme.spriteColor}\r\n            map={spriteTexture}\r\n            depthWrite={false}\r\n            transparent={true}\r\n            blending={THREE.CustomBlending}\r\n            blendEquation={THREE.AddEquation}\r\n            blendSrc={THREE.SrcAlphaFactor}\r\n            blendDst={THREE.OneFactor}\r\n          />\r\n        </sprite>\r\n        <pointLight\r\n          color={trebleTheme.lightColor}\r\n          castShadow={false}\r\n          distance={BASE_LIGHT_DISTANCE}\r\n        />\r\n      </group>\r\n    });\r\n\r\n  // Reset the peak indices when we seek or change tracks\r\n  useEffect(() => useStore.subscribe(\r\n    state => [state.analysis, state.audioLastSeeked],\r\n    () => {\r\n      // eslint-disable-next-line react-hooks/exhaustive-deps\r\n      nextUnrenderedPeakIndex = 0;\r\n      // eslint-disable-next-line react-hooks/exhaustive-deps\r\n      nextAvailableGroupIndex = 0;\r\n    }),\r\n    []);\r\n\r\n  useFrame((_state, delta) => {\r\n    if (props.audio.current === null) {\r\n      return;\r\n    }\r\n\r\n    const audioTime = props.audio.current.currentTime;\r\n    const lastRenderTime = Math.max(audioTime - delta, 0);\r\n\r\n    // Determine if we need to fill the ring buffer with any new meshes\r\n    for (let peakIdx = nextUnrenderedPeakIndex; peakIdx < trackAnalysis.treble.length; peakIdx++) {\r\n      const curPeak = trackAnalysis.treble[peakIdx];\r\n      const peakDisplayStart = curPeak.time - LOOKAHEAD_PERIOD;\r\n      const peakDisplayEnd = curPeak.end + DECAY_PERIOD;\r\n\r\n      // See if we're already too late for this peak - if so, skip ahead\r\n      if (lastRenderTime > peakDisplayEnd) {\r\n        nextUnrenderedPeakIndex++;\r\n        continue;\r\n      }\r\n\r\n      // Now see if we're too early for this peak - if so, exit out\r\n      if (peakDisplayStart > audioTime) {\r\n        break;\r\n      }\r\n\r\n      // Now we have a new peak to render. Assign it to the next available group/sprite\r\n      const groupForPeak = availableTrebleGroupsRing.current[nextAvailableGroupIndex];\r\n      groupForPeak.userData['peak'] = curPeak;\r\n\r\n      // Randomize the position of the group\r\n      const angle = trackAnalysis.getTrackSeededRandomInt(0, 359, curPeak.time) * THREE.MathUtils.DEG2RAD;\r\n      const radius = trackAnalysis.getTrackSeededRandomInt(MIN_DISTRIBUTION_RADIUS, MAX_DISTRIBUTION_RADIUS, curPeak.time);\r\n      \r\n      groupForPeak.position.x = Math.cos(angle) * radius;\r\n      groupForPeak.position.y = Math.sin(angle) * radius;\r\n      \r\n      // Switch around to the next sprite in the ring buffer\r\n      nextAvailableGroupIndex = (nextAvailableGroupIndex + 1) % availableTrebleGroupsRing.current.length;\r\n\r\n      // Ensure we're rendering the next peak\r\n      nextUnrenderedPeakIndex++;\r\n    }\r\n\r\n    // Now update the items in the ring buffer\r\n    for (let itemIdx = 0; itemIdx < availableTrebleGroupsRing.current.length; itemIdx++)\r\n    {\r\n      const groupForPeak = availableTrebleGroupsRing.current[itemIdx];\r\n      const peakData = groupForPeak.userData['peak'] as Peak;\r\n\r\n      if (peakData === null || peakData === undefined) {\r\n        groupForPeak.visible = false;\r\n        continue;\r\n      }\r\n\r\n      const peakDisplayStart = peakData.time - LOOKAHEAD_PERIOD;\r\n      const peakDisplayEnd = peakData.end + DECAY_PERIOD;\r\n\r\n      // See if we've finished peaking, which means we should hide the entire group\r\n      if (peakDisplayStart > audioTime || peakDisplayEnd < lastRenderTime) {\r\n        groupForPeak.visible = false;\r\n        delete groupForPeak.userData['peak'];\r\n        continue;\r\n      }\r\n\r\n      // Make the group visible and lerp it to zoom in\r\n      groupForPeak.visible = true;\r\n      groupForPeak.position.z = THREE.MathUtils.mapLinear(audioTime, peakDisplayStart, peakDisplayEnd, PEAK_DEPTH_START, PEAK_DEPTH_END);\r\n\r\n      // Fade the sprite opacity if we're in the lookahead/decay period\r\n      const spriteForPeak = groupForPeak.children[0] as THREE.Sprite;\r\n      const lightForPeak = groupForPeak.children[1] as THREE.PointLight;\r\n\r\n      if (audioTime < peakData.time) {\r\n        const scale = THREE.MathUtils.mapLinear(audioTime, peakDisplayStart, peakData.time, 0, 1);\r\n\r\n        spriteForPeak.material.opacity = scale;\r\n        lightForPeak.intensity = BASE_LIGHT_INTENSITY * scale;\r\n      }\r\n      else if (audioTime > peakData.end) {\r\n        const scale = THREE.MathUtils.mapLinear(audioTime, peakData.end, peakDisplayEnd, 1, 0);\r\n\r\n        spriteForPeak.material.opacity = scale;\r\n        lightForPeak.intensity = BASE_LIGHT_INTENSITY * scale;\r\n      }\r\n      else {\r\n        spriteForPeak.material.opacity = 1;\r\n        lightForPeak.intensity = BASE_LIGHT_INTENSITY;\r\n      }\r\n    }\r\n  });\r\n\r\n  return (\r\n    <group>\r\n      {availableSpriteElements}\r\n    </group>\r\n  );\r\n}\r\n\r\nexport default TrebleQueue;\r\n","import { RefObject, useMemo, useRef } from 'react';\r\nimport * as THREE from 'three';\r\nimport { useFrame } from '@react-three/fiber';\r\nimport { useTexture } from '@react-three/drei';\r\n\r\nimport { useStore } from '../store/visualizerStore';\r\n\r\nconst FULL_RADIANS = 2 * Math.PI;\r\n\r\nfunction buildLineRingGeometry(innerRadius: number, maxOuterRadius: number, perturbAngle: number): THREE.BufferGeometry {\r\n  const points: THREE.Vector3[] = [];\r\n  const LINE_COUNT = 120;\r\n  const ANGLE_PER_LINE = 360 / LINE_COUNT;\r\n  const extraLength = Math.max(maxOuterRadius - innerRadius, 1);\r\n\r\n  for (let pointNum = 0; pointNum < LINE_COUNT; pointNum++) {\r\n    const angle = ((pointNum * ANGLE_PER_LINE) + perturbAngle) * THREE.MathUtils.DEG2RAD;\r\n    const outerRadius = innerRadius + (((Math.sin(pointNum * innerRadius) + 1) * extraLength) / 2);\r\n    const x = Math.cos(angle);\r\n    const y = Math.sin(angle);\r\n\r\n    points.push(new THREE.Vector3(x * innerRadius, y * innerRadius, 0));\r\n    points.push(new THREE.Vector3(x * outerRadius, y * outerRadius, 0));\r\n  }\r\n\r\n  const geometry = new THREE.BufferGeometry();\r\n  geometry.setFromPoints(points);\r\n  return geometry; \r\n}\r\n\r\n/**\r\n * A geometry that is intended to act as a backdrop for the entire scene.\r\n */\r\nconst backdropGeometry = new THREE.PlaneGeometry(2048, 2048);\r\n\r\nfunction BackgroundManager(props: { audio: RefObject<HTMLAudioElement>, analyser: RefObject<AnalyserNode> }): JSX.Element {\r\n  // Load background textures\r\n  const textures = useTexture({\r\n    star_first: process.env.PUBLIC_URL + '/backgrounds/star-01.png',\r\n    star_first_glow: process.env.PUBLIC_URL + '/backgrounds/star-01-glow.png',\r\n    star_second: process.env.PUBLIC_URL + '/backgrounds/star-02.png',\r\n    star_second_glow: process.env.PUBLIC_URL + '/backgrounds/star-02-glow.png',\r\n    star_third: process.env.PUBLIC_URL + '/backgrounds/star-03.png',\r\n    star_third_glow: process.env.PUBLIC_URL + '/backgrounds/star-03-glow.png',\r\n    horizon: process.env.PUBLIC_URL + '/backgrounds/horizon.png'\r\n  });\r\n\r\n  // The star textures should repeat 4 times\r\n  [\r\n    textures.star_first,\r\n    textures.star_first_glow,\r\n    textures.star_second,\r\n    textures.star_second_glow,\r\n    textures.star_third,\r\n    textures.star_third_glow\r\n  ].forEach((tex) => {\r\n    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;\r\n    tex.repeat.setScalar(4);\r\n  });\r\n\r\n  // For the horizon, we just want to repeat the pixels when available\r\n  textures.horizon.wrapS = textures.horizon.wrapT = THREE.RepeatWrapping;\r\n\r\n  const trackAnalysis = useStore(state => state.analysis);\r\n  const backgroundTheme = useStore(state => state.theme.background); \r\n\r\n  // Set up the geometry for the line \"rings\"\r\n  const firstRingGeometry = useMemo(() => {\r\n    return buildLineRingGeometry(100, 120, 0);\r\n  }, []);\r\n\r\n  const secondRingGeometry = useMemo(() => {\r\n    return buildLineRingGeometry(125, 145, 15);\r\n  }, []);\r\n\r\n  const thirdRingGeometry = useMemo(() => {\r\n    return buildLineRingGeometry(150, 170, 30);\r\n  }, []);\r\n\r\n  // Determine motion amounts based on the BPM\r\n  const ringCycleSeconds = useMemo(() => {\r\n    return trackAnalysis.secondsPerMeasure * 8;\r\n  }, [trackAnalysis]);\r\n\r\n  const starCycleSeconds = useMemo(() => {\r\n    return trackAnalysis.secondsPerMeasure * 16;\r\n  }, [trackAnalysis]);\r\n\r\n  const horizonLayer = useRef<THREE.Mesh>(null!);\r\n  const firstStarLayer = useRef<THREE.Mesh>(null!);\r\n  const firstStarGlowLayer = useRef<THREE.Mesh>(null!);\r\n  const secondStarLayer = useRef<THREE.Mesh>(null!);\r\n  const secondStarGlowLayer = useRef<THREE.Mesh>(null!);\r\n  const thirdStarLayer = useRef<THREE.Mesh>(null!);\r\n  const thirdStarGlowLayer = useRef<THREE.Mesh>(null!);\r\n  const ringGroup = useRef<THREE.Group>(null!);\r\n  const firstLineRing = useRef<THREE.LineSegments>(null!);\r\n  const secondLineRing = useRef<THREE.LineSegments>(null!);\r\n  const thirdLineRing = useRef<THREE.LineSegments>(null!);\r\n  \r\n  useFrame((state) => {\r\n    state.scene.background = backgroundTheme.fillColor;\r\n\r\n    // Hide the ring group when we don't have a track analysis\r\n    ringGroup.current.visible = !trackAnalysis.isEmpty;\r\n\r\n    let currentTrackTime = 0;\r\n    let currentTrackDuration = 0;\r\n\r\n    if (props.audio.current !== null) {\r\n      currentTrackTime = props.audio.current.currentTime;\r\n      currentTrackDuration = props.audio.current.duration;\r\n    }\r\n\r\n    // Rotate the line \"rings\" over time\r\n    const ringPercentage = (currentTrackTime % ringCycleSeconds) / ringCycleSeconds;\r\n    const ringRotation = Math.sin(ringPercentage * FULL_RADIANS);\r\n\r\n    firstLineRing.current.rotation.set(0, 0, ringRotation);\r\n    secondLineRing.current.rotation.set(0, 0, 0.75 * ringRotation);\r\n    thirdLineRing.current.rotation.set(0, 0, 0.5 * ringRotation);\r\n\r\n    // Shift the star backgrounds over time\r\n    const starPercentage = (currentTrackTime % starCycleSeconds) / starCycleSeconds;\r\n    const starRotation = Math.sin(starPercentage * FULL_RADIANS);\r\n\r\n    firstStarLayer.current.position.x = 50 * starRotation;\r\n    firstStarGlowLayer.current.position.x = 50 * starRotation;\r\n    secondStarLayer.current.position.x = 60 * starRotation;\r\n    secondStarGlowLayer.current.position.x = 60 * starRotation;\r\n    thirdStarLayer.current.position.x = 70 * starRotation;\r\n    thirdStarGlowLayer.current.position.x = 70 * starRotation;\r\n\r\n    // If we're currently playing, tweak based on the music\r\n    let ringOpacityFactor = 0.0;\r\n    let ringScaleFactor = 0.0;\r\n    let horizonOpacityFactor = 0.0;\r\n    let starGlowFactor = 0.0;\r\n\r\n    if (currentTrackTime > 0 && props.analyser.current !== null) {\r\n      const frequencies = new Uint8Array(props.analyser.current.frequencyBinCount);\r\n      props.analyser.current.getByteFrequencyData(frequencies);\r\n\r\n      if (Number.isFinite(frequencies[15])) {\r\n        ringOpacityFactor = (frequencies[15] / 255.0) / 2;\r\n      }\r\n\r\n      if (Number.isFinite(frequencies[7])) {\r\n        ringScaleFactor = (frequencies[7] / 255.0) / 4;\r\n      }\r\n\r\n      if (Number.isFinite(frequencies[31])) {\r\n        horizonOpacityFactor = (frequencies[31] / 255.0) / 3;\r\n      }\r\n\r\n      if (Number.isFinite(frequencies[53])) {\r\n        starGlowFactor = (frequencies[53] / 255.0) / 5;\r\n      }\r\n    }\r\n\r\n    // Scale the rings opacity\r\n    (firstLineRing.current.material as THREE.Material).opacity = 0.5 + ringOpacityFactor;\r\n    (secondLineRing.current.material as THREE.Material).opacity = 0.4 + ringOpacityFactor;\r\n    (thirdLineRing.current.material as THREE.Material).opacity = 0.3 + ringOpacityFactor;\r\n\r\n    // Ease horizon flashes back down to 0.0, but cut off items that are asymptotically approaching 0 opacity\r\n    let horizonDampenedOpacity = (horizonLayer.current.material as THREE.Material).opacity * 0.95;\r\n\r\n    if (horizonDampenedOpacity <= 0.01) {\r\n      horizonDampenedOpacity = 0;\r\n    }\r\n\r\n    (horizonLayer.current.material as THREE.Material).opacity = Math.max(horizonOpacityFactor, horizonDampenedOpacity);\r\n\r\n    // Similarly scale the star \"glow\" layers\r\n    let starGlowDampenedOpacity = (firstStarGlowLayer.current.material as THREE.Material).opacity * 0.95;\r\n\r\n    if (starGlowDampenedOpacity <= 0.01) {\r\n      starGlowDampenedOpacity = 0;\r\n    }\r\n\r\n    const newStarGlowOpacity = Math.max(starGlowFactor, starGlowDampenedOpacity);\r\n\r\n    (firstStarGlowLayer.current.material as THREE.Material).opacity = newStarGlowOpacity;\r\n    (secondStarGlowLayer.current.material as THREE.Material).opacity = newStarGlowOpacity;\r\n    (thirdStarGlowLayer.current.material as THREE.Material).opacity = newStarGlowOpacity;\r\n\r\n    // Scale the rings based on our frequency-0driven factor\r\n    // If we are just coming off of an increase in scale, we want to ease back to the standard 1.0\r\n    const ringDampenedScale = firstLineRing.current.scale.x * 0.9;\r\n    const newRingScale = Math.max(1.0 + ringScaleFactor, ringDampenedScale);\r\n\r\n    firstLineRing.current.scale.x = firstLineRing.current.scale.y = newRingScale;\r\n    secondLineRing.current.scale.x = secondLineRing.current.scale.y = newRingScale;\r\n    thirdLineRing.current.scale.x = thirdLineRing.current.scale.y = newRingScale;\r\n\r\n    // Make the rings appear closer as we get closer to the end of the track\r\n    if (Number.isFinite(currentTrackDuration) && currentTrackDuration > 0) {\r\n      const ringGroupScale = THREE.MathUtils.mapLinear(currentTrackTime, 0, currentTrackDuration, 0.5, 1.5);\r\n      ringGroup.current.scale.x = ringGroup.current.scale.y = ringGroupScale;\r\n    }\r\n  })\r\n\r\n  return (\r\n    <group>\r\n      <mesh\r\n        ref={horizonLayer}\r\n        frustumCulled={false}\r\n        position={[0, 0, -300]}\r\n        scale={[8, 0.125, 1]}\r\n      >\r\n        <planeGeometry\r\n          args={[1024, 512]}\r\n        />\r\n        <meshBasicMaterial\r\n          color={backgroundTheme.starFlashColor}\r\n          map={textures.horizon}\r\n          transparent={true}\r\n          opacity={0.0}\r\n          fog={false}\r\n          depthWrite={false}\r\n          precision={'mediump'}\r\n        />\r\n       </mesh>\r\n      <group ref={ringGroup}>\r\n        <lineSegments\r\n          ref={firstLineRing}\r\n          position={[0, 0, -250]}\r\n          geometry={firstRingGeometry}\r\n        >\r\n          <lineBasicMaterial\r\n            color={backgroundTheme.burstLineColor}\r\n            transparent={true}\r\n            opacity={0.5}\r\n            fog={false}\r\n            precision={'lowp'}\r\n          />\r\n        </lineSegments>\r\n        <lineSegments\r\n          ref={secondLineRing}\r\n          position={[0, 0, -250]}\r\n          geometry={secondRingGeometry}\r\n        >\r\n          <lineBasicMaterial\r\n            color={backgroundTheme.burstLineColor}\r\n            transparent={true}\r\n            opacity={0.4}\r\n            fog={false}\r\n            precision={'lowp'}\r\n          />\r\n        </lineSegments>\r\n        <lineSegments\r\n          ref={thirdLineRing}\r\n          position={[0, 0, -250]}\r\n          geometry={thirdRingGeometry}\r\n        >\r\n          <lineBasicMaterial\r\n            color={backgroundTheme.burstLineColor}\r\n            transparent={true}\r\n            opacity={0.3}\r\n            fog={false}\r\n            precision={'lowp'}\r\n          />\r\n        </lineSegments>\r\n      </group>\r\n      <group>\r\n        <mesh\r\n          ref={firstStarGlowLayer}\r\n          position={[0, 0, -599]}\r\n          scale={[2, 2, 1]}\r\n          frustumCulled={false}\r\n          geometry={backdropGeometry}\r\n        >\r\n          <meshBasicMaterial\r\n            color={backgroundTheme.starFlashColor}\r\n            map={textures.star_first_glow}\r\n            transparent={true}\r\n            opacity={0.0}\r\n            fog={false}\r\n            depthWrite={false}\r\n            precision={'lowp'}\r\n          />\r\n        </mesh>\r\n        <mesh\r\n          ref={firstStarLayer}\r\n          position={[0, 0, -600]}\r\n          scale={[2, 2, 1]}\r\n          frustumCulled={false}\r\n          geometry={backdropGeometry}\r\n        >\r\n          <meshBasicMaterial\r\n            color={backgroundTheme.starColor}\r\n            map={textures.star_first}\r\n            transparent={true}\r\n            fog={false}\r\n            depthWrite={false}\r\n            precision={'lowp'}\r\n          />\r\n        </mesh>\r\n\r\n        <mesh\r\n          ref={secondStarGlowLayer}\r\n          position={[0, 0, -699]}\r\n          scale={[2, 2, 1]}\r\n          frustumCulled={false}\r\n          geometry={backdropGeometry}\r\n        >\r\n          <meshBasicMaterial\r\n            color={backgroundTheme.starFlashColor}\r\n            map={textures.star_second_glow}\r\n            transparent={true}\r\n            opacity={0.0}\r\n            fog={false}\r\n            depthWrite={false}\r\n            precision={'lowp'}\r\n          />\r\n        </mesh>\r\n        <mesh\r\n          ref={secondStarLayer}\r\n          position={[0, 0, -700]}\r\n          scale={[2, 2, 1]}\r\n          frustumCulled={false}\r\n          geometry={backdropGeometry}\r\n        >\r\n          <meshBasicMaterial\r\n            color={backgroundTheme.starColor}\r\n            map={textures.star_second}\r\n            transparent={true}\r\n            fog={false}\r\n            depthWrite={false}\r\n            precision={'lowp'}\r\n          />\r\n        </mesh>\r\n\r\n        <mesh\r\n          ref={thirdStarGlowLayer}\r\n          position={[0, 0, -799]}\r\n          scale={[2, 2, 1]}\r\n          frustumCulled={false}\r\n          geometry={backdropGeometry}\r\n        >\r\n          <meshBasicMaterial\r\n            color={backgroundTheme.starFlashColor}\r\n            map={textures.star_third_glow}\r\n            transparent={true}\r\n            opacity={0.0}\r\n            fog={false}\r\n            depthWrite={false}\r\n            precision={'lowp'}\r\n          />\r\n        </mesh>\r\n        <mesh\r\n          ref={thirdStarLayer}\r\n          position={[0, 0, -800]}\r\n          scale={[2, 2, 1]}\r\n          frustumCulled={false}\r\n          geometry={backdropGeometry}\r\n        >\r\n          <meshBasicMaterial\r\n            color={backgroundTheme.starColor}\r\n            map={textures.star_third}\r\n            transparent={true}\r\n            fog={false}\r\n            depthWrite={false}\r\n            precision={'lowp'}\r\n          />\r\n        </mesh>\r\n      </group>\r\n    </group>\r\n  );\r\n}\r\n\r\nexport default BackgroundManager;\r\n","import { RefObject, useRef } from 'react';\r\nimport * as THREE from 'three';\r\nimport { useFrame } from '@react-three/fiber';\r\nimport { EffectComposer, Bloom, GodRays } from '@react-three/postprocessing';\r\nimport { GodRaysEffect, BlendFunction, Resizer, KernelSize } from 'postprocessing';\r\n\r\nfunction VfxManager(props: { audio: RefObject<HTMLAudioElement>, analyser: RefObject<AnalyserNode>, sunMesh: THREE.Mesh }): JSX.Element {\r\n  const godRaysEffect = useRef<typeof GodRaysEffect>(null!);\r\n  \r\n  useFrame(() => {\r\n    if (props.audio.current === null || props.audio.current.currentTime <= 0 || props.analyser.current === null || godRaysEffect.current === null) {\r\n      return;\r\n    }\r\n\r\n    const frequencies = new Uint8Array(props.analyser.current.frequencyBinCount);\r\n    props.analyser.current.getByteFrequencyData(frequencies);\r\n\r\n    // Pulse the intensity of the god rays based on low-mid frequencies\r\n    // HACK: Party on the GodRaysMaterial and adjust values based on our frequency\r\n    // https://vanruesc.github.io/postprocessing/public/docs/file/src/effects/GodRaysEffect.js.html\r\n    const godRaysMaterial = godRaysEffect.current.godRaysPass.getFullscreenMaterial();\r\n    \r\n    if (Number.isFinite(frequencies[5])) {\r\n      const godRaysScale = frequencies[5] / 255.0;\r\n\r\n      godRaysMaterial.uniforms.decay.value = THREE.MathUtils.lerp(0.4, 0.93, godRaysScale);\r\n      godRaysMaterial.uniforms.exposure.value = THREE.MathUtils.lerp(0.4, 0.85, godRaysScale);\r\n    }\r\n    else {\r\n      godRaysMaterial.uniforms.decay.value = 0.4;\r\n      godRaysMaterial.uniforms.exposure.value = 0.4;\r\n    }\r\n  });\r\n\r\n  return (\r\n    <EffectComposer>\r\n      <Bloom\r\n        intensity={1}\r\n        width={Resizer.AUTO_SIZE}\r\n        height={Resizer.AUTO_SIZE}\r\n        kernelSize={KernelSize.MEDIUM}\r\n        luminanceThreshold={0.4}\r\n        luminanceSmoothing={0.1}\r\n      />\r\n      <GodRays\r\n        ref={godRaysEffect}\r\n        sun={props.sunMesh}\r\n        blur={10}\r\n        blendFunction={BlendFunction.Screen}\r\n        samples={60}\r\n        density={0.85}\r\n        decay={0.85}\r\n        weight={0.4}\r\n        exposure={0.4}\r\n        clampMax={1}\r\n        width={Resizer.AUTO_SIZE}\r\n        height={Resizer.AUTO_SIZE}\r\n        kernelSize={KernelSize.MEDIUM}\r\n      />\r\n    </EffectComposer>\r\n  )\r\n}\r\n\r\nexport default VfxManager;\r\n","import { RefObject, useEffect } from 'react';\r\nimport * as THREE from 'three';\r\nimport { Canvas } from '@react-three/fiber';\r\n\r\nimport { useStore } from '../store/visualizerStore';\r\n\r\nimport BassTunnel from './BassTunnel';\r\nimport BeatQueue from './BeatQueue';\r\nimport FrequencyGrid from './FrequencyGrid';\r\nimport TrebleQueue from './TrebleQueue';\r\nimport BackgroundManager from './BackgroundManager';\r\nimport VfxManager from './VfxManager';\r\n\r\n/**\r\n * The material to use for the sun.\r\n */\r\nconst sunMaterial = new THREE.MeshBasicMaterial({ transparent: true, fog: false });\r\n\r\n/**\r\n * The mesh to use for the sun.\r\n * Used to simplify ref-passing for the VFX manager.\r\n */\r\nconst sunMesh = new THREE.Mesh(new THREE.SphereGeometry(5), sunMaterial);\r\nsunMesh.frustumCulled = false;\r\nsunMesh.position.set(0, 0, -200);\r\n\r\nfunction Visualizer(props: { audio: RefObject<HTMLAudioElement>, analyser: RefObject<AnalyserNode> }): JSX.Element {\r\n  // Ensure that the sun's color is updated in response to theme changes\r\n  sunMaterial.color = useStore.getState().theme.background.sunColor;\r\n\r\n  useEffect(() => useStore.subscribe(\r\n    (state) => state.theme.background.sunColor,\r\n    (newSunColor) => {\r\n      sunMaterial.color = newSunColor;\r\n    }),\r\n    []);\r\n\r\n  return (\r\n    <Canvas camera={{position: [0, 0, 15]}}>\r\n      <ambientLight intensity={0.1} />\r\n      <directionalLight position={[0, 0, 20]} />\r\n      <primitive object={sunMesh} />\r\n      <BassTunnel audio={props.audio} />\r\n      <BeatQueue audio={props.audio} />\r\n      <FrequencyGrid audio={props.audio} analyser={props.analyser} />\r\n      <TrebleQueue audio={props.audio} />\r\n      <BackgroundManager audio={props.audio} analyser={props.analyser} />\r\n      <VfxManager audio={props.audio} analyser={props.analyser} sunMesh={sunMesh} />\r\n    </Canvas>\r\n  );\r\n}\r\n\r\nexport default Visualizer;","import React, { useRef, useCallback, useEffect, Suspense, useState } from 'react';\r\nimport { Stats } from '@react-three/drei';\r\n\r\nimport { analyzeTrack } from '../store/analyzer';\r\nimport { useStore } from '../store/visualizerStore';\r\nimport { getNextTheme, getThemeForTrack } from '../store/themes';\r\n\r\nimport './App.css';\r\nimport AppStyles from './AppStyles';\r\nimport Visualizer from './Visualizer';\r\nimport ThemeReviewer from './ThemeReviewer';\r\n\r\nfunction isSafari(): boolean {\r\n  return navigator.userAgent.indexOf('AppleWebKit') > -1 && navigator.userAgent.indexOf('Chrome') === -1;\r\n}\r\n\r\nfunction getAllowedAudioFileTypes(): string {\r\n  // Work around Webkit bug https://bugs.webkit.org/show_bug.cgi?id=34442\r\n  if (isSafari()) {\r\n    return '.mp3,.m4a,.ogg,.aac,.flac';\r\n  }\r\n  else {\r\n    return 'audio/*';\r\n  }\r\n}\r\n\r\nfunction App(): JSX.Element {\r\n  // Keep track of what we played last so we can free the object URL when switching tracks\r\n  let playingFileUrl: string = '';\r\n\r\n  // Wire up store hooks\r\n  const setStoreAnalysis = useStore(store => store.setAnalysis);\r\n  const setStoreTheme = useStore(store => store.setTheme);\r\n  const setStoreAudioSeeked = useStore(store => store.indicateAudioSeeked);\r\n\r\n  // XXX: Investigate supprting webkitAudioContext\r\n  // audioContext is a ref so that we can try to preserve state during fast-refresh in Chrome\r\n  const audioContext = useRef(new AudioContext());\r\n  const introElement = useRef<HTMLDivElement>(null!);\r\n  const sourceFileElement = useRef<HTMLInputElement>(null!);\r\n  const dummyFileButtonElement = useRef<HTMLButtonElement>(null!);\r\n  const [fileError, setFileError] = useState('');\r\n\r\n  // These are indirect refs set up via audio player callback\r\n  const audioPlayerElement = useRef<HTMLAudioElement | null>(null);\r\n  const audioAnalyser = useRef<AnalyserNode | null>(null);\r\n\r\n  // Like audioContext, this is a ref so that we can preserve it during Chrome fast-refresh\r\n  const mediaElementSourceNodes = useRef(new WeakMap<HTMLMediaElement, MediaElementAudioSourceNode>());\r\n  \r\n  // Ensure that the audio player has an audio context/analyzer node set up\r\n  const audioPlayerRef = useCallback(\r\n    (node: HTMLAudioElement) => {\r\n      if (node != null) {\r\n        // HACK: Work around hot-reload issues in Chrome by ensuring we re-use media source nodes\r\n        // https://stackoverflow.com/a/39725071\r\n        let audioSource: MediaElementAudioSourceNode;\r\n\r\n        if (mediaElementSourceNodes.current.has(node)) {\r\n          audioSource = mediaElementSourceNodes.current.get(node)!;\r\n        }\r\n        else {\r\n          audioSource = new MediaElementAudioSourceNode(audioContext.current, { mediaElement: node });\r\n          mediaElementSourceNodes.current.set(node, audioSource);\r\n        }\r\n\r\n        const analyser = new AnalyserNode(audioContext.current, { fftSize: 128 });\r\n\r\n        audioSource.connect(analyser);\r\n        analyser.connect(audioContext.current.destination);\r\n\r\n        audioPlayerElement.current = node;\r\n        audioAnalyser.current = analyser;\r\n      }\r\n    },\r\n    [audioContext],\r\n  );\r\n\r\n  const dummyFilePickerClicked = () => {\r\n    // HACK: Work around Mobile Safari autoplay limitations:\r\n    // http://www.schillmania.com/projects/soundmanager2/doc/technotes/#mobile-device-limitations\r\n    // If we have an audio player but haven't wired up a source yet, set one and load\r\n    if (isSafari() && audioContext.current && audioPlayerElement.current && !audioPlayerElement.current.src) {\r\n      try {\r\n        audioContext.current.resume();\r\n        audioPlayerElement.current.play();\r\n      }\r\n      catch {\r\n      }\r\n    }\r\n\r\n    // Now open the file picker\r\n    sourceFileElement.current.click();\r\n  };\r\n\r\n  const selectedFileChange = () => {\r\n    if (sourceFileElement.current?.files?.length === 1)\r\n    {\r\n      // Disable the file picker while we analyze the track\r\n      dummyFileButtonElement.current.disabled = true;\r\n      dummyFileButtonElement.current.innerText = \"Analyzing...\";\r\n      sourceFileElement.current.disabled = true;\r\n      sourceFileElement.current.readOnly = true;\r\n\r\n      // Reset the file error message\r\n      setFileError('');\r\n\r\n      // Disable the audio player while we analyze - we don't want\r\n      // weird concurrency issues when we're updating the element\r\n      if (audioPlayerElement.current) {\r\n        audioPlayerElement.current.pause();\r\n        audioPlayerElement.current.controls = false;\r\n      }\r\n\r\n      const trackFile = sourceFileElement.current.files[0];\r\n\r\n      analyzeTrack(trackFile)\r\n        .then((analyzerResult) => {\r\n          if (process.env.NODE_ENV !== 'production') {\r\n            console.log(analyzerResult);\r\n          }\r\n\r\n          // Create a URL for the new file\r\n          const newAudioUrl = URL.createObjectURL(trackFile);\r\n\r\n          // Switch the audio over to that\r\n          if (audioPlayerElement.current !== null) {\r\n            audioPlayerElement.current.src = newAudioUrl;\r\n            audioPlayerElement.current.load();\r\n\r\n            // HACK: As needed, start the audio player in an event loop *after* we've finished handling the file selection.\r\n            // Even though the file selector has been clicked, we're still in the event handler for that\r\n            // so Chrome's auto-play blocking doesn't consider the interaction \"complete\".\r\n            const initialContextPromise = audioContext.current.resume();\r\n            const initialPlayerPromise = audioPlayerElement.current.play();\r\n\r\n            if (initialContextPromise !== undefined && initialPlayerPromise !== undefined) {\r\n\r\n              Promise.all([initialContextPromise, initialPlayerPromise])\r\n                .then(() => {\r\n                  // We're good!\r\n                })\r\n                .catch(() => {\r\n                  // We need to wait for the next event loop\r\n                  window.setTimeout(() => {\r\n                    if (audioContext.current && audioPlayerElement.current) {\r\n                      audioContext.current.resume();\r\n                      audioPlayerElement.current.play();\r\n                    }\r\n                  });\r\n                });\r\n            }\r\n          }\r\n\r\n          // Free the previously-playing URL over if we had one\r\n          if (playingFileUrl !== '') {\r\n            URL.revokeObjectURL(playingFileUrl);\r\n          }\r\n\r\n          playingFileUrl = newAudioUrl;\r\n          introElement.current.hidden = true;\r\n          setStoreAnalysis(analyzerResult);\r\n          setStoreTheme(getThemeForTrack(analyzerResult));\r\n          setStoreAudioSeeked();\r\n        })\r\n        .catch((reason: any) => {\r\n          console.error(reason);\r\n          setFileError(`Error opening \"${trackFile?.name}\":\\n${reason.toString()}`);\r\n        })\r\n        .finally(() => {\r\n          // Re-enable the file picker\r\n          if (sourceFileElement.current) {\r\n            sourceFileElement.current.disabled = false;\r\n            sourceFileElement.current.readOnly = false;\r\n          }\r\n\r\n          if (dummyFileButtonElement.current) {\r\n            dummyFileButtonElement.current.disabled = false;\r\n            dummyFileButtonElement.current.innerText = \"Choose a track\";\r\n          }\r\n\r\n          if (audioPlayerElement.current && audioPlayerElement.current.src) {\r\n            audioPlayerElement.current.controls = true;\r\n          }\r\n        })\r\n    }\r\n  };\r\n\r\n  const cycleTheme = () => {\r\n    const nextTheme = getNextTheme(useStore.getState().theme);\r\n    \r\n    if (process.env.NODE_ENV !== 'production') {\r\n      console.debug(`switching to ${nextTheme.name} theme`);\r\n    }\r\n\r\n    setStoreTheme(nextTheme);\r\n  };\r\n\r\n  // Update the page title based on the currently playing song\r\n  useEffect(() => useStore.subscribe(\r\n    (state) => state.analysis, \r\n    (newAnalysis) => {\r\n      if (newAnalysis !== null && !newAnalysis.isEmpty && newAnalysis.artist !== '' && newAnalysis.title !== '') {\r\n        document.title = `Edenator (${newAnalysis.artist} - ${newAnalysis.title})`;\r\n      }\r\n      else {\r\n        document.title = 'Edenator';\r\n      }\r\n    }),\r\n    []);\r\n\r\n  return (\r\n    <div>\r\n      <AppStyles />\r\n      <div\r\n        ref={introElement}\r\n        className='app-title'\r\n      > \r\n        <h1>\r\n          Edenator\r\n        </h1>\r\n        <p>\r\n          An in-browser audio visualizer.\r\n          Start by choosing a track.\r\n        </p>\r\n        <p>\r\n          <strong><em>The visuals used by this application may not be suitable for\r\n          people with photosensitive epilepsy.</em></strong>\r\n        </p>\r\n        <p>\r\n          This visualizer requires support for WebGL 2.0 and the Web Audio API.\r\n          All audio processing is performed in-browser and is not uploaded.\r\n        </p>\r\n      </div>\r\n      <div\r\n        className=\"app-error\"\r\n        hidden={!fileError}\r\n      >\r\n        {fileError}\r\n        <button\r\n          type=\"button\"\r\n          onClick={() => setFileError('')}\r\n        >\r\n          Dismiss\r\n        </button>\r\n      </div>\r\n      <div id=\"filePicker\">\r\n        <button\r\n          type=\"button\"\r\n          ref={dummyFileButtonElement}\r\n          id=\"dummyFilePicker\"\r\n          className=\"btn\"\r\n          onClick={dummyFilePickerClicked}\r\n        >\r\n          Choose a track\r\n        </button>\r\n        <input\r\n          type=\"file\"\r\n          ref={sourceFileElement}\r\n          id=\"sourceFile\"\r\n          aria-label=\"Choose an audio file\"\r\n          accept={getAllowedAudioFileTypes()}\r\n          onChange={selectedFileChange}\r\n        />\r\n      </div>\r\n      <button\r\n        type=\"button\"\r\n        id=\"themeCycler\"\r\n        className=\"btn\"\r\n        onClick={cycleTheme}\r\n      >\r\n        Switch theme\r\n      </button>\r\n      <audio\r\n        ref={audioPlayerRef}\r\n        id=\"audioPlayer\"\r\n        onSeeked={setStoreAudioSeeked}\r\n      >\r\n      </audio>\r\n      <div id=\"canvas-container\">\r\n        <Suspense fallback={null}>\r\n          <Visualizer\r\n            audio={audioPlayerElement}\r\n            analyser={audioAnalyser}\r\n          />\r\n        </Suspense>\r\n      </div>\r\n      {/* Only include stats and theme reviewer in development */}\r\n      {\r\n        process.env.NODE_ENV !== 'production'\r\n        &&\r\n        <Stats\r\n          showPanel={0}\r\n          className=\"stats\"\r\n        />\r\n      }\r\n      {\r\n        process.env.NODE_ENV !== 'production'\r\n        &&\r\n        <ThemeReviewer />\r\n      }\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport './index.css';\nimport App from './components/App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}