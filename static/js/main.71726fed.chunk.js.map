{"version":3,"sources":["store/TrackAnalysis.ts","store/analyzer.ts","store/themes.ts","store/visualizerStore.ts","components/AppStyles.tsx","utils.ts","components/BassTunnel.tsx","components/BeatQueue.tsx","components/FrequencyGrid.tsx","components/TrebleQueue.tsx","components/SceneryQueue.tsx","components/BackgroundManager.tsx","components/VfxManager.tsx","components/Visualizer.tsx","components/App.tsx","reportWebVitals.ts","index.tsx"],"names":["OpenKey","TrackAnalysis","title","artist","bpm","length","key","subBass","bass","beat","treble","lulls","trackHash","isEmpty","this","low","high","getTrackSeededRandomInt","seed","random","Math","sin","floor","min","max","EmptyTrackAnalysis","ANALYZER_SAMPLE_RATE","RECOGNIZED_KEY_VALUES","Object","values","KEY_CONVERSION_CHART","G_Sharp_Minor","B_Major","D_Sharp_Minor","F_Sharp_Major","B_Flat_Minor","D_Flat_Major","F_Minor","A_Flat_Major","C_Minor","E_Flat_Major","G_Minor","B_Flat_Major","D_Minor","F_Major","A_Minor","C_Major","E_Minor","G_Major","B_Minor","D_Major","F_Sharp_Minor","A_Major","C_Sharp_Minor","E_Major","OffKey","getTrackTags","file","Promise","resolve","reject","Reader","read","onSuccess","tagData","onError","error","wrappedError","Error","info","name","findTagValue","tagCollection","standardTags","customTagDescriptions","standardTagName","tags","customTags","Array","isArray","targetDescription","customTag","data","id","description","getBpmTagValue","bpmTag","bpmValue","parseFloat","Number","isFinite","getKeyTagValue","keyTag","keyValue","toString","replace","includes","trim","getTrackVolume","audioData","window","OfflineAudioContext","decodeAudioData","then","decodedData","audioContext","bufferSource","createBufferSource","buffer","connect","destination","start","startRendering","renderedBuffer","rawSamples","getChannelData","smoothedVolume","Float32Array","SAMPLE_WINDOW","volume","frameIdx","rms","sum","windowedIndex","sqrt","getPeaks","overallVolume","analysisArgs","lastNode","minFrequency","minFrequencyFilter","BiquadFilterNode","type","Q","frequency","maxFrequency","maxFrequencyFilter","frames","peaksList","peaksHistogram","absoluteIntensity","abs","relativeIntensity","initialAbsoluteThreshold","initialRelativeThreshold","newPeak","time","intensity","intensityNormalized","end","sustainAbsoluteThreshold","sustainRelativeThreshold","push","roundedIntensity","toFixed","ceil","expectedMaximumPeaks","expectedMaxPeaksPerMinute","duration","sortedBuckets","keys","map","k","count","sort","a","b","intensityIndex","intensityCutoff","totalPeaks","filter","p","getBpmFromPeaks","beats","trackLength","minimumBeats","intervalHistogram","forEach","index","relativeIndex","interval","roundedInterval","tempoHistogram","tempoForInterval","roundedTempoForInterval","sortedTempos","intervals","modeIntervals","totalWeightedTempo","totalIntervals","tempo","averageTempo","medianIntervals","medianTempoIdx","tryInsertSortedLull","targetArray","maxArrayLength","newItem","targetIndex","splice","pop","findNearestActivity","activityArrays","nextActivityIndices","minimumTime","MAX_SAFE_INTEGER","minimumArrayIndex","minimumElementIndex","arrayIndex","activityArrayToScan","nextActivityIndex","activityAtIndex","elementIndex","findLulls","maximumLulls","minimumLullDuration","sortedLongestLulls","lullDurationCutoff","startOfCurrentPeriod","nearestActivityLocation","endingLull","nearestActivity","newLull","subdivideLongLulls","lullToSplit","shift","newDuration","midpoint","firstLull","secondLull","arrayBuffer","byteBuffer","all","tagResult","subBassResult","bassResult","beatResult","trebleResult","keyFromTags","detectedBpm","analysis","lastModified","size","maxLullsForTrack","minLullDuration","secondsPerMeasure","BLACK_COLOR","THREE","WHITE_COLOR","getLumaComponent","floatColor","pow","getLuma","color","r","g","LIGHT_LUMA_THRESHOLD","generateThemeForColor","baseColor","secondaryColor","uiTextColor","uiDisabledBgColor","uiFocusBgColor","tertiaryColor","lerp","wireframeColor","panelColor","spriteColor","spriteTexture","process","lightColor","frequencyGrid","lineColor","background","fillColor","sunColor","burstLineColor","starColor","starFlashColor","ui","textColor","backgroundColor","disabledBackgroundColor","focusBackgroundColor","borderColor","defaultTheme","magentaTheme","indigoTheme","darkBlueTheme","midBlueTheme","lightBlueTheme","blueGreenTheme","greenTheme","yellowGreenTheme","yellowTheme","orangeTheme","redTheme","pinkTheme","hotdogStandTheme","fluorescentTheme","plasmaPowerSaverTheme","ALL_THEMES","useStore","create","subscribeWithSelector","set","theme","audioLastSeeked","setAnalysis","newAnalysis","state","setTheme","newTheme","indicateAudioSeeked","Date","now","bevelPath","Path2D","waveformPath","firstStarPath","secondStarPath","AppStyles","uiTheme","useEffect","subscribe","newUiTheme","document","querySelector","setAttribute","getStyle","canvasElem","createElement","ctx","getContext","alpha","desynchronized","fillStyle","fill","strokeStyle","lineWidth","stroke","iconUrl","toDataURL","remove","css","generateNumericArray","total","from","QUARTER_TURN","PI","SEGMENT_HEIGHT","boxLineGeometry","setFromPoints","SegmentDisplay","boxLineMaterial","panelFillGeometry","panelFillMaterial","side","transparent","opacity","randomizeTunnelSegment","segmentIndex","segment","planeForSegment","trackAnalysis","currentTrackTime","visible","PlaneHidden","MIN","MAX","SegmentHidden","PlaneLeft","scale","position","rotation","PlaneRight","SEGMENT_WIDTH","PlaneFront","SEGMENT_DEPTH","PlaneTop","PlaneBottom","getDepthForSegment","BassTunnel","props","nextBassIndex","nextSubBassIndex","newLineColor","newFillColor","tunnelSegments","useRef","tunnelSegmentBoxes","tunnelSegmentPlanes","tunnelSegmentElements","useMemo","SEGMENTS_PER_SIDE","ref","grp","current","seg","geometry","material","plane","tunnelTraversalPeriodSeconds","groupForSegment","segmentDepth","useFrame","WRAP_DEPTH","timeDepthOffset","bassScalingFactor","subBassScalingFactor","audio","currentTime","bassIndex","curBass","startTime","endTime","effectiveIntensity","mapLinear","subBassIndex","curSubBass","z","getBasePosition","sideIdx","totalSides","angle","cos","multiplyScalar","beatGeometry","beatMeshMaterial","shininess","BeatQueue","nextUnrenderedPeakIndex","nextAvailableMeshIndex","availableMeshesRing","newBeatColor","availableMeshElements","SIDES","sideNumber","mesh","_state","delta","audioTime","lastRenderTime","peakIdx","curPeak","peakDisplayStart","userData","meshForPeak","peakData","undefined","peakDisplayEnd","setScalar","frequencyLineMaterial","FrequencyGrid","DEPTH_SPACING","pointSet","points","currentX","i","LINE_BUCKETS","frequencyGeometry","rowLines","rowElements","rowIndex","line","FREQUENCY_ROWS","object","analyser","frequencies","Uint8Array","frequencyBinCount","getByteFrequencyData","y","leftmostFrequency","rightmostFrequency","ANCHOR_POINTS","measurePercentage","lineRow","baseDepth","computeBoundingBox","TrebleQueue","nextAvailableGroupIndex","availableTrebleGroupsRing","trebleTheme","useTexture","availableSpriteElements","depthWrite","blending","blendEquation","blendSrc","blendDst","castShadow","distance","groupForPeak","DEG2RAD","radius","x","itemIdx","spriteForPeak","children","lightForPeak","BASE_RADIUS","NO_TRANSLATION","SCENERY_GEOMETRIES","rotateY","beatColorMaterial","fog","bassColorMaterial","starFlashColorMaterial","frequencyWireframeMaterial","wireframe","ALL_MATERIALS","assignMaterialsToMesh","forLull","groups","materialIndex","evenMaterialIndex","oddMaterialIndex","groupIndex","SceneryQueue","nextUnrenderedLullIndex","availableSceneryMeshesRing","lookaheadPeriod","m","newColor","lullIdx","curLull","lullDisplayStart","meshForLull","geometryIndex","geometryPosition","verticalScalingFactor","widthAndDepthScalingFactor","lullData","lullDisplayEnd","easedDownXScale","easedDownYScale","easedDownZScale","easedUpXScale","easedUpYScale","easedUpZScale","FULL_RADIANS","buildLineRingGeometry","innerRadius","maxOuterRadius","perturbAngle","extraLength","pointNum","outerRadius","backdropGeometry","BackgroundManager","textures","star_first","star_first_glow","star_second","star_second_glow","star_third","star_third_glow","horizon","tex","wrapS","wrapT","repeat","backgroundTheme","firstRingGeometry","secondRingGeometry","thirdRingGeometry","ringCycleSeconds","starCycleSeconds","horizonLayer","firstStarLayer","firstStarGlowLayer","secondStarLayer","secondStarGlowLayer","thirdStarLayer","thirdStarGlowLayer","ringGroup","firstLineRing","secondLineRing","thirdLineRing","scene","currentTrackDuration","ringPercentage","ringRotation","starPercentage","starRotation","ringOpacityFactor","ringScaleFactor","horizonOpacityFactor","starGlowFactor","horizonDampenedOpacity","starGlowDampenedOpacity","newStarGlowOpacity","ringDampenedScale","newRingScale","ringGroupScale","frustumCulled","args","precision","VfxManager","godRaysEffect","godRaysMaterial","godRaysPass","getFullscreenMaterial","godRaysScale","uniforms","decay","value","exposure","width","Resizer","AUTO_SIZE","height","kernelSize","KernelSize","MEDIUM","luminanceThreshold","luminanceSmoothing","sun","sunMesh","blur","blendFunction","BlendFunction","Screen","samples","density","weight","clampMax","sunMaterial","Visualizer","getState","newSunColor","camera","isSafari","navigator","userAgent","indexOf","App","playingFileUrl","setStoreAnalysis","store","setStoreTheme","setStoreAudioSeeked","AudioContext","introElement","sourceFileElement","dummyFileButtonElement","useState","fileError","setFileError","audioPlayerElement","audioAnalyser","mediaElementSourceNodes","WeakMap","audioPlayerRef","useCallback","node","audioSource","has","get","MediaElementAudioSourceNode","mediaElement","AnalyserNode","fftSize","className","hidden","onClick","src","resume","play","click","accept","onChange","files","disabled","innerText","readOnly","pause","controls","trackFile","analyzeTrack","analyzerResult","newAudioUrl","URL","createObjectURL","load","initialContextPromise","initialPlayerPromise","setTimeout","revokeObjectURL","track","keyIndex","getTrackRandomInt","getThemeForTrack","reason","console","nextTheme","currentTheme","currentThemeIndex","getNextTheme","onSeeked","fallback","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.71726fed.chunk.js","sourcesContent":["import Peak from \"./Peak\";\r\nimport Lull from \"./Lull\";\r\n\r\n/**\r\n * The different key values that are supported\r\n * by Open Key Notation.\r\n * @see {@link https://www.beatunes.com/en/open-key-notation.html}\r\n */\r\n export enum OpenKey {\r\n  C_Major = '1d',\r\n  A_Minor = '1m',\r\n\r\n  G_Major = '2d',\r\n  E_Minor = '2m',\r\n\r\n  D_Major = '3d',\r\n  B_Minor = '3m',\r\n\r\n  A_Major = '4d',\r\n  F_Sharp_Minor = '4m',\r\n\r\n  E_Major = '5d',\r\n  C_Sharp_Minor = '5m',\r\n\r\n  B_Major = '6m',\r\n  G_Sharp_Minor = '6d',\r\n\r\n  F_Sharp_Major = '7d',\r\n  D_Sharp_Minor = '7m',\r\n\r\n  D_Flat_Major = '8d',\r\n  B_Flat_Minor = '8m',\r\n\r\n  A_Flat_Major = '9d',\r\n  F_Minor = '9m',\r\n\r\n  E_Flat_Major = '10d',\r\n  C_Minor = '10m',\r\n\r\n  B_Flat_Major = '11d',\r\n  G_Minor = '11m',\r\n\r\n  F_Major = '12d',\r\n  D_Minor = '12m',\r\n\r\n  OffKey = '0'\r\n}\r\n\r\n/**\r\n * An analysis of a track to be played and visualized.\r\n */\r\nexport class TrackAnalysis\r\n{\r\n  public title: string = '';\r\n\r\n  public artist: string = '';\r\n\r\n  public bpm: number = 120;\r\n\r\n  public get secondsPerMeasure(): number {\r\n    // Assuming 4 beats per measure, BPM / 4 => measures/minute / 60 => BPM/240 for measures per second\r\n    // Use the inverse to get seconds per measure\r\n    return 240 / this.bpm;\r\n  }\r\n\r\n  /**\r\n   * The length of the song, in seconds.\r\n   */\r\n  public length: number = 0;\r\n\r\n  /**\r\n   * The key that was detected for the track, or null if not detected.\r\n   */\r\n  public key: OpenKey | null = null;\r\n\r\n  public subBass: Peak[] = [];\r\n\r\n  public bass: Peak[] = [];\r\n\r\n  public beat: Peak[] = [];\r\n\r\n  public treble: Peak[] = [];\r\n\r\n  /**\r\n   * The lulls in the song.\r\n   */\r\n  public lulls: Lull[] = [];\r\n\r\n  /**\r\n   * The hash to identify the track. This is not guaranteed to be unique, but is\r\n   * intended to help ensure deterministic results for the same track.\r\n   * \r\n   * This should be a positive non-zero finite integer.\r\n   */\r\n  public trackHash: number = 1;\r\n\r\n  /**\r\n   * Used to indicate \"empty\" instances for special default displays.\r\n   */\r\n  public isEmpty: boolean = false;\r\n\r\n  /**\r\n   * Gets a random integer that is deterministic for the track.\r\n   * @param low The minimum possible integer value.\r\n   * @param high The maximum possible integer value.\r\n   */\r\n  public getTrackRandomInt(low: number, high: number): number {\r\n    return this.getTrackSeededRandomInt(low, high, 0);\r\n  }\r\n\r\n  /**\r\n   * Gets a random integer that is deterministic for the track and specified seed.\r\n   * @param low The minimum possible integer value.\r\n   * @param high The maximum possible integer value.\r\n   * @param seed The seed to use.\r\n   */\r\n  public getTrackSeededRandomInt(low: number, high: number, seed: number): number {\r\n    // Because our random number seeds aren't as clustered around pi, this should vary *enough* for our purposes\r\n    // Something like THREE.MathUtils.seededRandom exhibits very little variation between small seed increments of 1,\r\n    // which doesn't work well for our purposes.\r\n    const random = (Math.sin(this.trackHash + seed) + 1) / 2;\r\n\r\n    // Because we're using Math.floor on the random result, we need to go 1 *above* the high\r\n    return low + Math.floor(random * (high - low + 1));\r\n  }\r\n\r\n  /**\r\n   * Gets a random float that is deterministic for the track and specified seed.\r\n   * @param min The minimum possible floating-point value.\r\n   * @param max The maximum possible floating-point value.\r\n   * @param seed The seed to use.\r\n   */\r\n  public getTrackSeededRandomFloat(min: number, max: number, seed: number) {\r\n    // Because our random number seeds aren't as clustered around pi, this should vary *enough* for our purposes\r\n    // Something like THREE.MathUtils.seededRandom exhibits very little variation between small seed increments of 1,\r\n    // which doesn't work well for our purposes.\r\n    const random = (Math.sin(this.trackHash + seed) + 1) / 2;\r\n\r\n    return min + (random * (max - min));    \r\n  }\r\n}\r\n\r\nexport const EmptyTrackAnalysis = new TrackAnalysis();\r\nEmptyTrackAnalysis.isEmpty = true;\r\n","import { Reader } from \"jsmediatags\";\r\nimport { FrameType, TagType } from \"jsmediatags/types\";\r\n\r\nimport Peak from \"./Peak\";\r\nimport Lull from \"./Lull\";\r\nimport { OpenKey, TrackAnalysis } from \"./TrackAnalysis\";\r\n\r\nconst ANALYZER_SAMPLE_RATE = 44100;\r\n\r\nconst RECOGNIZED_KEY_VALUES = Object.values(OpenKey);\r\n\r\n/**\r\n * Converts various key formats into a corresponding Open Key Notation representation.\r\n * @see {@link https://id3.org/id3v2.3.0|TKEY value definition} (TKEY)\r\n * @see {@link https://mixedinkey.com/harmonic-mixing-guide/|Camelot mixing keys}\r\n */\r\nconst KEY_CONVERSION_CHART: { [key: string]: OpenKey } = {\r\n  // A-flat/G-sharp minor\r\n  '1A': OpenKey.G_Sharp_Minor,\r\n  'G#m': OpenKey.G_Sharp_Minor,\r\n  'Abm': OpenKey.G_Sharp_Minor,\r\n\r\n  // B major\r\n  '1B': OpenKey.B_Major,\r\n  'B': OpenKey.B_Major,\r\n\r\n  // E-flat/D-sharp minor\r\n  '2A': OpenKey.D_Sharp_Minor,\r\n  'D#m': OpenKey.D_Sharp_Minor,\r\n  'Ebm': OpenKey.D_Sharp_Minor,\r\n\r\n  // F-sharp/G-flat major\r\n  '2B': OpenKey.F_Sharp_Major,\r\n  'F#': OpenKey.F_Sharp_Major,\r\n  'Gb': OpenKey.F_Sharp_Major,\r\n\r\n  // B-flat/A-sharp minor\r\n  '3A': OpenKey.B_Flat_Minor,\r\n  'A#m': OpenKey.B_Flat_Minor,\r\n  'Bbm': OpenKey.B_Flat_Minor,\r\n\r\n  // D-flat/C-sharp major\r\n  '3B': OpenKey.D_Flat_Major,\r\n  'C#': OpenKey.D_Flat_Major,\r\n  'Db': OpenKey.D_Flat_Major,\r\n\r\n  // F minor\r\n  '4A': OpenKey.F_Minor,\r\n  'Fm': OpenKey.F_Minor,\r\n\r\n  // A-flat/G-sharp major\r\n  '4B': OpenKey.A_Flat_Major,\r\n  'G#': OpenKey.A_Flat_Major,\r\n  'Ab': OpenKey.A_Flat_Major,\r\n\r\n  // C minor\r\n  '5A': OpenKey.C_Minor,\r\n  'Cm': OpenKey.C_Minor,\r\n\r\n  // E-flat/D-sharp major\r\n  '5B': OpenKey.E_Flat_Major,\r\n  'D#': OpenKey.E_Flat_Major,\r\n  'Eb': OpenKey.E_Flat_Major,\r\n\r\n  // G minor\r\n  '6A': OpenKey.G_Minor,\r\n  'Gm': OpenKey.G_Minor,\r\n\r\n  // B-flat/A-sharp major\r\n  '6B': OpenKey.B_Flat_Major,\r\n  'A#': OpenKey.B_Flat_Major,\r\n  'Bb': OpenKey.B_Flat_Major,\r\n\r\n  // D minor\r\n  '7A': OpenKey.D_Minor,\r\n  'Dm': OpenKey.D_Minor,\r\n\r\n  // F major\r\n  '7B': OpenKey.F_Major,\r\n  'F': OpenKey.F_Major,\r\n\r\n  // A minor\r\n  '8A': OpenKey.A_Minor,\r\n  'Am': OpenKey.A_Minor,\r\n\r\n  // C major\r\n  '8B': OpenKey.C_Major,\r\n  'C': OpenKey.C_Major,\r\n\r\n  // E minor\r\n  '9A': OpenKey.E_Minor,\r\n  'Em': OpenKey.E_Minor,\r\n\r\n  // G major\r\n  '9B': OpenKey.G_Major,\r\n  'G': OpenKey.G_Major,\r\n\r\n  // B minor\r\n  '10A': OpenKey.B_Minor,\r\n  'Bm': OpenKey.B_Minor,\r\n\r\n  // D major\r\n  '10B': OpenKey.D_Major,\r\n  'D': OpenKey.D_Major,\r\n\r\n  // G-flat/F-sharp minor\r\n  '11A': OpenKey.F_Sharp_Minor,\r\n  'F#m': OpenKey.F_Sharp_Minor,\r\n  'Gbm': OpenKey.F_Sharp_Minor,\r\n\r\n  // A major\r\n  '11B': OpenKey.A_Major,\r\n  'A': OpenKey.A_Major,\r\n\r\n  // D-flat/C-sharp minor\r\n  '12A': OpenKey.C_Sharp_Minor,\r\n  'C#m': OpenKey.C_Sharp_Minor,\r\n  'Dbm': OpenKey.C_Sharp_Minor,\r\n\r\n  // E major\r\n  '12B': OpenKey.E_Major,\r\n  'E': OpenKey.E_Major,\r\n\r\n  // Map off-key items to '0' placeholder\r\n  'o': OpenKey.OffKey,\r\n  'O': OpenKey.OffKey\r\n};\r\n\r\n/**\r\n * Describes the parameters to use for a specific song peak analysis pass.\r\n */\r\ninterface PeakAnalysisArgs {\r\n  minFrequency: number | null;\r\n  \r\n  maxFrequency: number | null;\r\n  \r\n  expectedMaxPeaksPerMinute: number;\r\n\r\n  initialAbsoluteThreshold: number;\r\n\r\n  initialRelativeThreshold: number;\r\n\r\n  sustainAbsoluteThreshold: number;\r\n\r\n  sustainRelativeThreshold: number;\r\n}\r\n\r\n/**\r\n * Attempts to get all media tags for the specified file.\r\n * @param file The file to open.\r\n * @returns A promise to retrieve all tags for the file.\r\n */\r\n function getTrackTags(file: File): Promise<TagType> {\r\n  return new Promise((resolve, reject) => {\r\n    new Reader(file)\r\n      .read({\r\n        onSuccess: (tagData) => {\r\n          resolve(tagData)\r\n        },\r\n        onError: (error) => {\r\n          // Wrap the jsmediatagsError into a true error object\r\n          // XXX: This won't let us use options.cause\r\n          const wrappedError = new Error(error.info);\r\n          wrappedError.name = 'MediaTagsError';\r\n\r\n          reject(wrappedError);\r\n        }\r\n      })\r\n  });\r\n}\r\n\r\n/**\r\n * Attempts to retrieve a tag value that could reside in any number of standard or custom tag values.\r\n * @param tagCollection The collection of tags to search through.\r\n * @param standardTags The standard tags to search for, in priority order.\r\n * @param customTagDescriptions The collection of user descriptions to search for, in priority order, in custom tags if no standard tags were found.\r\n * @returns The specified tag and value, if found; otherwise, null.\r\n */\r\nfunction findTagValue(tagCollection: TagType, standardTags: string[] | null, customTagDescriptions: string[] | null): FrameType | null {\r\n  // First check standard tags\r\n  if (standardTags !== null) {\r\n    for (let standardTagName of standardTags) {\r\n      if (standardTagName in tagCollection.tags) {\r\n        return tagCollection.tags[standardTagName];\r\n      }\r\n    }\r\n  }\r\n\r\n  // Then look for custom tags if any are defined\r\n  if (customTagDescriptions !== null) {\r\n    if ('TXXX' in tagCollection.tags) {\r\n      let customTags: FrameType[] = [];\r\n\r\n      // See if this is already an array\r\n      if (Array.isArray(tagCollection.tags['TXXX'])) {\r\n        customTags = tagCollection.tags['TXXX'];\r\n      }\r\n      else {\r\n        // Wrap the single tag in an array\r\n        customTags = [tagCollection.tags['TXXX']];\r\n      }\r\n\r\n      // Iterate through our custom descriptions\r\n      // XXX: This is technically quadratic but I don't know how long customTagDescriptions will be, realistically\r\n      for (let targetDescription of customTagDescriptions) {\r\n        for (let customTag of customTags) {\r\n          // In this case, the description and value we want is wrapped further in customTag.data\r\n          if ('user_description' in customTag.data && 'data' in customTag.data && customTag.data['user_description'] === targetDescription) {\r\n            return {\r\n              id: targetDescription,\r\n              description: targetDescription,\r\n              data: customTag.data['data']\r\n            };\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Attempts to retrieve the BPM of the track as stored in its metadata tags.\r\n * @param tagCollection The collection of tags to search.\r\n * @returns The fractional BPM, if found; otherwise, null.\r\n */\r\nfunction getBpmTagValue(tagCollection: TagType): number | null {\r\n  // Look for, in order of preference: BPM, TBPM, TMPO\r\n  // In addition, we want to support fBPM as set by programs like Traktor\r\n  let bpmTag = findTagValue(tagCollection, ['BPM', 'TBPM', 'TMPO'], ['fBPM']);\r\n  let bpmValue: any = '';\r\n\r\n  if (bpmTag === null) {\r\n    return null;\r\n  }\r\n  else {\r\n    bpmValue = bpmTag.data;\r\n  }\r\n\r\n  // Coalesce to a float value\r\n  if (typeof bpmValue === 'string') {\r\n    bpmValue = parseFloat(bpmValue);\r\n  }\r\n\r\n  // Make sure it's a finite number greater than zero\r\n  if (typeof bpmValue === 'number' && Number.isFinite(bpmValue) && bpmValue > 0) {\r\n    return bpmValue;\r\n  }\r\n  else {\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Attempts to retrieve the key of the track as stored in its metadata tags.\r\n * @param tagCollection The collection of tags to search.\r\n * @returns The OpenKey representation of the key, if found; otherwise, null.\r\n */\r\nfunction getKeyTagValue(tagCollection: TagType): OpenKey | null {\r\n  let keyTag = findTagValue(tagCollection, ['KEY', 'TKEY'], ['INITIAL KEY', 'INITIAL_KEY']);\r\n  let keyValue: string = '';\r\n\r\n  if (keyTag === null) {\r\n    return null;\r\n  }\r\n  else {\r\n    keyValue = keyTag.data.toString();\r\n  }\r\n\r\n  // Remove spaces\r\n  keyValue = keyValue.replace(/ /, '');\r\n\r\n  // Convert appropriate values to open key notation\r\n  if (keyValue in KEY_CONVERSION_CHART) {\r\n    keyValue = KEY_CONVERSION_CHART[keyValue];\r\n  }\r\n\r\n  // See if this matches a recognized key value\r\n  if (keyValue !== null && RECOGNIZED_KEY_VALUES.includes(keyValue.trim() as OpenKey)) {\r\n    return keyValue as OpenKey;\r\n  }\r\n  else {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      console.debug(`unrecognized key value: ${keyValue}`);\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Gets the track volume for the specified audio data.\r\n * @param audioData The raw encoded audio data.\r\n * @returns A promise for the equivalent mono track volume, smoothed and sampled at periodic \r\n */\r\nfunction getTrackVolume(audioData: ArrayBuffer): Promise<Float32Array> {\r\n  // For processing, downmix to mono\r\n  // HACK: We need to use one audio context just so we can decode the audio (and get the correct buffer length)\r\n  // After that, we use a *separate* audio context with the correct buffer length\r\n  // XXX: Look at getting webkitOfflineAudioContext supported as well\r\n  const dummyAudioContext = new window.OfflineAudioContext(1, ANALYZER_SAMPLE_RATE, ANALYZER_SAMPLE_RATE);\r\n\r\n  return dummyAudioContext.decodeAudioData(audioData)\r\n  .then((decodedData: AudioBuffer) => {\r\n    // if (process.env.NODE_ENV !== 'production') {\r\n    //   console.debug('audio decoded', decodedData);\r\n    // }\r\n    const audioContext = new window.OfflineAudioContext(1, decodedData.length, ANALYZER_SAMPLE_RATE);\r\n    const bufferSource = audioContext.createBufferSource();\r\n    bufferSource.buffer = decodedData;\r\n\r\n    // Now wire up the destination\r\n    bufferSource.connect(audioContext.destination);\r\n    bufferSource.start(0);\r\n    return audioContext.startRendering();\r\n  })\r\n  .then((renderedBuffer: AudioBuffer) => {\r\n    const rawSamples = renderedBuffer.getChannelData(0);\r\n\r\n    // Convert the channel data to the equivalent volume\r\n    // Code based on https://webaudio.github.io/web-audio-api/#vu-meter-mode\r\n    const smoothedVolume = new Float32Array(rawSamples);\r\n    const SAMPLE_WINDOW = Math.floor(ANALYZER_SAMPLE_RATE / 50);\r\n    const DECAY_FACTOR = 0.9;\r\n    let volume = 0.0;\r\n\r\n    for (let frameIdx = 0; frameIdx < rawSamples.length; frameIdx = frameIdx + SAMPLE_WINDOW)\r\n    {\r\n      // Calculate RMS across the sample window\r\n      let sum = 0;\r\n      let rms = 0;\r\n      let windowedIndex = 0;\r\n\r\n      for (windowedIndex = 0; windowedIndex < SAMPLE_WINDOW && (frameIdx + windowedIndex) < rawSamples.length; windowedIndex++) {\r\n        sum += rawSamples[frameIdx + windowedIndex] * rawSamples[frameIdx + windowedIndex];\r\n      }\r\n\r\n      rms = Math.sqrt(sum / (windowedIndex + 1));\r\n\r\n      // Update the volume\r\n      volume = Math.max(rms, volume * DECAY_FACTOR);\r\n\r\n      // Fill our sample window with that smoothed volume\r\n      for (windowedIndex = 0; windowedIndex < SAMPLE_WINDOW && (frameIdx + windowedIndex) < rawSamples.length; windowedIndex++) {\r\n        smoothedVolume[frameIdx + windowedIndex] = volume;\r\n      }\r\n    }\r\n\r\n    // if (process.env.NODE_ENV !== 'production') {\r\n    //   console.debug('volume analyzed', renderedBuffer, smoothedVolume);\r\n    // }\r\n    return smoothedVolume;\r\n  });\r\n}\r\n\r\n/**\r\n * Gets peaks from the provided audio data that meet the specified criteria.\r\n * @param audioData The raw encoded audio data.\r\n * @param overallVolume The mono volume progression for the entire track.\r\n * @param analysisArgs The parameters to use for the analysis.\r\n * @returns A promise for the relevant peak collection.\r\n */\r\nfunction getPeaks(audioData: ArrayBuffer, overallVolume: Float32Array, analysisArgs: PeakAnalysisArgs): Promise<Peak[]> {\r\n  // For processing, downmix to mono\r\n  // XXX: Look at getting webkitOfflineAudioContext supported as well\r\n  const audioContext = new window.OfflineAudioContext(1, overallVolume.length, ANALYZER_SAMPLE_RATE);\r\n  \r\n  return audioContext.decodeAudioData(audioData)\r\n    .then((decodedData: AudioBuffer) => {\r\n      const bufferSource = audioContext.createBufferSource();\r\n      let lastNode: AudioNode = bufferSource;\r\n\r\n      bufferSource.buffer = decodedData;\r\n\r\n      // Add a minimum frequency filter if we need it\r\n      if (analysisArgs.minFrequency != null) {\r\n        const minFrequencyFilter = new BiquadFilterNode(audioContext, { type: 'highpass', Q: 1, frequency: analysisArgs.minFrequency });\r\n\r\n        lastNode.connect(minFrequencyFilter);\r\n        lastNode = minFrequencyFilter;\r\n      }\r\n\r\n      // Do the same for the maximum frequency\r\n      if (analysisArgs.maxFrequency != null) {\r\n        const maxFrequencyFilter = new BiquadFilterNode(audioContext, { type: 'lowpass', Q: 1, frequency: analysisArgs.maxFrequency });\r\n\r\n        lastNode.connect(maxFrequencyFilter);\r\n        lastNode = maxFrequencyFilter;\r\n      }\r\n\r\n      // Now wire up the destination\r\n      lastNode.connect(audioContext.destination);\r\n      bufferSource.start(0);\r\n      return audioContext.startRendering();\r\n    })\r\n    .then((renderedBuffer: AudioBuffer) => {    \r\n      // if (process.env.NODE_ENV !== 'production') {\r\n      //   console.debug(`buffer for ${analysisArgs.minFrequency} to ${analysisArgs.maxFrequency}`, renderedBuffer);\r\n      // }\r\n      const frames = renderedBuffer.getChannelData(0);\r\n      const peaksList: Peak[] = [];\r\n      const peaksHistogram: { [roundedIntensity: string]: number } = {};\r\n\r\n      for(let frameIdx = 0; frameIdx < frames.length;)\r\n      {\r\n        // Make sure we have audio data on this frame\r\n        if (overallVolume[frameIdx] === 0) {\r\n          frameIdx++;\r\n          continue;\r\n        }\r\n\r\n        let absoluteIntensity = Math.abs(frames[frameIdx]);\r\n        let relativeIntensity = absoluteIntensity / overallVolume[frameIdx];\r\n\r\n        // See if we're ready to start a new peak\r\n        if (absoluteIntensity >= analysisArgs.initialAbsoluteThreshold && relativeIntensity >= analysisArgs.initialRelativeThreshold)\r\n        {\r\n          // Start a new peak, and mark when it was encountered\r\n          const newPeak: Peak = {\r\n            time: frameIdx / ANALYZER_SAMPLE_RATE,\r\n            intensity: 0,\r\n            intensityNormalized: 0,\r\n            end: 0 // To be calculated\r\n          };\r\n\r\n          // Determine the maximum intensity and number of frames it was above the threshold\r\n          do {\r\n            // See if this peak reached a new intensity\r\n            newPeak.intensity = Math.max(newPeak.intensity, absoluteIntensity)\r\n            newPeak.intensityNormalized = Math.max(newPeak.intensityNormalized, relativeIntensity)\r\n\r\n            // Look at the next frame.\r\n            // If we have audio data, recalculate the current intensity (both absolute and normalized)\r\n            // and see whether we can keep going based on the *sustain* thresholds\r\n            frameIdx++;\r\n\r\n            if (frameIdx >= frames.length || overallVolume[frameIdx] === 0) {\r\n              break;\r\n            }\r\n\r\n            absoluteIntensity = Math.abs(frames[frameIdx]);\r\n            relativeIntensity = absoluteIntensity / overallVolume[frameIdx];\r\n          } while(absoluteIntensity >= analysisArgs.sustainAbsoluteThreshold && relativeIntensity >= analysisArgs.sustainRelativeThreshold)\r\n\r\n          // Now calculate the end of the peak\r\n          newPeak.end = frameIdx / ANALYZER_SAMPLE_RATE;\r\n\r\n          // Store the peak\r\n          peaksList.push(newPeak);\r\n\r\n          // Update the histogram\r\n          const roundedIntensity = newPeak.intensityNormalized.toFixed(2);\r\n\r\n          if (roundedIntensity in peaksHistogram) {\r\n            peaksHistogram[roundedIntensity]++;\r\n          }\r\n          else {\r\n            peaksHistogram[roundedIntensity] = 1;\r\n          }\r\n\r\n          // Move forward 1/16 of a second\r\n          frameIdx += Math.ceil(ANALYZER_SAMPLE_RATE / 16);\r\n        }\r\n\r\n        frameIdx++;\r\n      }\r\n  \r\n      if (process.env.NODE_ENV !== 'production') {\r\n        console.debug(`peak histogram for ${analysisArgs.minFrequency} to ${analysisArgs.maxFrequency}`, peaksHistogram);\r\n      }\r\n\r\n      // See if we have too many peaks - if so, trim\r\n      const expectedMaximumPeaks = Math.ceil(analysisArgs.expectedMaxPeaksPerMinute * renderedBuffer.duration / 60);\r\n\r\n      if (peaksList.length > expectedMaximumPeaks) {\r\n        // Look at the histogram to figure out the cutoff.\r\n        // Convert each truncated bucket back to its actual intensity float, and sort intensity in decreasing order\r\n        const sortedBuckets = Object.keys(peaksHistogram)\r\n          .map((k) => {\r\n            return { \r\n              intensity: parseFloat(k), \r\n              count: peaksHistogram[k]\r\n            };\r\n          })\r\n          .sort((a, b) => b.intensity - a.intensity);\r\n\r\n        // Start at the maximum intensity, and keep decreasing until we get more peaks\r\n        let intensityIndex = 0;\r\n        let intensityCutoff = sortedBuckets[0].intensity;\r\n        let totalPeaks = sortedBuckets[0].count;\r\n\r\n        while(totalPeaks < expectedMaximumPeaks && intensityIndex < sortedBuckets.length - 1)\r\n        {\r\n          intensityIndex++;\r\n          intensityCutoff = sortedBuckets[intensityIndex].intensity;\r\n          totalPeaks += sortedBuckets[intensityIndex].count;\r\n        }\r\n\r\n        // Once we determine the cutoff, filter out elements that don't match\r\n        if (process.env.NODE_ENV !== 'production') {\r\n          console.debug(`cutting off peaks for ${analysisArgs.minFrequency} to ${analysisArgs.maxFrequency} at ${intensityCutoff}`);\r\n        }\r\n\r\n        return peaksList.filter((p) => p.intensityNormalized >= intensityCutoff);\r\n      }\r\n\r\n      return peaksList;\r\n    });\r\n}\r\n\r\n/**\r\n * Attempts to detect the BPM from the provided collection of peaks.\r\n * @param beats The collection of beats that are used to determine the peaks.\r\n * @param trackLength The length of the track, in seconds.\r\n * @returns The resulting BPM, if successfully detected; otherwise, null.\r\n */\r\nfunction getBpmFromPeaks(beats: Peak[], trackLength: number) : number | null {\r\n  const MINIMUM_INTERVAL = 0.25;\r\n\r\n  if (!beats) {\r\n    return null;\r\n  }\r\n\r\n  // If we don't have many beats (assume we want probably 45 per minute) also exit out\r\n  const minimumBeats = 45 * (trackLength / 60);\r\n\r\n  if (beats.length < minimumBeats) {\r\n    return null;\r\n  }\r\n\r\n  // Generate a histogram of the average distance between beats\r\n  const intervalHistogram: { [roundedInterval: string]: number } = {};\r\n\r\n  beats.forEach((beat, index) => {\r\n    for(let relativeIndex = 1; relativeIndex < 10; relativeIndex++) {\r\n      // Make sure we don't skip too far out\r\n      if (index + relativeIndex >= beats.length) {\r\n        break;\r\n      }\r\n\r\n      // Instead of counting all beats equally, count ones with more intensity\r\n      const interval = beats[index + relativeIndex].time - beat.time;\r\n      const roundedInterval = interval.toFixed(2);\r\n      // const averageIntensity = (beats[index + relativeIndex].intensityNormalized + beat.intensityNormalized) / 2;\r\n\r\n      // Skip over beats that happen too soon\r\n      if (interval < MINIMUM_INTERVAL) {\r\n        continue;\r\n      }\r\n\r\n      if (roundedInterval in intervalHistogram) {\r\n        // intervalHistogram[roundedInterval] += averageIntensity;\r\n        intervalHistogram[roundedInterval]++;\r\n      }\r\n      else {\r\n        // intervalHistogram[roundedInterval] = averageIntensity;\r\n        intervalHistogram[roundedInterval] = 1;\r\n      }\r\n    }\r\n  });\r\n\r\n  // Map that to an equivalent tempo histogram\r\n  const tempoHistogram: { [roundedTempo: string]: number } = {};\r\n\r\n  Object.keys(intervalHistogram).forEach((roundedInterval) => {\r\n    const intervalFloat = parseFloat(roundedInterval);\r\n    let tempoForInterval = 60 / (intervalFloat / ANALYZER_SAMPLE_RATE);\r\n\r\n    // Adjust to fit within the typical range of 90-180 BPM\r\n    while (tempoForInterval < 90) {\r\n      tempoForInterval *= 2;\r\n    }\r\n\r\n    while (tempoForInterval > 180) {\r\n      tempoForInterval /= 2;\r\n    }\r\n\r\n    // Round the tempo and add all of its intervals\r\n    const roundedTempoForInterval = tempoForInterval.toFixed(0);\r\n\r\n    if (roundedTempoForInterval in tempoHistogram) {\r\n      tempoHistogram[roundedTempoForInterval] += intervalHistogram[roundedInterval];\r\n    }\r\n    else {\r\n      tempoHistogram[roundedTempoForInterval] = intervalHistogram[roundedInterval];\r\n    }\r\n  });\r\n\r\n  // Now get the assumed maximum\r\n  const sortedTempos = Object.keys(tempoHistogram)\r\n    .map((k) => {\r\n      return { \r\n        bpm: parseFloat(k), \r\n        intervals: tempoHistogram[k]\r\n      };\r\n    })\r\n    .sort((a, b) => b.bpm - a.bpm);\r\n\r\n  let modeTempo = 0.0;\r\n  let modeIntervals = 0;\r\n  let totalWeightedTempo = 0.0;\r\n  let totalIntervals = 0.0;\r\n\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    console.debug(`histogram for BPM detection`, sortedTempos);\r\n  }\r\n\r\n  sortedTempos.forEach((tempo) => {\r\n    if (tempo.intervals > modeIntervals) {\r\n      modeTempo = tempo.bpm;\r\n      modeIntervals = tempo.intervals;\r\n    }\r\n\r\n    totalWeightedTempo += (tempo.bpm * tempo.intervals);\r\n    totalIntervals += tempo.intervals;\r\n  });\r\n\r\n  const averageTempo = (totalWeightedTempo / totalIntervals);\r\n\r\n  // Calculate median\r\n  let medianTempo = 0;\r\n\r\n  if (totalIntervals > 2 && sortedTempos.length > 1) {\r\n    // Keep advancing through the sorted tempos list until we've hit halfway in the intervals.\r\n    // Essentially if we have:\r\n    // [{bpm: 120, intervals: 2}, {bpm: 125, intervals: 2}, {bpm: 130, intervals: 2}]\r\n    // then we expect our median BPM to be 125.\r\n    // We'd also expect the same result for:\r\n    // [{bpm: 120, intervals: 2}, {bpm: 130, intervals: 2}]\r\n    let medianIntervals = Math.floor(totalIntervals / 2);\r\n    let medianTempoIdx = 0;\r\n\r\n    while (medianIntervals > 0 && medianTempoIdx < sortedTempos.length) {\r\n      medianIntervals -= sortedTempos[medianTempoIdx].intervals;\r\n      medianTempoIdx++;\r\n    }\r\n\r\n    // If we hit *exactly* zero, average with the next tempo bucket - otherwise, use the current tempo\r\n    if (medianIntervals === 0) {\r\n      medianTempo = (sortedTempos[medianTempoIdx - 1].bpm + sortedTempos[medianTempoIdx].bpm) / 2;\r\n    }\r\n    else {\r\n      medianTempo = sortedTempos[medianTempoIdx - 1].bpm;\r\n    }\r\n  }\r\n\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    console.debug(`calculated BPM mode: ${modeTempo}\\tmean: ${averageTempo}\\tmedian: ${medianTempo}`);\r\n  }\r\n\r\n  return averageTempo;\r\n}\r\n\r\n/**\r\n * Attempts to insert the specified lull into the sorted array\r\n * while preserving sort order and maximum array size constraints.\r\n * @param targetArray The array of lulls, sorted from longest to shortest.\r\n * @param maxArrayLength The maximum array length to maintain.\r\n * @param newItem The new item to attempt to insert.\r\n * @returns True if the item was successfully inserted; otherwise, false.\r\n */\r\nfunction tryInsertSortedLull(targetArray: Lull[], maxArrayLength: number, newItem: Lull): boolean {\r\n  // This array should be sorted from longest to shortest.\r\n  for(let targetIndex = 0; targetIndex < targetArray.length; targetIndex++) {\r\n    const currentItem = targetArray[targetIndex];\r\n\r\n    // This new item should precede the current item, so insert it at the current item's position\r\n    if (currentItem.duration < newItem.duration) {\r\n      targetArray.splice(targetIndex, 0, newItem);\r\n\r\n      // Trim off the last element of the array if we're over-length\r\n      if (targetArray.length > maxArrayLength) {\r\n        targetArray.pop();\r\n      }\r\n\r\n      // Indicate we successfully inserted!\r\n      return true;\r\n    }\r\n  }\r\n\r\n  // We didn't find anything smaller than our source item, but we can still append if we don't have enough items\r\n  if (targetArray.length < maxArrayLength) {\r\n    targetArray.push(newItem);\r\n    return true;\r\n  }\r\n  else {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Finds the location of the nearest activity across a collection of activity arrays.\r\n * @param activityArrays The collection of activity arrays to search.\r\n * @param nextActivityIndices The collection of next indices to check in the respective activity arrays.\r\n * @returns Information about where the nearest activity may be located, or an object with -1 indices when there are no activities remaining.\r\n */\r\nfunction findNearestActivity(activityArrays: (Peak | Lull)[][], nextActivityIndices: number[]): { arrayIndex: number, elementIndex: number } {\r\n  let minimumTime = Number.MAX_SAFE_INTEGER;\r\n  let minimumArrayIndex = -1;\r\n  let minimumElementIndex = -1;\r\n\r\n  for(let arrayIndex = 0; arrayIndex < activityArrays.length; arrayIndex++) {\r\n    const activityArrayToScan = activityArrays[arrayIndex];\r\n    const nextActivityIndex = nextActivityIndices[arrayIndex];\r\n\r\n    // If this array doesn't have any more elements, skip over it\r\n    if (nextActivityIndex >= activityArrayToScan.length) {\r\n      continue;\r\n    }\r\n\r\n    // See if this comes before our current minimum - if so, update \r\n    const activityAtIndex = activityArrayToScan[nextActivityIndex];\r\n\r\n    if (activityAtIndex.time < minimumTime) {\r\n      minimumTime = activityAtIndex.time;\r\n      minimumArrayIndex = arrayIndex;\r\n      minimumElementIndex = nextActivityIndex;\r\n    }\r\n  }\r\n  \r\n  return {\r\n    arrayIndex: minimumArrayIndex,\r\n    elementIndex: minimumElementIndex\r\n  }\r\n}\r\n\r\n/**\r\n * Finds lulls in the track between the specified collection of activities.\r\n * @param trackLength The length of the track, in fractional seconds.\r\n * @param maximumLulls The maximum number of lulls that can be found.\r\n * @param minimumLullDuration The shortest allowable lull, in fractional seconds.\r\n * @param activityArrays The activities to skip over when determining lulls. Each should be sorted in time-ascending order.\r\n * @returns The resulting collection of lulls.\r\n */\r\nfunction findLulls(trackLength: number, maximumLulls: number, minimumLullDuration: number, activityArrays: (Peak | Lull)[][]): Lull[] {\r\n  if (maximumLulls <= 0 || activityArrays.length <= 0) {\r\n    return [];\r\n  }\r\n\r\n  // Filter out empty arrays\r\n  // We want to keep processing even if *this* filtered length is 0, because that way we'll get a lull\r\n  // ranging from 0 to the end of the song.\r\n  activityArrays = activityArrays.filter((activityArrays) => activityArrays.length > 0);\r\n\r\n  // Now build an array of the next element to look for in each array\r\n  const nextActivityIndices: number[] = activityArrays.map(() => 0);\r\n\r\n  // We want to track the longest lulls available\r\n  let sortedLongestLulls: Lull[] = [];\r\n  let lullDurationCutoff = minimumLullDuration;\r\n  let startOfCurrentPeriod = 0.0;\r\n\r\n  while(true) {\r\n    // Get the nearest activity\r\n    const nearestActivityLocation = findNearestActivity(activityArrays, nextActivityIndices);\r\n\r\n    // See if we ran out of arrays to scan\r\n    if (nearestActivityLocation.arrayIndex === -1) {\r\n      // Create an ending lull that goes to the end of the track\r\n      const endingLull: Lull = {\r\n        time: startOfCurrentPeriod,\r\n        end: trackLength,\r\n        duration: trackLength - startOfCurrentPeriod\r\n      };\r\n\r\n      // See if that's sufficient\r\n      if (endingLull.duration > lullDurationCutoff) {\r\n        tryInsertSortedLull(sortedLongestLulls, maximumLulls, endingLull);\r\n      }\r\n\r\n      // Exit out since we have nothing left to scan\r\n      break;\r\n    }\r\n\r\n    // Ensure we increment the next activity index for the source array\r\n    nextActivityIndices[nearestActivityLocation.arrayIndex]++;\r\n\r\n    // Now pull what we just found.\r\n    // If it's in the past, skip over it and keep searching.\r\n    // This handles when multiple elements have identical starts, with one exception -\r\n    // we want items starting at the very beginning of the song to be respected\r\n    const nearestActivity = activityArrays[nearestActivityLocation.arrayIndex][nearestActivityLocation.elementIndex];\r\n\r\n    if (nearestActivity.time > 0 && nearestActivity.time <= startOfCurrentPeriod) {\r\n      continue;\r\n    }\r\n\r\n    // Create a new lull ranging from our starting point up to start of the activity\r\n    const newLull: Lull = {\r\n      time: startOfCurrentPeriod,\r\n      end: nearestActivity.time,\r\n      duration: nearestActivity.time - startOfCurrentPeriod\r\n    };\r\n\r\n    // See if there is room for this lull in the collection.\r\n    // Use the lullDurationCutoff as an optimization before actually comparing against array elements\r\n    if (newLull.duration > lullDurationCutoff && tryInsertSortedLull(sortedLongestLulls, maximumLulls, newLull)) {\r\n      \r\n      // We successfully inserted.\r\n      // If we're at the maximum array length, ensure the minimum duration is up-to-date.\r\n      if (sortedLongestLulls.length >= maximumLulls) {\r\n        lullDurationCutoff = sortedLongestLulls[sortedLongestLulls.length - 1].duration;\r\n      }\r\n    }\r\n\r\n    // Now move the start of the next period to the end of the activity\r\n    // Also artifically increase the time so that we don't have too many too quickly\r\n    startOfCurrentPeriod = nearestActivity.end + minimumLullDuration;\r\n\r\n    // If we're past the song length, exit out\r\n    if (startOfCurrentPeriod > trackLength) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  // Sort the lulls by time\r\n  return sortedLongestLulls.sort((a, b) => {\r\n    return a.time - b.time;\r\n  });\r\n}\r\n\r\n/**\r\n * Subdivides long lulls in the provided collection until the maximum number of lulls\r\n * has been encountered or the lull durations are relatively homogenous.\r\n * @param lulls The collection of lulls to update. This array will be modified in-place.\r\n * @param maximumLulls The maximum number of lulls that can be found.\r\n */\r\nfunction subdivideLongLulls(lulls: Lull[], maximumLulls: number): void {\r\n  if (lulls.length === 0 || lulls.length >= maximumLulls) {\r\n    return;\r\n  }\r\n\r\n  // First sort by duration descending\r\n  lulls.sort((a, b) => {\r\n    return b.duration - a.duration;\r\n  });\r\n\r\n  // We will keep subdividing until:\r\n  // 1) We have enough lulls\r\n  // 2) The shortest lull is more than half of the longest one, ensuring the collection is roughly homogenous\r\n  const MINIMUM_DISCREPANCY = 2;\r\n\r\n  while(lulls.length < maximumLulls && (lulls[0].duration / MINIMUM_DISCREPANCY) > lulls[lulls.length - 1].duration) {\r\n    // Subdivide the longest lull\r\n    const lullToSplit = lulls.shift()!;\r\n    const newDuration = lullToSplit.duration / 2;\r\n    const midpoint = lullToSplit.time + newDuration;\r\n\r\n    // if (process.env.NODE_ENV !== 'production') {\r\n    //   console.debug(`splitting lull from ${lullToSplit.time} to ${lullToSplit.end} at ${midpoint}`);\r\n    // }\r\n\r\n    const firstLull: Lull = {\r\n      time: lullToSplit.time,\r\n      end: midpoint,\r\n      duration: newDuration\r\n    };\r\n\r\n    const secondLull: Lull = {\r\n      time: midpoint,\r\n      end: lullToSplit.end,\r\n      duration: newDuration\r\n    };\r\n\r\n    // Try to insert both\r\n    tryInsertSortedLull(lulls, maximumLulls, firstLull);\r\n    tryInsertSortedLull(lulls, maximumLulls, secondLull);\r\n  }\r\n\r\n  // Re-sort the lulls by time ascending\r\n  lulls.sort((a, b) => {\r\n    return a.time - b.time;\r\n  });\r\n}\r\n\r\nexport async function analyzeTrack(file: File): Promise<TrackAnalysis> {\r\n  let tags: TagType;\r\n\r\n  try {\r\n    tags = await getTrackTags(file);\r\n  }\r\n  catch (error) {\r\n    return Promise.reject(error);\r\n  }\r\n\r\n  const overallVolume = await file.arrayBuffer().then((byteBuffer) => getTrackVolume(byteBuffer));\r\n\r\n  const subBass = file.arrayBuffer().then((byteBuffer) => getPeaks(byteBuffer, overallVolume, {\r\n    minFrequency: 20,\r\n    maxFrequency: 50,\r\n    expectedMaxPeaksPerMinute: 60,\r\n    initialAbsoluteThreshold: 0.4,\r\n    initialRelativeThreshold: 0.5,\r\n    sustainAbsoluteThreshold: 0.4,\r\n    sustainRelativeThreshold: 0.5\r\n  }));\r\n\r\n  const bass = file.arrayBuffer().then((byteBuffer) => getPeaks(byteBuffer, overallVolume, {\r\n    minFrequency: 50,\r\n    maxFrequency: 90,\r\n    expectedMaxPeaksPerMinute: 120,\r\n    initialAbsoluteThreshold: 0.4,\r\n    initialRelativeThreshold: 0.5,\r\n    sustainAbsoluteThreshold: 0.4,\r\n    sustainRelativeThreshold: 0.5\r\n  }));\r\n\r\n  const beat = file.arrayBuffer().then((byteBuffer) => getPeaks(byteBuffer, overallVolume, {\r\n    minFrequency: 90,\r\n    maxFrequency: 200,\r\n    expectedMaxPeaksPerMinute: 300,\r\n    initialAbsoluteThreshold: 0.4,\r\n    initialRelativeThreshold: 0.5,\r\n    sustainAbsoluteThreshold: 0.4,\r\n    sustainRelativeThreshold: 0.5\r\n  }));\r\n\r\n  const treble = file.arrayBuffer().then((byteBuffer) => getPeaks(byteBuffer, overallVolume, {\r\n    minFrequency: 2048,\r\n    maxFrequency: null,\r\n    expectedMaxPeaksPerMinute: 120,\r\n    initialAbsoluteThreshold: 0.4,\r\n    initialRelativeThreshold: 0.5,\r\n    sustainAbsoluteThreshold: 0.25,\r\n    sustainRelativeThreshold: 0.35\r\n  }));\r\n\r\n  return Promise.all([tags, subBass, bass, beat, treble])\r\n    .then((values): TrackAnalysis => {\r\n      const [tagResult, subBassResult, bassResult, beatResult, trebleResult] = values;\r\n      const trackLength = overallVolume.length / ANALYZER_SAMPLE_RATE;\r\n      const keyFromTags = getKeyTagValue(tagResult);\r\n\r\n      let detectedBpm = getBpmTagValue(tagResult);\r\n\r\n      // Attempt to detect the BPM from the peaks if either:\r\n      // 1) We couldn't find it in tags\r\n      // 2) We're in development (so we can compare results easily)\r\n      if (!detectedBpm) {\r\n        detectedBpm = getBpmFromPeaks(beatResult, trackLength);\r\n      }\r\n      else if (process.env.NODE_ENV !== 'production') {\r\n        let bpmFromPeaks = getBpmFromPeaks(beatResult, trackLength);\r\n        console.debug(`tag BPM: ${detectedBpm}\\tcalculated BPM: ${bpmFromPeaks}`);\r\n      }\r\n\r\n      const analysis = new TrackAnalysis()\r\n      analysis.title = tagResult.tags.title ?? 'Unknown Title';\r\n      analysis.artist = tagResult.tags.artist ?? 'Unknown Artist';\r\n      analysis.bpm = detectedBpm ?? 120;\r\n      analysis.length = trackLength;\r\n      analysis.key = keyFromTags;\r\n      analysis.subBass = subBassResult;\r\n      analysis.bass = bassResult;\r\n      analysis.beat = beatResult;\r\n      analysis.treble = trebleResult;\r\n      analysis.trackHash = Math.floor(file.lastModified + file.size) + 1;\r\n\r\n      // Calculate lulls last since that depends on other analysis components\r\n      const maxLullsForTrack = Math.floor((trackLength / 60) * 12);\r\n      const minLullDuration = analysis.secondsPerMeasure;\r\n\r\n      analysis.lulls = findLulls(trackLength, maxLullsForTrack, minLullDuration, [beatResult, trebleResult]);\r\n\r\n      // Try to add more if we're still under\r\n      if (analysis.lulls.length < maxLullsForTrack) {\r\n        // Look for more lulls, skipping over already-existing lulls and the sub-bass peaks\r\n        analysis.lulls.push(...findLulls(trackLength, maxLullsForTrack - analysis.lulls.length, minLullDuration, [analysis.lulls, subBassResult]));\r\n\r\n        // Re-sort based on time\r\n        analysis.lulls.sort((a, b) => {\r\n          return a.time - b.time;\r\n        });\r\n\r\n        // Try to subdivide long lulls\r\n        subdivideLongLulls(analysis.lulls, maxLullsForTrack);\r\n      }\r\n\r\n      return analysis;\r\n    });\r\n}\r\n","import * as THREE from 'three';\r\nimport { OpenKey, TrackAnalysis } from './TrackAnalysis';\r\n\r\n/**\r\n * A theme to use for the visualizer.\r\n */\r\nexport interface Theme {\r\n  name: string;\r\n\r\n  /**\r\n   * Contains theming information relevant to the BassTunnel component.\r\n   */\r\n  bass: {\r\n    /**\r\n     * The color to use for wireframes that form the \"tunnel\".\r\n     */\r\n    wireframeColor: THREE.Color;\r\n\r\n    /**\r\n     * The color to use for panels that fill different parts of the tunnel.\r\n     */\r\n    panelColor: THREE.Color;\r\n  },\r\n\r\n  /**\r\n   * Contains theming information relevant to the BeatQueue component.\r\n   */\r\n  beat: {\r\n    /**\r\n     * The color to use for incoming beat peaks.\r\n     */\r\n    color: THREE.Color;\r\n  },\r\n\r\n  /**\r\n   * Contains theming information relevant to the TrebleQueue component.\r\n   */\r\n  treble: {\r\n    /**\r\n     * The sprite color to use for incoming treble peaks.\r\n     */\r\n    spriteColor: THREE.Color;\r\n\r\n    /**\r\n     * The path to the sprite texture to use for incoming treble peaks.\r\n     */\r\n    spriteTexture: string;\r\n\r\n    /**\r\n     * The light color to use for incoming treble peaks.\r\n     */\r\n    lightColor: THREE.Color;\r\n  },\r\n\r\n  /**\r\n   * Contains theming information relevant to the FrequencyGrid component.\r\n   */\r\n  frequencyGrid: {\r\n    /**\r\n     * The color to use for drawing frequency lines.\r\n     */\r\n    lineColor: THREE.Color;\r\n  },\r\n\r\n  /**\r\n   * Contains theming information relevant to the overall visualizer and BackgroundManager component.\r\n   */\r\n  background: {\r\n    /**\r\n     * The color to use for filling the background scene.\r\n     */\r\n    fillColor: THREE.Color;\r\n\r\n    /**\r\n     * The color to use for the sun.\r\n     */\r\n    sunColor: THREE.Color;\r\n\r\n    /**\r\n     * The color to use for the \"burst\" lines that rotate around the sun.\r\n     */\r\n    burstLineColor: THREE.Color;\r\n\r\n    /**\r\n     * The standard color to use for stars in the background.\r\n     */\r\n    starColor: THREE.Color;\r\n\r\n    /**\r\n     * The color to use for \"flashed\" stars in the background.\r\n     */\r\n    starFlashColor: THREE.Color;\r\n  },\r\n\r\n  /**\r\n   * Contains theming information for the overall application UI.\r\n   */\r\n  ui: {\r\n    textColor: THREE.Color;\r\n\r\n    backgroundColor: THREE.Color;\r\n\r\n    disabledBackgroundColor: THREE.Color;\r\n\r\n    focusBackgroundColor: THREE.Color;\r\n\r\n    borderColor: THREE.Color;\r\n  }\r\n}\r\n\r\nconst BLACK_COLOR = new THREE.Color(0x000000);\r\nconst WHITE_COLOR = new THREE.Color(0xFFFFFF);\r\n\r\n/**\r\n * Gets the sRGB value to use in luma calculations for the specified color component.\r\n * @param floatColor The color component, on a 0.0-1.0 scale.\r\n * @returns The corresponding luma component.\r\n * @see {@link https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef}\r\n */\r\nfunction getLumaComponent(floatColor: number): number {\r\n  const cutoff = 0.03928;\r\n\r\n  if (floatColor <= cutoff) {\r\n    return floatColor / 12.92;\r\n  }\r\n  else {\r\n    return Math.pow(((floatColor + 0.055) / 1.055), 2.4);\r\n  }\r\n}\r\n\r\n/**\r\n * Gets the luma value for the specified color.\r\n * @param color The color.\r\n * @returns The corresponding luma value.\r\n * @see {@link https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef}\r\n */\r\nfunction getLuma(color: THREE.Color): number {\r\n  return (0.2126 * getLumaComponent(color.r)) + (0.7152 * getLumaComponent(color.g)) + (0.0722 * getLumaComponent(color.b));\r\n}\r\n\r\n/**\r\n * The threshold against which the color is considered dark enough to support legible white text.\r\n * @see {@link https://lesscss.org/functions/#color-operations-contrast}\r\n */\r\nconst LIGHT_LUMA_THRESHOLD = 0.43;\r\n\r\n/**\r\n * Gets a black or white color to contrast against the provided color.\r\n * @param color The color to check against.\r\n * @returns The equivalent contrasting color.\r\n */\r\nexport function getContrast(color: THREE.Color): THREE.Color {\r\n  if (getLuma(color) < LIGHT_LUMA_THRESHOLD) {\r\n    return WHITE_COLOR;\r\n  }\r\n  else {\r\n    return BLACK_COLOR;\r\n  }\r\n}\r\n\r\nfunction generateThemeForColor(name: string, baseColor: THREE.Color, secondaryColor: THREE.Color, tertiaryColor: THREE.Color | null = null): Theme {\r\n  // Default the tertiary color if not specified\r\n  if (tertiaryColor === null) {\r\n    tertiaryColor = new THREE.Color(baseColor).lerp(secondaryColor, 0.5);\r\n  }\r\n\r\n  // Determine the UI text color to use\r\n  let uiTextColor: THREE.Color;\r\n  let uiDisabledBgColor: THREE.Color;\r\n  let uiFocusBgColor: THREE.Color;\r\n\r\n  if (getLuma(baseColor) < LIGHT_LUMA_THRESHOLD) {\r\n    uiTextColor = WHITE_COLOR;\r\n    uiDisabledBgColor = new THREE.Color(baseColor).lerp(BLACK_COLOR, 0.3);\r\n    uiFocusBgColor = new THREE.Color(baseColor).lerp(WHITE_COLOR, 0.2);\r\n  }\r\n  else {\r\n    uiTextColor = BLACK_COLOR;\r\n    uiDisabledBgColor = new THREE.Color(baseColor).lerp(WHITE_COLOR, 0.3);\r\n    uiFocusBgColor = new THREE.Color(baseColor).lerp(BLACK_COLOR, 0.2);\r\n  }\r\n\r\n  return {\r\n    name: name,\r\n    bass: {\r\n      wireframeColor: new THREE.Color(tertiaryColor).lerp(BLACK_COLOR, 0.3),\r\n      panelColor: new THREE.Color(tertiaryColor)\r\n    },\r\n    beat: {\r\n      color: new THREE.Color(baseColor)\r\n    },\r\n    treble: {\r\n      spriteColor: new THREE.Color(baseColor).lerp(WHITE_COLOR, 0.65),\r\n      spriteTexture: process.env.PUBLIC_URL + '/textures/extendring.png',\r\n      lightColor: new THREE.Color(baseColor).lerp(WHITE_COLOR, 0.75),\r\n    },\r\n    frequencyGrid: {\r\n      lineColor: new THREE.Color(secondaryColor)\r\n    },\r\n    background: {\r\n      fillColor: new THREE.Color(baseColor).lerp(BLACK_COLOR, 0.97),\r\n      sunColor: new THREE.Color(baseColor).lerp(secondaryColor, 0.75).lerp(WHITE_COLOR, 0.5),\r\n      burstLineColor: new THREE.Color(baseColor).lerp(secondaryColor, 0.75).lerp(WHITE_COLOR, 0.25),\r\n      starColor: new THREE.Color(baseColor).lerp(secondaryColor, 0.75).lerp(WHITE_COLOR, 0.1),\r\n      starFlashColor: new THREE.Color(baseColor).lerp(secondaryColor, 0.75)\r\n    },\r\n    ui: {\r\n      textColor: uiTextColor,\r\n      backgroundColor: new THREE.Color(baseColor),\r\n      disabledBackgroundColor: uiDisabledBgColor,\r\n      focusBackgroundColor: uiFocusBgColor,\r\n      borderColor: new THREE.Color(secondaryColor)\r\n    }\r\n  };\r\n}\r\n\r\nexport const defaultTheme = generateThemeForColor('default', new THREE.Color(0xff6600), new THREE.Color(0xff3333), new THREE.Color(0xff9933));\r\n\r\nconst magentaTheme = generateThemeForColor('magenta', new THREE.Color(0xff33ff), new THREE.Color(0x993399), new THREE.Color(0x0033ff));\r\nconst indigoTheme = generateThemeForColor('indigo', new THREE.Color(0xcc00ff), new THREE.Color(0x6666ff), new THREE.Color(0x6633ff));\r\nconst darkBlueTheme = generateThemeForColor('deep blue', new THREE.Color(0x0033ff), new THREE.Color(0xcc9900), new THREE.Color(0x00cccc));\r\nconst midBlueTheme = generateThemeForColor('mid blue', new THREE.Color(0x6699ff), new THREE.Color(0x66cc66), new THREE.Color(0x3366ff));\r\nconst lightBlueTheme = generateThemeForColor('light blue', new THREE.Color(0x99ccff), new THREE.Color(0xff66ff), new THREE.Color(0x33ff33));\r\nconst blueGreenTheme = generateThemeForColor('blue-green', new THREE.Color(0x00ffff), new THREE.Color(0xcc6600), new THREE.Color(0x339999));\r\nconst greenTheme = generateThemeForColor('green', new THREE.Color(0x00ff00), new THREE.Color(0xFF0099), new THREE.Color(0x00ff99));\r\nconst yellowGreenTheme = generateThemeForColor('yellow-green', new THREE.Color(0x99ffcc), new THREE.Color(0xffcc33), new THREE.Color(0x33cc00));\r\nconst yellowTheme = generateThemeForColor('yellow', new THREE.Color(0xffcc00), new THREE.Color(0x3333FF), new THREE.Color(0xcccc33));\r\nconst orangeTheme = generateThemeForColor('orange', new THREE.Color(0xff6600), new THREE.Color(0x33FFFF), new THREE.Color(0xff0000));\r\nconst redTheme = generateThemeForColor('red', new THREE.Color(0xff0000), new THREE.Color(0x99FFcc), new THREE.Color(0xff6699));\r\nconst pinkTheme = generateThemeForColor('pink', new THREE.Color(0xff99cc), new THREE.Color(0xff3333), new THREE.Color(0xcc33cc));\r\n\r\nconst hotdogStandTheme = generateThemeForColor('hotdog stand', new THREE.Color(0xff0000), new THREE.Color(0xffff00));\r\nconst fluorescentTheme = generateThemeForColor('fluorescent', new THREE.Color(0xff00ff), new THREE.Color(0x00ff00));\r\nconst plasmaPowerSaverTheme = generateThemeForColor('plasma power saver', new THREE.Color(0x0000ff), new THREE.Color(0xff00ff), new THREE.Color(0xcc0066));\r\n\r\n/**\r\n * An array of all themes that can be assigned randomly by getThemeForTrack.\r\n */\r\nexport const ALL_THEMES = [\r\n  defaultTheme,\r\n  magentaTheme,\r\n  indigoTheme,\r\n  darkBlueTheme,\r\n  midBlueTheme,\r\n  lightBlueTheme,\r\n  blueGreenTheme,\r\n  greenTheme,\r\n  yellowGreenTheme,\r\n  yellowTheme,\r\n  orangeTheme,\r\n  redTheme,\r\n  pinkTheme,\r\n  hotdogStandTheme,\r\n  fluorescentTheme,\r\n  plasmaPowerSaverTheme\r\n];\r\n\r\nexport function getThemeForTrack(track: TrackAnalysis): Theme {\r\n  if (track === null) {\r\n    return defaultTheme;\r\n  }\r\n\r\n  // Randomly assign a key if we didn't detect one \r\n  if (track.key === null) {\r\n    const keyIndex = track.getTrackRandomInt(0, ALL_THEMES.length - 1);\r\n    return ALL_THEMES[keyIndex];\r\n  }\r\n\r\n  // Map keys to specific themes\r\n  switch(track.key) {\r\n    case OpenKey.C_Major:\r\n    case OpenKey.A_Minor:\r\n      return magentaTheme;\r\n\r\n    case OpenKey.G_Major:\r\n    case OpenKey.E_Minor:\r\n      return indigoTheme;\r\n\r\n    case OpenKey.D_Major:\r\n    case OpenKey.B_Minor:\r\n      return darkBlueTheme;\r\n\r\n    case OpenKey.A_Major:\r\n    case OpenKey.F_Sharp_Minor:\r\n      return midBlueTheme;\r\n\r\n    case OpenKey.E_Major:\r\n    case OpenKey.C_Sharp_Minor:\r\n      return lightBlueTheme;\r\n\r\n    case OpenKey.B_Major:\r\n    case OpenKey.G_Sharp_Minor:\r\n      return blueGreenTheme;\r\n\r\n    case OpenKey.F_Sharp_Major:\r\n    case OpenKey.D_Sharp_Minor:\r\n      return greenTheme;\r\n\r\n    case OpenKey.D_Flat_Major:\r\n    case OpenKey.B_Flat_Minor:\r\n      return yellowGreenTheme;\r\n\r\n    case OpenKey.A_Flat_Major:\r\n    case OpenKey.F_Minor:\r\n      return yellowTheme;\r\n\r\n    case OpenKey.E_Flat_Major:\r\n    case OpenKey.C_Minor:\r\n      return orangeTheme;\r\n\r\n    case OpenKey.B_Flat_Major:\r\n    case OpenKey.G_Minor:\r\n      return redTheme;\r\n\r\n    case OpenKey.F_Major:\r\n    case OpenKey.D_Minor:\r\n      return pinkTheme;\r\n\r\n    case OpenKey.OffKey:\r\n      return hotdogStandTheme;\r\n\r\n    default:\r\n      return defaultTheme;\r\n  }\r\n}\r\n\r\nexport function getNextTheme(currentTheme: Theme): Theme {\r\n  const currentThemeIndex = ALL_THEMES.indexOf(currentTheme);\r\n\r\n  // Return the first theme if we didn't find a match or we need to wrap around\r\n  if (currentThemeIndex === -1 || currentThemeIndex === ALL_THEMES.length - 1) {\r\n    return ALL_THEMES[0];\r\n  }\r\n\r\n  return ALL_THEMES[currentThemeIndex + 1];\r\n}\r\n","import create, { GetState, SetState } from 'zustand';\r\nimport { StoreApiWithSubscribeWithSelector, subscribeWithSelector } from 'zustand/middleware'\r\n\r\nimport { EmptyTrackAnalysis, TrackAnalysis } from './TrackAnalysis';\r\nimport { defaultTheme, Theme } from './themes';\r\n\r\ninterface VisualizerState {\r\n  /**\r\n   * The analysis for the current track being played.\r\n   */\r\n  analysis: TrackAnalysis;\r\n\r\n  /**\r\n   * The theme to use.\r\n   */\r\n  theme: Theme;\r\n\r\n  /**\r\n   * A time stamp to indicate that the current track's audio has been seeked.\r\n   */\r\n  audioLastSeeked: number;\r\n\r\n  setAnalysis: (newAnalysis: TrackAnalysis) => void;\r\n\r\n  setTheme: (newTheme: Theme) => void;\r\n\r\n  indicateAudioSeeked: () => void;\r\n}\r\n\r\nexport const useStore = create<\r\n  VisualizerState,\r\n  SetState<VisualizerState>,\r\n  GetState<VisualizerState>,\r\n  StoreApiWithSubscribeWithSelector<VisualizerState>\r\n>(subscribeWithSelector((set) => ({\r\n  analysis: EmptyTrackAnalysis,\r\n  theme: defaultTheme,\r\n  audioLastSeeked: 0,\r\n\r\n  setAnalysis: (newAnalysis) => set(state => { state.analysis = newAnalysis }),\r\n  setTheme: (newTheme) => set(state => { state.theme = newTheme }),\r\n  indicateAudioSeeked: () => set(state => { state.audioLastSeeked = Date.now() })\r\n})));","import { useEffect } from 'react';\r\nimport { css } from \"styled-components\";\r\n\r\nimport { useStore } from '../store/visualizerStore';\r\n\r\n/**\r\n * A path for a round-rect background to use for dynamic icon generation.\r\n * Extracted from a 64x64 version of the logo SVG.\r\n */\r\nconst bevelPath = new Path2D('M64,12.8C64,5.735 58.265,0 51.2,0L12.8,0C5.735,0 0,5.735 0,12.8L0,51.2C0,58.265 5.735,64 12.8,64L51.2,64C58.265,64 64,58.265 64,51.2L64,12.8Z');\r\n\r\n/**\r\n * A path for a waveform to use for dynamic icon generation.\r\n * Extracted from a 64x64 version of the logo SVG.\r\n */\r\nconst waveformPath = new Path2D('M-0.063,32C-0.063,32 0.1,14.756 0.706,14.762C1.308,14.768 1.352,48.687 2.623,48.679C3.713,48.672 4.033,19.674 6.498,19.72C8.476,19.757 9.898,44.125 11.665,44.137C13.269,44.148 15.225,27.314 18.123,27.262C19.97,27.228 22.316,34.293 24.748,34.262C26.547,34.239 29.486,30.126 31.915,30.179C33.821,30.22 36.836,32.346 39.185,32.262C41.258,32.188 44.23,31.313 45.976,31.262C47.511,31.217 51.354,32.125 53.396,32.058C55.048,32.004 58.987,31.707 60.222,31.672C61.416,31.638 62.61,31.788 63.804,31.845');\r\n\r\n/**\r\n * A path for a star shape to use for dynamic icon generation.\r\n * Extracted from a 64x64 version of the logo SVG.\r\n */\r\nconst firstStarPath = new Path2D('M25.418,10.25L27.74,9.882L27.993,11.48L29.435,10.745L30.502,12.84L29.06,13.575L30.204,14.719L28.542,16.381L27.398,15.237L26.663,16.679L24.568,15.612L25.303,14.17L23.705,13.917L24.073,11.595L25.671,11.848L25.418,10.25Z');\r\n\r\n/**\r\n * A path for a star shape to use for dynamic icon generation.\r\n * Extracted from a 64x64 version of the logo SVG.\r\n */\r\nconst secondStarPath = new Path2D('M44.075,49.242L45.903,47.762L46.921,49.02L47.802,47.663L49.774,48.943L48.893,50.3L50.456,50.719L49.847,52.99L48.284,52.571L48.369,54.187L46.021,54.31L45.936,52.694L44.426,53.274L43.583,51.079L45.094,50.499L44.075,49.242Z');\r\n\r\nfunction AppStyles(): JSX.Element {\r\n  const uiTheme = useStore((state) => state.theme.ui);\r\n\r\n  useEffect(() => useStore.subscribe(\r\n    (state) => state.theme.ui,\r\n    (newUiTheme) => {\r\n      // Update the theme-color meta tag to match our main color\r\n      document.querySelector('meta[name=\"theme-color\"]')?.setAttribute('content', newUiTheme.backgroundColor.getStyle());\r\n\r\n      // Create a dummy canvas\r\n      const canvasElem = document.createElement('canvas') as HTMLCanvasElement;\r\n      canvasElem.setAttribute('width', '64px');\r\n      canvasElem.setAttribute('height', '64px');\r\n\r\n      // Try to get a 2D rendering context\r\n      const ctx = canvasElem.getContext('2d', { alpha: true, desynchronized: true });\r\n\r\n      if (ctx) {\r\n        // If found, fill our bevel style and stroke in the waveform and stars.\r\n        ctx.fillStyle = newUiTheme.backgroundColor.getStyle();\r\n        ctx.fill(bevelPath);\r\n\r\n        ctx.strokeStyle = newUiTheme.textColor.getStyle();\r\n        ctx.lineWidth = 2;\r\n        ctx.stroke(waveformPath);\r\n\r\n        ctx.lineWidth = 1;\r\n        ctx.stroke(firstStarPath);\r\n        ctx.stroke(secondStarPath);\r\n\r\n        // Convert to a data URL and use it to generate the favicon\r\n        const iconUrl = canvasElem.toDataURL('image/png');\r\n        document.querySelector('link[rel=\"icon\"]')?.setAttribute('href', iconUrl);\r\n      }\r\n\r\n      canvasElem.remove();\r\n    }),\r\n    []);\r\n\r\n  // Because we want to make this a reactive component, we can't manually use something like createGlobalStyle,\r\n  // which handles component generation.\r\n  return (\r\n    <style\r\n      type=\"text/css\">\r\n      {css`\r\n        html {\r\n          --ui-color-text: ${uiTheme.textColor.getStyle()};\r\n          --ui-color-contrast: ${uiTheme.backgroundColor.getStyle()};\r\n          --ui-color-contrast-disabled: ${uiTheme.disabledBackgroundColor.getStyle()};\r\n          --ui-color-contrast-focus: ${uiTheme.focusBackgroundColor.getStyle()};\r\n          --ui-color-border: ${uiTheme.borderColor.getStyle()};\r\n      }`}\r\n    </style>\r\n  );\r\n}\r\n\r\nexport default AppStyles;\r\n","/**\r\n * Generates a numeric array consisting of the numbers spanning the range [0, total) in sequential order.\r\n * @param total The total number of elements to return.\r\n * @returns The corresponding array.\r\n */\r\nexport function generateNumericArray(total: number): number[] {\r\n  return Array.from(Array(total).keys());\r\n}\r\n","import { RefObject, useEffect, useMemo, useRef } from 'react';\r\nimport * as THREE from 'three';\r\nimport { useFrame } from '@react-three/fiber';\r\n\r\nimport { generateNumericArray } from '../utils';\r\nimport { TrackAnalysis } from '../store/TrackAnalysis';\r\nimport { useStore } from '../store/visualizerStore';\r\n\r\nconst QUARTER_TURN = Math.PI / 2;\r\n\r\nconst SEGMENT_DEPTH = 5;\r\nconst SEGMENT_WIDTH = 2;\r\nconst SEGMENT_HEIGHT = 15;\r\n\r\nconst SEGMENTS_PER_SIDE = 20;\r\nconst START_DEPTH = SEGMENT_DEPTH;\r\n\r\n// When we normally try to display a standard box geometry using wireframes,\r\n// it will display each side using two triangles. We want pure lines,\r\n// so we'll use a set of lines (with appropriate scaling) to approximate quads.\r\nconst boxLineGeometry = new THREE.BufferGeometry();\r\n\r\nboxLineGeometry.setFromPoints([\r\n  // Right line, front face\r\n  new THREE.Vector3(0.5, -0.5, 0.5),\r\n  new THREE.Vector3(0.5, 0.5, 0.5),\r\n\r\n  // Top line, front face\r\n  new THREE.Vector3(0.5, 0.5, 0.5),\r\n  new THREE.Vector3(-0.5, 0.5, 0.5),\r\n\r\n  // Left line, front face\r\n  new THREE.Vector3(-0.5, 0.5, 0.5),\r\n  new THREE.Vector3(-0.5, -0.5, 0.5),\r\n\r\n  // Bottom line, front face\r\n  new THREE.Vector3(-0.5, -0.5, 0.5),\r\n  new THREE.Vector3(0.5, -0.5, 0.5),\r\n\r\n  // Top-left faces connector\r\n  new THREE.Vector3(-0.5, 0.5, 0.5),\r\n  new THREE.Vector3(-0.5, 0.5, -0.5),\r\n\r\n  // Bottom-left faces connector\r\n  new THREE.Vector3(-0.5, -0.5, 0.5),\r\n  new THREE.Vector3(-0.5, -0.5, -0.5),\r\n\r\n  // Top-right faces connector\r\n  new THREE.Vector3(0.5, 0.5, 0.5),\r\n  new THREE.Vector3(0.5, 0.5, -0.5),\r\n\r\n  // Bottom-right faces connector\r\n  new THREE.Vector3(0.5, -0.5, 0.5),\r\n  new THREE.Vector3(0.5, -0.5, -0.5),\r\n\r\n  // Right line, back face\r\n  new THREE.Vector3(0.5, -0.5, -0.5),\r\n  new THREE.Vector3(0.5, 0.5, -0.5),\r\n\r\n  // Top line, back face\r\n  new THREE.Vector3(0.5, 0.5, -0.5),\r\n  new THREE.Vector3(-0.5, 0.5, -0.5),\r\n\r\n  // Left line, back face\r\n  new THREE.Vector3(-0.5, 0.5, -0.5),\r\n  new THREE.Vector3(-0.5, -0.5, -0.5),\r\n\r\n  // Bottom line, back face\r\n  new THREE.Vector3(-0.5, -0.5, -0.5),\r\n  new THREE.Vector3(0.5, -0.5, -0.5),\r\n]);\r\n\r\n/**\r\n * The material to use for all wireframe lines.\r\n */\r\nconst boxLineMaterial = new THREE.LineBasicMaterial();\r\n\r\n/**\r\n  * The geometry to use for all filler panels.\r\n  */\r\nconst panelFillGeometry = new THREE.PlaneGeometry();\r\n \r\n/**\r\n  * The material to use for all filler panels.\r\n  */\r\nconst panelFillMaterial = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, transparent: true, opacity: 0.6 });\r\n\r\nconst enum SegmentDisplay {\r\n  SegmentHidden = 0,\r\n  MIN = SegmentHidden,\r\n  PlaneLeft = 1,\r\n  PlaneRight = 2,\r\n  PlaneFront = 3,\r\n  PlaneTop = 4,\r\n  PlaneBottom = 5,\r\n  PlaneHidden = 6,\r\n  MAX = PlaneHidden\r\n}\r\n\r\n/**\r\n * Randomizes the presentation of the provided tunnel segment based on the current track and time.\r\n * @param segmentIndex The index of the segment.\r\n * @param segment The group containing the wireframe box and the filler plane.\r\n * @param planeForSegment The mesh for the filler plane.\r\n * @param trackAnalysis The track information.\r\n * @param currentTrackTime The current track time.\r\n */\r\nfunction randomizeTunnelSegment(segmentIndex: number, segment: THREE.Group, planeForSegment: THREE.Mesh, trackAnalysis: TrackAnalysis, currentTrackTime: number): void {\r\n  // In most cases both the segment and filler plane will be visible, so default those.\r\n  segment.visible = true;\r\n  planeForSegment.visible = true;\r\n\r\n  // Randomly determine how this segment might appear based on the current time.\r\n  // If we're changing two segments in the same frame, we might run into overlap, \r\n  // and so it's a good idea to also incorporate the segment index so there are still variances\r\n  let segmentDisplayMode: SegmentDisplay;\r\n  \r\n  if (!trackAnalysis.isEmpty) {\r\n    segmentDisplayMode = trackAnalysis.getTrackSeededRandomInt(SegmentDisplay.MIN, SegmentDisplay.MAX, currentTrackTime + segmentIndex);\r\n  }\r\n  else {\r\n    segmentDisplayMode = SegmentDisplay.PlaneHidden;\r\n  }\r\n\r\n  switch(segmentDisplayMode) {\r\n    case SegmentDisplay.SegmentHidden:\r\n      segment.visible = false;\r\n      planeForSegment.visible = false;\r\n      break;\r\n\r\n    case SegmentDisplay.PlaneLeft:\r\n      planeForSegment.scale.set(SEGMENT_DEPTH, SEGMENT_HEIGHT, 1);\r\n      planeForSegment.position.set(-SEGMENT_WIDTH / 2, 0, 0);\r\n      planeForSegment.rotation.set(0, QUARTER_TURN, 0);\r\n      break;\r\n\r\n    case SegmentDisplay.PlaneRight:\r\n      planeForSegment.scale.set(SEGMENT_DEPTH, SEGMENT_HEIGHT, 1);\r\n      planeForSegment.position.set(SEGMENT_WIDTH / 2, 0, 0);\r\n      planeForSegment.rotation.set(0, QUARTER_TURN, 0);\r\n      break;\r\n\r\n    case SegmentDisplay.PlaneFront:\r\n      planeForSegment.scale.set(SEGMENT_WIDTH, SEGMENT_HEIGHT, 1);\r\n      planeForSegment.position.set(0, 0, SEGMENT_DEPTH / 2);\r\n      planeForSegment.rotation.set(0, 0, 0);\r\n      break;\r\n\r\n    case SegmentDisplay.PlaneTop:\r\n      planeForSegment.scale.set(SEGMENT_WIDTH, SEGMENT_DEPTH, 1);\r\n      planeForSegment.position.set(0, SEGMENT_HEIGHT / 2, 0);\r\n      planeForSegment.rotation.set(QUARTER_TURN, 0, 0);\r\n      break;\r\n\r\n    case SegmentDisplay.PlaneBottom:\r\n      planeForSegment.scale.set(SEGMENT_WIDTH, SEGMENT_DEPTH, 1);\r\n      planeForSegment.position.set(0, -SEGMENT_HEIGHT / 2, 0);\r\n      planeForSegment.rotation.set(QUARTER_TURN, 0, 0);\r\n      break;\r\n\r\n    case SegmentDisplay.PlaneHidden:\r\n      planeForSegment.visible = false;\r\n      break;\r\n\r\n    default:\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        console.trace(`unexpected display mode: ${segmentDisplayMode} for segment ${segmentIndex}`);\r\n      }\r\n      planeForSegment.visible = false;\r\n      break;\r\n  }\r\n}\r\n\r\nfunction getDepthForSegment(segmentIndex: number): number {\r\n  return START_DEPTH - (SEGMENT_DEPTH * (segmentIndex % SEGMENTS_PER_SIDE))\r\n}\r\n\r\nfunction BassTunnel(props: { audio: RefObject<HTMLAudioElement> }): JSX.Element {\r\n  const HORIZ_OFFSET = 12;\r\n  let nextBassIndex = 0;\r\n  let nextSubBassIndex = 0;\r\n  \r\n  const trackAnalysis = useStore(state => state.analysis);\r\n\r\n  // Because the wireframe/filler materials are cached across multiple renders, just ensure the colors reflects the state.\r\n  boxLineMaterial.color = useStore().theme.bass.wireframeColor;\r\n  panelFillMaterial.color = useStore().theme.bass.panelColor;\r\n  \r\n  useEffect(() => useStore.subscribe(\r\n    state => state.theme.bass.wireframeColor,\r\n    (newLineColor) => {\r\n      boxLineMaterial.color = newLineColor;\r\n    }),\r\n    []);\r\n  \r\n  useEffect(() => useStore.subscribe(\r\n    state => state.theme.bass.panelColor,\r\n    (newFillColor) => {\r\n      panelFillMaterial.color = newFillColor;\r\n    }),\r\n    []);\r\n\r\n  // Store references to each tunnel segment group and its constituent elements (box/plane)\r\n  const tunnelSegments = useRef<THREE.Group[]>([]);\r\n  const tunnelSegmentBoxes = useRef<THREE.LineSegments[]>([]);\r\n  const tunnelSegmentPlanes = useRef<THREE.Mesh[]>([]);\r\n\r\n  const tunnelSegmentElements = useMemo(() => {\r\n    return generateNumericArray(SEGMENTS_PER_SIDE * 2)\r\n      .map((segmentIndex) => {\r\n        return <group\r\n          ref={(grp: THREE.Group) => tunnelSegments.current[segmentIndex] = grp}\r\n          key={segmentIndex}\r\n        >\r\n          <lineSegments\r\n            ref={(seg: THREE.LineSegments) => tunnelSegmentBoxes.current[segmentIndex] = seg}\r\n            scale={[SEGMENT_WIDTH, SEGMENT_HEIGHT, SEGMENT_DEPTH]}\r\n            geometry={boxLineGeometry}\r\n            material={boxLineMaterial}\r\n          />\r\n          <mesh\r\n            ref={(plane: THREE.Mesh) => tunnelSegmentPlanes.current[segmentIndex] = plane}\r\n            geometry={panelFillGeometry}\r\n            material={panelFillMaterial}\r\n          />\r\n        </group>\r\n      });\r\n    }, []);\r\n\r\n  // Determine the amount of time it should take for a segment to scroll the length of the tunnel\r\n  const tunnelTraversalPeriodSeconds = useMemo(() => {\r\n      return trackAnalysis.secondsPerMeasure * 0.5 * SEGMENTS_PER_SIDE;\r\n    },\r\n    [trackAnalysis]);\r\n\r\n  // Reset the initial arrangement when the track analysis changes\r\n  useEffect(() => {\r\n    for(let segmentIndex = 0; segmentIndex < tunnelSegments.current.length; segmentIndex++) {\r\n      const groupForSegment = tunnelSegments.current[segmentIndex];\r\n      const planeForSegment = tunnelSegmentPlanes.current[segmentIndex];\r\n\r\n      // Position the overall group for the segment.\r\n      // The first half of the segments will be on the left side, the remainder will be on the right\r\n      // Each half will be positioned one behind the other\r\n      const segmentDepth = getDepthForSegment(segmentIndex);\r\n\r\n      if (segmentIndex < SEGMENTS_PER_SIDE) {\r\n        groupForSegment.position.set(-HORIZ_OFFSET, 0, segmentDepth);\r\n      }\r\n      else {\r\n        groupForSegment.position.set(HORIZ_OFFSET, 0, segmentDepth);\r\n      }\r\n\r\n      // Randomize the presentation for initial display\r\n      randomizeTunnelSegment(segmentIndex, groupForSegment, planeForSegment, trackAnalysis, 0); \r\n    }\r\n  }, [trackAnalysis, tunnelSegments, tunnelSegmentPlanes]);\r\n\r\n  // Ensure we reset the next bass endpoint when the track gets seeked -\r\n  // useFrame will recalculate as needed \r\n  useEffect(() => useStore.subscribe(\r\n    state => [state.analysis, state.audioLastSeeked],\r\n    () => {\r\n      // eslint-disable-next-line react-hooks/exhaustive-deps\r\n      nextBassIndex = 0;\r\n\r\n      // eslint-disable-next-line react-hooks/exhaustive-deps\r\n      nextSubBassIndex = 0;\r\n    }),\r\n    []);\r\n\r\n  useFrame(() => {\r\n    // Determine the depth offset to apply to all segments\r\n    const TOTAL_DEPTH = SEGMENT_DEPTH * SEGMENTS_PER_SIDE;\r\n    const WRAP_DEPTH = getDepthForSegment(0) + (2 * SEGMENT_DEPTH);\r\n    let timeDepthOffset = 0;\r\n    let currentTrackTime = 0;\r\n    let bassScalingFactor = 0;\r\n    let subBassScalingFactor = 0;\r\n\r\n    if (props.audio.current !== null) {\r\n      currentTrackTime = props.audio.current.currentTime;\r\n      timeDepthOffset = TOTAL_DEPTH * (currentTrackTime % tunnelTraversalPeriodSeconds) / tunnelTraversalPeriodSeconds;\r\n    }\r\n\r\n    // See if we're currently during a bass period\r\n    for(let bassIndex = nextBassIndex; bassIndex < trackAnalysis.bass.length; bassIndex++) {\r\n      const curBass = trackAnalysis.bass[bassIndex];\r\n      // Ease in and out of the bass peak\r\n      const startTime = curBass.time - 0.25;\r\n      const endTime = curBass.end + 0.5;\r\n      let effectiveIntensity = curBass.intensity;\r\n\r\n      // If this is too early, stop looping\r\n      if (startTime > currentTrackTime) {\r\n        break;\r\n      }\r\n\r\n      // If we've already passed this bass peak, make sure we'll skip over it in subsequent frames\r\n      if (endTime < currentTrackTime) {\r\n        nextBassIndex++;\r\n        continue;\r\n      }\r\n\r\n      // We are somewhere during this peak period - because of that, update the intensity\r\n      // However, apply it less strongly if we're outside the actual peak\r\n      if (currentTrackTime < curBass.time) {\r\n        effectiveIntensity = THREE.MathUtils.mapLinear(currentTrackTime, startTime, curBass.time, 0, effectiveIntensity);\r\n      }\r\n      else if (currentTrackTime > curBass.end) {\r\n        effectiveIntensity = THREE.MathUtils.mapLinear(currentTrackTime, curBass.end, endTime, effectiveIntensity, 0);\r\n      }\r\n\r\n      // Use Math.max so that if we have multiple concurrent peaks, the strongest peak is what gets used\r\n      bassScalingFactor = Math.max(effectiveIntensity, bassScalingFactor);\r\n    }\r\n\r\n    // See if we're currently during a bass period\r\n    for(let subBassIndex = nextSubBassIndex; subBassIndex < trackAnalysis.subBass.length; subBassIndex++) {\r\n      const curSubBass = trackAnalysis.subBass[subBassIndex];\r\n      // Ease in and out of the sub-bass peak\r\n      const startTime = curSubBass.time - 0.5;\r\n      const endTime = curSubBass.end + 1.5;\r\n      let effectiveIntensity = curSubBass.intensity;\r\n\r\n      // If this is too early, stop looping\r\n      if (startTime > currentTrackTime) {\r\n        break;\r\n      }\r\n\r\n      // If we've already passed this peak, make sure we'll skip over it in subsequent frames\r\n      if (endTime < currentTrackTime) {\r\n        nextSubBassIndex++;\r\n        continue;\r\n      }\r\n\r\n      // We are somewhere during this peak period - because of that, update the intensity\r\n      // However, apply it less strongly if we're outside the actual peak\r\n      if (currentTrackTime < curSubBass.time) {\r\n        effectiveIntensity = THREE.MathUtils.mapLinear(currentTrackTime, startTime, curSubBass.time, 0, effectiveIntensity);\r\n      }\r\n      else if (currentTrackTime > curSubBass.end) {\r\n        effectiveIntensity = THREE.MathUtils.mapLinear(currentTrackTime, curSubBass.end, endTime, effectiveIntensity, 0);\r\n      }\r\n\r\n      // Use Math.max so that if we have multiple concurrent peaks, the strongest peak is what gets used\r\n      subBassScalingFactor = Math.max(effectiveIntensity, subBassScalingFactor);\r\n    }\r\n\r\n    for(let segmentIndex = 0; segmentIndex < tunnelSegments.current.length; segmentIndex++) {\r\n      const segment = tunnelSegments.current[segmentIndex];\r\n      let segmentDepth = getDepthForSegment(segmentIndex) + timeDepthOffset;\r\n\r\n      // Hide all segments when we don't have a track analysis\r\n      segment.visible = !trackAnalysis.isEmpty;\r\n\r\n      // Wrap the group if it's past the camera\r\n      if (segmentDepth > WRAP_DEPTH) {\r\n        segmentDepth -= TOTAL_DEPTH;\r\n\r\n        // If this is the first time we've had to re-position the wrapped element, randomize the segment's appearance\r\n        if (segmentDepth < segment.position.z) {\r\n          const planeForSegment = tunnelSegmentPlanes.current[segmentIndex];\r\n          randomizeTunnelSegment(segmentIndex, segment, planeForSegment, trackAnalysis, currentTrackTime);\r\n        }\r\n      }\r\n\r\n      segment.position.z = segmentDepth;\r\n\r\n      // Scale each segment based on the bass (y)/sub-bass (x) intensity\r\n      segment.scale.set(1 + (subBassScalingFactor), 1 + (bassScalingFactor * 0.75), 1);\r\n    }\r\n  })\r\n\r\n  return (\r\n    <group>\r\n      {tunnelSegmentElements}\r\n    </group>\r\n  );\r\n}\r\n\r\nexport default BassTunnel;\r\n","import { RefObject, useEffect, useRef } from 'react';\r\nimport * as THREE from 'three';\r\nimport { useFrame } from '@react-three/fiber';\r\n\r\nimport { useStore } from '../store/visualizerStore';\r\nimport { generateNumericArray } from '../utils';\r\nimport Peak from '../store/Peak';\r\n\r\nfunction getBasePosition(sideIdx: number, totalSides: number, scale: number): THREE.Vector3 {\r\n  // Modulo the side index so that we'll always get a value that maps within [0, 360) degree range\r\n  let angle = ((sideIdx % totalSides) / totalSides) * 2 * Math.PI;\r\n\r\n  // For alternating sets, further perturb the angle\r\n  if (Math.ceil(sideIdx / totalSides) % 2 === 0) {\r\n    angle += Math.PI / totalSides;\r\n  } \r\n\r\n  return new THREE.Vector3(Math.cos(angle), Math.sin(angle), 0).multiplyScalar(scale);\r\n}\r\n\r\n/**\r\n * The geometry to use for all beat meshes.\r\n */\r\nconst beatGeometry = new THREE.SphereGeometry();\r\n\r\n/**\r\n * The material to use for all beat meshes.\r\n */\r\nconst beatMeshMaterial = new THREE.MeshPhongMaterial({ shininess: 0.5 });\r\n\r\nfunction BeatQueue(props: { audio: RefObject<HTMLAudioElement> }): JSX.Element {\r\n  let nextUnrenderedPeakIndex = 0;\r\n  let nextAvailableMeshIndex = 0;\r\n  const availableMeshesRing = useRef<THREE.Mesh[]>([]);\r\n  const SIDES = 6;\r\n  const RADIUS = 5;\r\n  const LOOKAHEAD_PERIOD = 1.5;\r\n  const DECAY_PERIOD = 0.25;\r\n  const PEAK_DEPTH_START = -200;\r\n  const PEAK_DEPTH_END = -10;\r\n\r\n  const trackAnalysis = useStore(state => state.analysis);\r\n\r\n  // Because the beat material is cached across multiple renders, just ensure the color reflects the state.\r\n  beatMeshMaterial.color = useStore().theme.beat.color;\r\n\r\n  useEffect(() => useStore.subscribe(\r\n    state => state.theme.beat.color,\r\n    (newBeatColor) => {\r\n      beatMeshMaterial.color = newBeatColor;\r\n    }),\r\n    []);\r\n\r\n  // Generate available meshes for use in a ring buffer\r\n  const availableMeshElements = \r\n    generateNumericArray(SIDES * 6).map((sideNumber) => {\r\n      return <mesh\r\n        key={sideNumber}\r\n        ref={(mesh: THREE.Mesh) => availableMeshesRing.current[sideNumber] = mesh}\r\n        visible={false}\r\n        position={getBasePosition(sideNumber, SIDES, RADIUS)}\r\n        geometry={beatGeometry}\r\n        material={beatMeshMaterial}\r\n      />\r\n    });\r\n\r\n  // Ensure we reset the next peak index when analysis changes (or we seeked).\r\n  // We're okay with just blowing away these values and letting useFrame re-calculate when it needs to\r\n  useEffect(() => useStore.subscribe(\r\n    state => [state.analysis, state.audioLastSeeked],\r\n    () => {\r\n      // eslint-disable-next-line react-hooks/exhaustive-deps\r\n      nextUnrenderedPeakIndex = 0;\r\n      \r\n      // eslint-disable-next-line react-hooks/exhaustive-deps\r\n      nextAvailableMeshIndex = 0;\r\n    }),\r\n    []);\r\n\r\n  useFrame((_state, delta) => {\r\n    if (props.audio.current === null) {\r\n      return;\r\n    }\r\n\r\n    const audioTime = props.audio.current.currentTime;\r\n    const lastRenderTime = Math.max(audioTime - delta, 0);\r\n\r\n    // Determine if we need to fill the ring buffer with any new meshes\r\n    for (let peakIdx = nextUnrenderedPeakIndex; peakIdx < trackAnalysis.beat.length; peakIdx++) {\r\n      const curPeak = trackAnalysis.beat[peakIdx];\r\n      const peakDisplayStart = curPeak.time - LOOKAHEAD_PERIOD;\r\n      const peakDisplayEnd = curPeak.end + DECAY_PERIOD;\r\n\r\n      // See if we're already too late for this peak - if so, skip ahead\r\n      if (lastRenderTime > peakDisplayEnd) {\r\n        nextUnrenderedPeakIndex++;\r\n        continue;\r\n      }\r\n\r\n      // Now see if we're too early for this peak - if so, exit out\r\n      if (peakDisplayStart > audioTime) {\r\n        break;\r\n      }\r\n\r\n      // Now we have a new peak to render. Assign it to the next available mesh\r\n      const meshForPeak = availableMeshesRing.current[nextAvailableMeshIndex];\r\n      meshForPeak.userData['peak'] = curPeak;\r\n      \r\n      // Switch around to the next mesh in the ring buffer\r\n      nextAvailableMeshIndex = (nextAvailableMeshIndex + 1) % availableMeshesRing.current.length;\r\n\r\n      // Ensure we're rendering the next peak\r\n      nextUnrenderedPeakIndex++;\r\n    }\r\n\r\n    // Now update the items in the ring buffer\r\n    for (let meshForPeak of availableMeshesRing.current)\r\n    {\r\n      const peakData = meshForPeak.userData['peak'] as Peak;\r\n\r\n      if (peakData === null || peakData === undefined) {\r\n        meshForPeak.visible = false;\r\n        continue;\r\n      }\r\n\r\n      const peakDisplayStart = peakData.time - LOOKAHEAD_PERIOD;\r\n      const peakDisplayEnd = peakData.end + DECAY_PERIOD;\r\n\r\n      // See if we've finished peaking, which means we should hide the mesh\r\n      if (peakDisplayStart > audioTime || peakDisplayEnd < lastRenderTime) {\r\n        meshForPeak.visible = false;\r\n        delete meshForPeak.userData['peak'];\r\n        continue;\r\n      }\r\n\r\n      // Make the mesh visible and lerp it to zoom in\r\n      meshForPeak.visible = true;\r\n      meshForPeak.position.z = THREE.MathUtils.mapLinear(audioTime, peakDisplayStart, peakDisplayEnd, PEAK_DEPTH_START, PEAK_DEPTH_END);\r\n\r\n      // Tweak scaling if we're during the actual beat\r\n      if (audioTime >= peakData.time && audioTime < peakDisplayEnd) {\r\n        meshForPeak.scale.setScalar(THREE.MathUtils.mapLinear(audioTime, peakData.time, peakDisplayEnd, 1.0, 2.0));\r\n      }\r\n      else {\r\n        meshForPeak.scale.setScalar(1);\r\n      }\r\n    }\r\n  });\r\n\r\n  return (\r\n    <group>\r\n      {availableMeshElements}\r\n    </group>\r\n  );\r\n}\r\n\r\nexport default BeatQueue;\r\n","import { RefObject, useEffect, useMemo, useRef } from 'react';\r\nimport * as THREE from 'three';\r\nimport { useFrame } from '@react-three/fiber';\r\n\r\nimport { generateNumericArray } from '../utils';\r\nimport { useStore } from '../store/visualizerStore';\r\n\r\n/**\r\n * The material to use for all frequency lines.\r\n */\r\nconst frequencyLineMaterial = new THREE.LineBasicMaterial();\r\n\r\nfunction FrequencyGrid(props: { audio: RefObject<HTMLAudioElement>, analyser: RefObject<AnalyserNode> }): JSX.Element {\r\n  // Track how many rows we have, where the first row starts, depth-wise, and the spacing between each row  \r\n  const FREQUENCY_ROWS: number = 10;\r\n  const STARTING_DEPTH: number = -10;\r\n  const DEPTH_SPACING: number = -20;\r\n\r\n  // XXX: LINE_BUCKETS should be equal to analyzer.frequencyBinCount\r\n  const LINE_BUCKETS = 64;\r\n  const BUCKET_WIDTH = 0.5;\r\n  const BUCKET_HEIGHT = 5.0;\r\n\r\n  // On either end, we want a set number of points to ease down the minimum/maximum frequencies to 0\r\n  // and avoid sharp cliffs\r\n  const ANCHOR_POINTS = 8;\r\n\r\n  // Pull our store items\r\n  const trackAnalysis = useStore(state => state.analysis);\r\n\r\n  // Because the line material is cached across multiple renders, just ensure the color reflects the state.\r\n  frequencyLineMaterial.color = useStore().theme.frequencyGrid.lineColor;\r\n\r\n  useEffect(() => useStore.subscribe(\r\n    state => state.theme.frequencyGrid.lineColor,\r\n    (newLineColor) => {\r\n      frequencyLineMaterial.color = newLineColor;\r\n    }),\r\n    []);\r\n\r\n  // Construct the set of points to use for each line\r\n  const pointSet = useMemo(() => {\r\n    const points: THREE.Vector3[] = [];\r\n\r\n    // Start by adding anchor points on the left-hand side and use a different scale just for the anchors\r\n    // Ideally we want something like\r\n    // |--25% anchors--|----50% points----|--25% anchors--|\r\n    const anchorIncrement = (LINE_BUCKETS * BUCKET_WIDTH) / (4 * ANCHOR_POINTS);\r\n    let currentX = -(anchorIncrement * ANCHOR_POINTS) - (LINE_BUCKETS * BUCKET_WIDTH / 2);\r\n\r\n    for (let i = 0; i < ANCHOR_POINTS; i++) {\r\n      points.push(new THREE.Vector3(currentX, 0, 0));\r\n      currentX += anchorIncrement;\r\n    }\r\n\r\n    // Now start distributing the \"normal\" points around zero\r\n    for(let i = 0; i < LINE_BUCKETS; i++) {\r\n      points.push(new THREE.Vector3(currentX, 0, 0));\r\n      currentX += BUCKET_WIDTH;\r\n    }\r\n\r\n    // Add the ending anchors\r\n    for (let i = 0; i < ANCHOR_POINTS; i++) {\r\n      points.push(new THREE.Vector3(currentX, 0, 0));\r\n      currentX += anchorIncrement;\r\n    }    \r\n\r\n    return points;\r\n  }, []);\r\n\r\n  // Construct the geometry from those points\r\n  const frequencyGeometry = useMemo(() => {\r\n    const geometry = new THREE.BufferGeometry();\r\n    geometry.setFromPoints(pointSet);\r\n    return geometry;\r\n  }, [pointSet]);\r\n\r\n  // Construct multiple lines from the geometry\r\n  const rowLines = useRef<THREE.Line[]>([]);\r\n  const rowElements = useMemo(() => {\r\n    return generateNumericArray(FREQUENCY_ROWS).map((rowIndex) => {\r\n      const line = new THREE.Line(frequencyGeometry, frequencyLineMaterial);\r\n      line.position.set(0, -10, STARTING_DEPTH + (DEPTH_SPACING * rowIndex));\r\n      line.scale.set(0.6, THREE.MathUtils.mapLinear(rowIndex, 0, FREQUENCY_ROWS - 1, 1.0, 0.1), 1.0);\r\n\r\n      // Ensure the line is stored in a mesh\r\n      rowLines.current[rowIndex] = line;\r\n\r\n      // Convert the line to the equivalent JSX element\r\n      return <primitive \r\n        object={line}\r\n        key={rowIndex}\r\n      />\r\n    })\r\n    }, [frequencyGeometry, STARTING_DEPTH, DEPTH_SPACING, FREQUENCY_ROWS]);\r\n\r\n  useFrame((state, delta) => {\r\n    if (props.analyser.current === null || props.audio.current === null) {\r\n      return;\r\n    }\r\n\r\n    const frequencies = new Uint8Array(props.analyser.current.frequencyBinCount);\r\n    props.analyser.current.getByteFrequencyData(frequencies);\r\n\r\n    // Skip over the four anchor points at the beginning and the four anchor points at the end\r\n    for(let i = 0; i < frequencies.length; i++) {\r\n      // Ensure that we're skipping over the anchors when accessing points, so that\r\n      // frequencies[0] will correspond with pointSet[ANCHOR_POINTS]\r\n      pointSet[i + ANCHOR_POINTS].y = (frequencies[i] / 255.0) * BUCKET_HEIGHT;\r\n    }\r\n\r\n    // Use the anchor points to scale down the edges\r\n    let leftmostFrequency = (frequencies[0] / 255.0) * BUCKET_HEIGHT;\r\n    let rightmostFrequency = (frequencies[frequencies.length - 1] / 255.0) * BUCKET_HEIGHT;\r\n\r\n    // Move outward on the lefthand side (but don't touch the bucket at 0)\r\n    for(let i = ANCHOR_POINTS - 1; i > 0; i--) {\r\n      leftmostFrequency = leftmostFrequency / 1.618;\r\n      pointSet[i].y = leftmostFrequency;\r\n    }\r\n\r\n    // Move outward on the righthand side (but again skip over the last bucket)\r\n    for (let i = LINE_BUCKETS + ANCHOR_POINTS; i < pointSet.length - 1; i++) {\r\n      rightmostFrequency = rightmostFrequency / 1.618;\r\n      pointSet[i].y = rightmostFrequency;\r\n    }\r\n\r\n    // Calculate how much of the measure, by percentage has elapsed by now\r\n    let measurePercentage = 0;\r\n    const secondsPerMeasure = trackAnalysis.secondsPerMeasure;\r\n\r\n    if (props.audio.current.currentTime > 0) {\r\n      measurePercentage = (props.audio.current.currentTime % secondsPerMeasure) / secondsPerMeasure;\r\n    }\r\n\r\n    // Update all of the rows\r\n    for(let rowIndex = 0; rowIndex < rowLines.current.length; rowIndex++) {\r\n      // Apply the point set to all line rows\r\n      const lineRow = rowLines.current[rowIndex];\r\n      const baseDepth = STARTING_DEPTH + (DEPTH_SPACING * rowIndex);\r\n\r\n      // Hide all line rows when we don't have a track analysis\r\n      lineRow.visible = !trackAnalysis.isEmpty;\r\n\r\n      lineRow.geometry.setFromPoints(pointSet);\r\n      lineRow.geometry.computeBoundingBox();\r\n\r\n      // Move forward the Z by the row spacing * the % of the measure completed.\r\n      // This ensures that each row will approach the previous row's starting point,\r\n      // but will snap back to the starting point once the new measure starts\r\n      if (props.audio.current.currentTime > 0) {\r\n        lineRow.position.z = baseDepth - (DEPTH_SPACING * measurePercentage);\r\n      }\r\n      else {\r\n        lineRow.position.z = baseDepth;\r\n      }\r\n    }\r\n  });\r\n\r\n  return (\r\n    <group>\r\n      {rowElements}\r\n    </group>\r\n  );\r\n}\r\n\r\nexport default FrequencyGrid;\r\n","import { RefObject, useEffect, useRef } from 'react';\r\nimport * as THREE from 'three';\r\nimport { useFrame } from '@react-three/fiber';\r\nimport { useTexture } from '@react-three/drei';\r\n\r\nimport { useStore } from '../store/visualizerStore';\r\nimport { generateNumericArray } from '../utils';\r\nimport Peak from '../store/Peak';\r\n\r\nfunction TrebleQueue(props: { audio: RefObject<HTMLAudioElement> }): JSX.Element {\r\n  let nextUnrenderedPeakIndex = 0;\r\n  let nextAvailableGroupIndex = 0;\r\n  const availableTrebleGroupsRing = useRef<THREE.Group[]>([]);\r\n  const QUEUE_SIZE = 20;\r\n  const LOOKAHEAD_PERIOD = 0.1;\r\n  const DECAY_PERIOD = 0.5;\r\n  const PEAK_DEPTH_START = -200;\r\n  const PEAK_DEPTH_END = 10;\r\n  const BASE_LIGHT_INTENSITY = 20;\r\n  const BASE_LIGHT_DISTANCE = 20;\r\n  const MIN_DISTRIBUTION_RADIUS = 12;\r\n  const MAX_DISTRIBUTION_RADIUS = 20;\r\n\r\n  const trackAnalysis = useStore(state => state.analysis);\r\n  const trebleTheme = useStore(state => state.theme.treble);\r\n  const spriteTexture = useTexture(trebleTheme.spriteTexture);\r\n\r\n  // Generate available sprites for use in a ring buffer\r\n  const availableSpriteElements = \r\n    generateNumericArray(QUEUE_SIZE).map((index) => {\r\n      return <group\r\n        key={index}\r\n        visible={false}\r\n        ref={(grp: THREE.Group) => availableTrebleGroupsRing.current[index] = grp}\r\n      >\r\n        {/* XXX: Don't change the order/contents without updating the useEffect that looks at the group's children */}\r\n        <sprite\r\n          scale={[15, 15, 1]}\r\n        >\r\n          <spriteMaterial\r\n            color={trebleTheme.spriteColor}\r\n            map={spriteTexture}\r\n            depthWrite={false}\r\n            transparent={true}\r\n            blending={THREE.CustomBlending}\r\n            blendEquation={THREE.AddEquation}\r\n            blendSrc={THREE.SrcAlphaFactor}\r\n            blendDst={THREE.OneFactor}\r\n          />\r\n        </sprite>\r\n        <pointLight\r\n          color={trebleTheme.lightColor}\r\n          castShadow={false}\r\n          distance={BASE_LIGHT_DISTANCE}\r\n        />\r\n      </group>\r\n    });\r\n\r\n  // Reset the peak indices when we seek or change tracks\r\n  useEffect(() => useStore.subscribe(\r\n    state => [state.analysis, state.audioLastSeeked],\r\n    () => {\r\n      // eslint-disable-next-line react-hooks/exhaustive-deps\r\n      nextUnrenderedPeakIndex = 0;\r\n      // eslint-disable-next-line react-hooks/exhaustive-deps\r\n      nextAvailableGroupIndex = 0;\r\n    }),\r\n    []);\r\n\r\n  useFrame((_state, delta) => {\r\n    if (props.audio.current === null) {\r\n      return;\r\n    }\r\n\r\n    const audioTime = props.audio.current.currentTime;\r\n    const lastRenderTime = Math.max(audioTime - delta, 0);\r\n\r\n    // Determine if we need to fill the ring buffer with any new meshes\r\n    for (let peakIdx = nextUnrenderedPeakIndex; peakIdx < trackAnalysis.treble.length; peakIdx++) {\r\n      const curPeak = trackAnalysis.treble[peakIdx];\r\n      const peakDisplayStart = curPeak.time - LOOKAHEAD_PERIOD;\r\n      const peakDisplayEnd = curPeak.end + DECAY_PERIOD;\r\n\r\n      // See if we're already too late for this peak - if so, skip ahead\r\n      if (lastRenderTime > peakDisplayEnd) {\r\n        nextUnrenderedPeakIndex++;\r\n        continue;\r\n      }\r\n\r\n      // Now see if we're too early for this peak - if so, exit out\r\n      if (peakDisplayStart > audioTime) {\r\n        break;\r\n      }\r\n\r\n      // Now we have a new peak to render. Assign it to the next available group/sprite\r\n      const groupForPeak = availableTrebleGroupsRing.current[nextAvailableGroupIndex];\r\n      groupForPeak.userData['peak'] = curPeak;\r\n\r\n      // Randomize the position of the group\r\n      const angle = trackAnalysis.getTrackSeededRandomInt(0, 359, curPeak.time) * THREE.MathUtils.DEG2RAD;\r\n      const radius = trackAnalysis.getTrackSeededRandomInt(MIN_DISTRIBUTION_RADIUS, MAX_DISTRIBUTION_RADIUS, curPeak.time);\r\n      \r\n      groupForPeak.position.x = Math.cos(angle) * radius;\r\n      groupForPeak.position.y = Math.sin(angle) * radius;\r\n      \r\n      // Switch around to the next sprite in the ring buffer\r\n      nextAvailableGroupIndex = (nextAvailableGroupIndex + 1) % availableTrebleGroupsRing.current.length;\r\n\r\n      // Ensure we're rendering the next peak\r\n      nextUnrenderedPeakIndex++;\r\n    }\r\n\r\n    // Now update the items in the ring buffer\r\n    for (let itemIdx = 0; itemIdx < availableTrebleGroupsRing.current.length; itemIdx++)\r\n    {\r\n      const groupForPeak = availableTrebleGroupsRing.current[itemIdx];\r\n      const peakData = groupForPeak.userData['peak'] as Peak;\r\n\r\n      if (peakData === null || peakData === undefined) {\r\n        groupForPeak.visible = false;\r\n        continue;\r\n      }\r\n\r\n      const peakDisplayStart = peakData.time - LOOKAHEAD_PERIOD;\r\n      const peakDisplayEnd = peakData.end + DECAY_PERIOD;\r\n\r\n      // See if we've finished peaking, which means we should hide the entire group\r\n      if (peakDisplayStart > audioTime || peakDisplayEnd < lastRenderTime) {\r\n        groupForPeak.visible = false;\r\n        delete groupForPeak.userData['peak'];\r\n        continue;\r\n      }\r\n\r\n      // Make the group visible and lerp it to zoom in\r\n      groupForPeak.visible = true;\r\n      groupForPeak.position.z = THREE.MathUtils.mapLinear(audioTime, peakDisplayStart, peakDisplayEnd, PEAK_DEPTH_START, PEAK_DEPTH_END);\r\n\r\n      // Fade the sprite opacity if we're in the lookahead/decay period\r\n      const spriteForPeak = groupForPeak.children[0] as THREE.Sprite;\r\n      const lightForPeak = groupForPeak.children[1] as THREE.PointLight;\r\n\r\n      if (audioTime < peakData.time) {\r\n        const scale = THREE.MathUtils.mapLinear(audioTime, peakDisplayStart, peakData.time, 0, 1);\r\n\r\n        spriteForPeak.material.opacity = scale;\r\n        lightForPeak.intensity = BASE_LIGHT_INTENSITY * scale;\r\n      }\r\n      else if (audioTime > peakData.end) {\r\n        const scale = THREE.MathUtils.mapLinear(audioTime, peakData.end, peakDisplayEnd, 1, 0);\r\n\r\n        spriteForPeak.material.opacity = scale;\r\n        lightForPeak.intensity = BASE_LIGHT_INTENSITY * scale;\r\n      }\r\n      else {\r\n        spriteForPeak.material.opacity = 1;\r\n        lightForPeak.intensity = BASE_LIGHT_INTENSITY;\r\n      }\r\n    }\r\n  });\r\n\r\n  return (\r\n    <group>\r\n      {availableSpriteElements}\r\n    </group>\r\n  );\r\n}\r\n\r\nexport default TrebleQueue;\r\n","import { RefObject, useEffect, useMemo, useRef } from 'react';\r\nimport * as THREE from 'three';\r\nimport { useFrame } from '@react-three/fiber';\r\n\r\nimport { useStore } from '../store/visualizerStore';\r\nimport { generateNumericArray } from '../utils';\r\nimport { TrackAnalysis } from '../store/TrackAnalysis';\r\nimport Lull from '../store/Lull';\r\n\r\nconst BASE_RADIUS = 150;\r\nconst NO_TRANSLATION = new THREE.Vector3(0, 0, 0);\r\n\r\n/**\r\n * The collection of geometries that can be used for scenery and the translation to use for it.\r\n */\r\nconst SCENERY_GEOMETRIES: [THREE.BufferGeometry, THREE.Vector3][] = [\r\n  [\r\n    new THREE.ConeGeometry(BASE_RADIUS, BASE_RADIUS * 3, undefined, undefined, true),\r\n    new THREE.Vector3(0, BASE_RADIUS, 0)\r\n  ],\r\n  [\r\n    // The top half of a sphere - make sure we move it down so it's flush\r\n    new THREE.SphereGeometry(BASE_RADIUS, undefined, undefined, undefined, undefined, 0, Math.PI / 2),\r\n    new THREE.Vector3(0, -BASE_RADIUS/2, 0)\r\n  ],\r\n  [\r\n    new THREE.BoxGeometry(BASE_RADIUS, BASE_RADIUS * 5, BASE_RADIUS),\r\n    NO_TRANSLATION\r\n  ],\r\n  [\r\n    // The top half of a torus - move it down like the sphere and rotate it so it's parallel to the walls\r\n    new THREE.TorusGeometry(BASE_RADIUS, BASE_RADIUS / 2, undefined, undefined, Math.PI).rotateY(Math.PI / 2),\r\n    new THREE.Vector3(0, -BASE_RADIUS/1.5, 0)\r\n  ],\r\n  [\r\n    new THREE.CylinderGeometry(BASE_RADIUS, BASE_RADIUS, BASE_RADIUS * 5, undefined, undefined, true),\r\n    NO_TRANSLATION\r\n  ]\r\n];\r\n\r\n/**\r\n * A material to use for scenery, using the main beat theme color.\r\n */\r\nconst beatColorMaterial = new THREE.MeshStandardMaterial({ fog: true });\r\n\r\n/**\r\n * A material to use for scenery, using the bass panel theme color.\r\n */\r\nconst bassColorMaterial = new THREE.MeshStandardMaterial({ fog: true });\r\n\r\n/**\r\n * A material to use for scenery, using the star flash theme color.\r\n */\r\n const starFlashColorMaterial = new THREE.MeshStandardMaterial({ fog: true });\r\n\r\n/**\r\n * A wireframe material to use for scenery, using the frequency line theme color.\r\n */\r\nconst frequencyWireframeMaterial = new THREE.MeshBasicMaterial({ wireframe: true });\r\n\r\nconst ALL_MATERIALS = [\r\n  beatColorMaterial,\r\n  bassColorMaterial,\r\n  starFlashColorMaterial,\r\n  frequencyWireframeMaterial\r\n];\r\n\r\nfunction assignMaterialsToMesh(mesh: THREE.Mesh, forLull: Lull, trackAnalysis: TrackAnalysis): void {\r\n  // First, handle when this mesh's geometry only has one group for materials\r\n  if (mesh.geometry.groups.length <= 1) {\r\n    // Randomly assign one of the materials.\r\n    // When getting a random value, use the end to get different seeding results than what we have for geometry.\r\n    const materialIndex = trackAnalysis.getTrackSeededRandomInt(0, ALL_MATERIALS.length - 1, forLull.end);\r\n    mesh.material = ALL_MATERIALS[materialIndex];\r\n  }\r\n  else {\r\n\r\n    // We have multiple groups. Get materials for even/odd groups\r\n    const evenMaterialIndex = trackAnalysis.getTrackSeededRandomInt(0, ALL_MATERIALS.length - 1, forLull.end);\r\n    const oddMaterialIndex = trackAnalysis.getTrackSeededRandomInt(0, ALL_MATERIALS.length - 1, forLull.end + 1);\r\n\r\n    mesh.material = [];\r\n  \r\n    for (let groupIndex = 0; groupIndex < mesh.geometry.groups.length; groupIndex++) {\r\n      if (groupIndex % 2 === 0) {\r\n        mesh.material[groupIndex] = ALL_MATERIALS[evenMaterialIndex];\r\n      }\r\n      else {\r\n        mesh.material[groupIndex] = ALL_MATERIALS[oddMaterialIndex];\r\n      } \r\n    }\r\n  }\r\n}\r\n\r\nfunction SceneryQueue(props: { audio: RefObject<HTMLAudioElement>, analyser: RefObject<AnalyserNode> }): JSX.Element {\r\n  let nextUnrenderedLullIndex = 0;\r\n  let nextAvailableMeshIndex = 0;\r\n  const availableSceneryMeshesRing = useRef<THREE.Mesh[]>([]);\r\n  const QUEUE_SIZE = 10;\r\n  const SCENERY_DEPTH_START = -1000;\r\n  const SCENERY_DEPTH_END = 0;\r\n  const HORIZ_OFFSET = BASE_RADIUS * 2.5;\r\n  const VERT_OFFSET = -10;\r\n\r\n  const trackAnalysis = useStore(state => state.analysis);\r\n\r\n  // Make the lookahead period variable based on measure lengths\r\n  const lookaheadPeriod = useMemo(() => {\r\n    return trackAnalysis.secondsPerMeasure * 2;\r\n  }, [trackAnalysis]);\r\n\r\n  // Generate available sprites for use in a ring buffer\r\n  const availableMeshElements = \r\n    generateNumericArray(QUEUE_SIZE).map((index) => {\r\n      return <mesh\r\n        key={index}\r\n        visible={false}\r\n        ref={(m: THREE.Mesh) => availableSceneryMeshesRing.current[index] = m}\r\n        position={[HORIZ_OFFSET, VERT_OFFSET, SCENERY_DEPTH_START]}\r\n      />\r\n    });\r\n\r\n  // Because the scenery material is cached across multiple renders, just ensure the color reflects the state.\r\n  beatColorMaterial.color = useStore().theme.beat.color;\r\n  bassColorMaterial.color = useStore().theme.bass.panelColor;\r\n  starFlashColorMaterial.color = useStore().theme.background.starFlashColor;\r\n  frequencyWireframeMaterial.color = useStore().theme.frequencyGrid.lineColor;\r\n\r\n  useEffect(() => useStore.subscribe(\r\n    state => state.theme.beat.color,\r\n    (newColor) => {\r\n      beatColorMaterial.color = newColor;\r\n    }),\r\n    []);\r\n\r\n  useEffect(() => useStore.subscribe(\r\n    state => state.theme.bass.panelColor,\r\n    (newColor) => {\r\n      bassColorMaterial.color = newColor;\r\n    }),\r\n    []);\r\n\r\n  useEffect(() => useStore.subscribe(\r\n    state => state.theme.background.starFlashColor,\r\n    (newColor) => {\r\n      starFlashColorMaterial.color = newColor;\r\n    }),\r\n    []);  \r\n\r\n  useEffect(() => useStore.subscribe(\r\n    state => state.theme.frequencyGrid.lineColor,\r\n    (newColor) => {\r\n      frequencyWireframeMaterial.color = newColor;\r\n    }),\r\n    []);\r\n\r\n  // Reset the lull indices when we seek or change tracks\r\n  useEffect(() => useStore.subscribe(\r\n    state => [state.analysis, state.audioLastSeeked],\r\n    () => {\r\n      // eslint-disable-next-line react-hooks/exhaustive-deps\r\n      nextUnrenderedLullIndex = 0;\r\n      // eslint-disable-next-line react-hooks/exhaustive-deps\r\n      nextAvailableMeshIndex = 0;\r\n    }),\r\n    []);\r\n\r\n  useFrame((_state, delta) => {\r\n    if (props.audio.current === null) {\r\n      return;\r\n    }\r\n\r\n    const audioTime = props.audio.current.currentTime;\r\n    const lastRenderTime = Math.max(audioTime - delta, 0);\r\n\r\n    // Determine if we need to fill the ring buffer with any new meshes\r\n    for (let lullIdx = nextUnrenderedLullIndex; lullIdx < trackAnalysis.lulls.length; lullIdx++) {\r\n      const curLull = trackAnalysis.lulls[lullIdx];\r\n      const lullDisplayStart = curLull.time - lookaheadPeriod;\r\n      const lullDisplayEnd = curLull.time + curLull.duration;\r\n\r\n      // See if we're already too late for this lull - if so, skip ahead\r\n      if (lastRenderTime > lullDisplayEnd) {\r\n        nextUnrenderedLullIndex++;\r\n        continue;\r\n      }\r\n\r\n      // Now see if we're too early for this lull - if so, exit out\r\n      if (lullDisplayStart > audioTime) {\r\n        break;\r\n      }\r\n\r\n      // Now we have a new lull to render. Attach the data.\r\n      const meshForLull = availableSceneryMeshesRing.current[nextAvailableMeshIndex];\r\n      meshForLull.userData['lull'] = curLull;\r\n\r\n      // Randomize the geometry to use for the mesh\r\n      const geometryIndex = trackAnalysis.getTrackSeededRandomInt(0, SCENERY_GEOMETRIES.length - 1, curLull.time);\r\n      meshForLull.geometry = SCENERY_GEOMETRIES[geometryIndex][0];\r\n\r\n      // Pull geometry-specific translation information\r\n      const geometryPosition = SCENERY_GEOMETRIES[geometryIndex][1];\r\n\r\n      // Randomize whether it's on the left or right and apply the geometry-specific offset in the same direction\r\n      if (trackAnalysis.getTrackSeededRandomInt(0, 1, curLull.time) === 0) {\r\n        meshForLull.position.x = HORIZ_OFFSET + geometryPosition.x;\r\n      }\r\n      else {\r\n        meshForLull.position.x = -HORIZ_OFFSET - geometryPosition.x;\r\n      }\r\n\r\n      // Similarly randomize which material is being used for each face\r\n      assignMaterialsToMesh(meshForLull, curLull, trackAnalysis);\r\n\r\n      // Reset the vertical offset and apply the geometry-specific offset\r\n      meshForLull.position.y = VERT_OFFSET + geometryPosition.y;\r\n      \r\n      // Switch around to the next item in the ring buffer\r\n      nextAvailableMeshIndex = (nextAvailableMeshIndex + 1) % availableSceneryMeshesRing.current.length;\r\n\r\n      // Ensure we're rendering the next lull\r\n      nextUnrenderedLullIndex++;\r\n    }\r\n\r\n    // Calculate audio-based scaling factors\r\n    let verticalScalingFactor = 0.0;\r\n    let widthAndDepthScalingFactor = 0.0;\r\n\r\n    if (props.audio.current.currentTime > 0 && props.analyser.current != null) {\r\n      const frequencies = new Uint8Array(props.analyser.current.frequencyBinCount);\r\n      props.analyser.current.getByteFrequencyData(frequencies);\r\n\r\n      if (Number.isFinite(frequencies[7])) {\r\n        verticalScalingFactor = (frequencies[7] / 255.0) / 3;\r\n      }\r\n\r\n      if (Number.isFinite(frequencies[23])) {\r\n        widthAndDepthScalingFactor = (frequencies[23] / 255.0) / 10;\r\n      }\r\n    }\r\n\r\n    // Now update the items in the ring buffer\r\n    for (let itemIdx = 0; itemIdx < availableSceneryMeshesRing.current.length; itemIdx++)\r\n    {\r\n      const meshForLull = availableSceneryMeshesRing.current[itemIdx];\r\n      const lullData = meshForLull.userData['lull'] as Lull;\r\n\r\n      if (lullData === null || lullData === undefined) {\r\n        meshForLull.visible = false;\r\n        continue;\r\n      }\r\n\r\n      const lullDisplayStart = lullData.time - lookaheadPeriod;\r\n      const lullDisplayEnd = lullData.time + lullData.duration;\r\n\r\n      // See if we've finished displaying\r\n      if (lullDisplayStart > audioTime || lullDisplayEnd < lastRenderTime) {\r\n        meshForLull.visible = false;\r\n        delete meshForLull.userData['lull'];\r\n        continue;\r\n      }\r\n\r\n      // Make the mesh visible and lerp it to zoom in\r\n      meshForLull.visible = true;\r\n      meshForLull.position.z = THREE.MathUtils.mapLinear(audioTime, lullDisplayStart, lullDisplayEnd, SCENERY_DEPTH_START, SCENERY_DEPTH_END);\r\n\r\n      // Scale the mesh based on audio data, but apply easing factors in either direction to minimize suddenness\r\n      const easedDownXScale = meshForLull.scale.x * 0.995;\r\n      const easedDownYScale = meshForLull.scale.y * 0.995;\r\n      const easedDownZScale = meshForLull.scale.z * 0.995;\r\n      const easedUpXScale = meshForLull.scale.x * 1.0025;\r\n      const easedUpYScale = meshForLull.scale.y * 1.0025;\r\n      const easedUpZScale = meshForLull.scale.z * 1.0025;\r\n\r\n      meshForLull.scale.set(\r\n        Math.max(easedDownXScale, Math.min(easedUpXScale, 1.0 + widthAndDepthScalingFactor)),\r\n        Math.max(easedDownYScale, Math.min(easedUpYScale, 1.0 + verticalScalingFactor)),\r\n        Math.max(easedDownZScale, Math.min(easedUpZScale, 1.0 + widthAndDepthScalingFactor)));\r\n    }\r\n  });\r\n\r\n  return (\r\n    <group>\r\n      {availableMeshElements}\r\n    </group>\r\n  );\r\n}\r\n\r\nexport default SceneryQueue;\r\n","import { RefObject, useMemo, useRef } from 'react';\r\nimport * as THREE from 'three';\r\nimport { useFrame } from '@react-three/fiber';\r\nimport { useTexture } from '@react-three/drei';\r\n\r\nimport { useStore } from '../store/visualizerStore';\r\n\r\nconst FULL_RADIANS = 2 * Math.PI;\r\n\r\nfunction buildLineRingGeometry(innerRadius: number, maxOuterRadius: number, perturbAngle: number): THREE.BufferGeometry {\r\n  const points: THREE.Vector3[] = [];\r\n  const LINE_COUNT = 120;\r\n  const ANGLE_PER_LINE = 360 / LINE_COUNT;\r\n  const extraLength = Math.max(maxOuterRadius - innerRadius, 1);\r\n\r\n  for (let pointNum = 0; pointNum < LINE_COUNT; pointNum++) {\r\n    const angle = ((pointNum * ANGLE_PER_LINE) + perturbAngle) * THREE.MathUtils.DEG2RAD;\r\n    const outerRadius = innerRadius + (((Math.sin(pointNum * innerRadius) + 1) * extraLength) / 2);\r\n    const x = Math.cos(angle);\r\n    const y = Math.sin(angle);\r\n\r\n    points.push(new THREE.Vector3(x * innerRadius, y * innerRadius, 0));\r\n    points.push(new THREE.Vector3(x * outerRadius, y * outerRadius, 0));\r\n  }\r\n\r\n  const geometry = new THREE.BufferGeometry();\r\n  geometry.setFromPoints(points);\r\n  return geometry; \r\n}\r\n\r\n/**\r\n * A geometry that is intended to act as a backdrop for the entire scene.\r\n */\r\nconst backdropGeometry = new THREE.PlaneGeometry(2048, 2048);\r\n\r\nfunction BackgroundManager(props: { audio: RefObject<HTMLAudioElement>, analyser: RefObject<AnalyserNode> }): JSX.Element {\r\n  // Load background textures\r\n  const textures = useTexture({\r\n    star_first: process.env.PUBLIC_URL + '/backgrounds/star-01.png',\r\n    star_first_glow: process.env.PUBLIC_URL + '/backgrounds/star-01-glow.png',\r\n    star_second: process.env.PUBLIC_URL + '/backgrounds/star-02.png',\r\n    star_second_glow: process.env.PUBLIC_URL + '/backgrounds/star-02-glow.png',\r\n    star_third: process.env.PUBLIC_URL + '/backgrounds/star-03.png',\r\n    star_third_glow: process.env.PUBLIC_URL + '/backgrounds/star-03-glow.png',\r\n    horizon: process.env.PUBLIC_URL + '/backgrounds/horizon.png'\r\n  });\r\n\r\n  // The star textures should repeat 4 times\r\n  [\r\n    textures.star_first,\r\n    textures.star_first_glow,\r\n    textures.star_second,\r\n    textures.star_second_glow,\r\n    textures.star_third,\r\n    textures.star_third_glow\r\n  ].forEach((tex) => {\r\n    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;\r\n    tex.repeat.setScalar(4);\r\n  });\r\n\r\n  // For the horizon, we just want to repeat the pixels when available\r\n  textures.horizon.wrapS = textures.horizon.wrapT = THREE.RepeatWrapping;\r\n\r\n  const trackAnalysis = useStore(state => state.analysis);\r\n  const backgroundTheme = useStore(state => state.theme.background); \r\n\r\n  // Set up the geometry for the line \"rings\"\r\n  const firstRingGeometry = useMemo(() => {\r\n    return buildLineRingGeometry(100, 120, 0);\r\n  }, []);\r\n\r\n  const secondRingGeometry = useMemo(() => {\r\n    return buildLineRingGeometry(125, 145, 15);\r\n  }, []);\r\n\r\n  const thirdRingGeometry = useMemo(() => {\r\n    return buildLineRingGeometry(150, 170, 30);\r\n  }, []);\r\n\r\n  // Determine motion amounts based on the BPM\r\n  const ringCycleSeconds = useMemo(() => {\r\n    return trackAnalysis.secondsPerMeasure * 8;\r\n  }, [trackAnalysis]);\r\n\r\n  const starCycleSeconds = useMemo(() => {\r\n    return trackAnalysis.secondsPerMeasure * 16;\r\n  }, [trackAnalysis]);\r\n\r\n  const horizonLayer = useRef<THREE.Mesh>(null!);\r\n  const firstStarLayer = useRef<THREE.Mesh>(null!);\r\n  const firstStarGlowLayer = useRef<THREE.Mesh>(null!);\r\n  const secondStarLayer = useRef<THREE.Mesh>(null!);\r\n  const secondStarGlowLayer = useRef<THREE.Mesh>(null!);\r\n  const thirdStarLayer = useRef<THREE.Mesh>(null!);\r\n  const thirdStarGlowLayer = useRef<THREE.Mesh>(null!);\r\n  const ringGroup = useRef<THREE.Group>(null!);\r\n  const firstLineRing = useRef<THREE.LineSegments>(null!);\r\n  const secondLineRing = useRef<THREE.LineSegments>(null!);\r\n  const thirdLineRing = useRef<THREE.LineSegments>(null!);\r\n  \r\n  useFrame((state) => {\r\n    state.scene.background = backgroundTheme.fillColor;\r\n\r\n    // Hide the ring group when we don't have a track analysis\r\n    ringGroup.current.visible = !trackAnalysis.isEmpty;\r\n\r\n    let currentTrackTime = 0;\r\n    let currentTrackDuration = 0;\r\n\r\n    if (props.audio.current !== null) {\r\n      currentTrackTime = props.audio.current.currentTime;\r\n      currentTrackDuration = props.audio.current.duration;\r\n    }\r\n\r\n    // Rotate the line \"rings\" over time\r\n    const ringPercentage = (currentTrackTime % ringCycleSeconds) / ringCycleSeconds;\r\n    const ringRotation = Math.sin(ringPercentage * FULL_RADIANS);\r\n\r\n    firstLineRing.current.rotation.set(0, 0, ringRotation);\r\n    secondLineRing.current.rotation.set(0, 0, 0.75 * ringRotation);\r\n    thirdLineRing.current.rotation.set(0, 0, 0.5 * ringRotation);\r\n\r\n    // Shift the star backgrounds over time\r\n    const starPercentage = (currentTrackTime % starCycleSeconds) / starCycleSeconds;\r\n    const starRotation = Math.sin(starPercentage * FULL_RADIANS);\r\n\r\n    firstStarLayer.current.position.x = 50 * starRotation;\r\n    firstStarGlowLayer.current.position.x = 50 * starRotation;\r\n    secondStarLayer.current.position.x = 60 * starRotation;\r\n    secondStarGlowLayer.current.position.x = 60 * starRotation;\r\n    thirdStarLayer.current.position.x = 70 * starRotation;\r\n    thirdStarGlowLayer.current.position.x = 70 * starRotation;\r\n\r\n    // If we're currently playing, tweak based on the music\r\n    let ringOpacityFactor = 0.0;\r\n    let ringScaleFactor = 0.0;\r\n    let horizonOpacityFactor = 0.0;\r\n    let starGlowFactor = 0.0;\r\n\r\n    if (currentTrackTime > 0 && props.analyser.current !== null) {\r\n      const frequencies = new Uint8Array(props.analyser.current.frequencyBinCount);\r\n      props.analyser.current.getByteFrequencyData(frequencies);\r\n\r\n      if (Number.isFinite(frequencies[15])) {\r\n        ringOpacityFactor = (frequencies[15] / 255.0) / 2;\r\n      }\r\n\r\n      if (Number.isFinite(frequencies[7])) {\r\n        ringScaleFactor = (frequencies[7] / 255.0) / 4;\r\n      }\r\n\r\n      if (Number.isFinite(frequencies[31])) {\r\n        horizonOpacityFactor = (frequencies[31] / 255.0) / 3;\r\n      }\r\n\r\n      if (Number.isFinite(frequencies[53])) {\r\n        starGlowFactor = (frequencies[53] / 255.0) / 5;\r\n      }\r\n    }\r\n\r\n    // Scale the rings opacity\r\n    (firstLineRing.current.material as THREE.Material).opacity = 0.5 + ringOpacityFactor;\r\n    (secondLineRing.current.material as THREE.Material).opacity = 0.4 + ringOpacityFactor;\r\n    (thirdLineRing.current.material as THREE.Material).opacity = 0.3 + ringOpacityFactor;\r\n\r\n    // Ease horizon flashes back down to 0.0, but cut off items that are asymptotically approaching 0 opacity\r\n    let horizonDampenedOpacity = (horizonLayer.current.material as THREE.Material).opacity * 0.95;\r\n\r\n    if (horizonDampenedOpacity <= 0.01) {\r\n      horizonDampenedOpacity = 0;\r\n    }\r\n\r\n    (horizonLayer.current.material as THREE.Material).opacity = Math.max(horizonOpacityFactor, horizonDampenedOpacity);\r\n\r\n    // Similarly scale the star \"glow\" layers\r\n    let starGlowDampenedOpacity = (firstStarGlowLayer.current.material as THREE.Material).opacity * 0.95;\r\n\r\n    if (starGlowDampenedOpacity <= 0.01) {\r\n      starGlowDampenedOpacity = 0;\r\n    }\r\n\r\n    const newStarGlowOpacity = Math.max(starGlowFactor, starGlowDampenedOpacity);\r\n\r\n    (firstStarGlowLayer.current.material as THREE.Material).opacity = newStarGlowOpacity;\r\n    (secondStarGlowLayer.current.material as THREE.Material).opacity = newStarGlowOpacity;\r\n    (thirdStarGlowLayer.current.material as THREE.Material).opacity = newStarGlowOpacity;\r\n\r\n    // Scale the rings based on our frequency-0driven factor\r\n    // If we are just coming off of an increase in scale, we want to ease back to the standard 1.0\r\n    const ringDampenedScale = firstLineRing.current.scale.x * 0.9;\r\n    const newRingScale = Math.max(1.0 + ringScaleFactor, ringDampenedScale);\r\n\r\n    firstLineRing.current.scale.x = firstLineRing.current.scale.y = newRingScale;\r\n    secondLineRing.current.scale.x = secondLineRing.current.scale.y = newRingScale;\r\n    thirdLineRing.current.scale.x = thirdLineRing.current.scale.y = newRingScale;\r\n\r\n    // Make the rings appear closer as we get closer to the end of the track\r\n    if (Number.isFinite(currentTrackDuration) && currentTrackDuration > 0) {\r\n      const ringGroupScale = THREE.MathUtils.mapLinear(currentTrackTime, 0, currentTrackDuration, 0.5, 1.5);\r\n      ringGroup.current.scale.x = ringGroup.current.scale.y = ringGroupScale;\r\n    }\r\n  })\r\n\r\n  return (\r\n    <group>\r\n      <mesh\r\n        ref={horizonLayer}\r\n        frustumCulled={false}\r\n        position={[0, 0, -300]}\r\n        scale={[8, 0.125, 1]}\r\n      >\r\n        <planeGeometry\r\n          args={[1024, 512]}\r\n        />\r\n        <meshBasicMaterial\r\n          color={backgroundTheme.starFlashColor}\r\n          map={textures.horizon}\r\n          transparent={true}\r\n          opacity={0.0}\r\n          fog={false}\r\n          depthWrite={false}\r\n          precision={'mediump'}\r\n        />\r\n       </mesh>\r\n      <group ref={ringGroup}>\r\n        <lineSegments\r\n          ref={firstLineRing}\r\n          position={[0, 0, -250]}\r\n          geometry={firstRingGeometry}\r\n        >\r\n          <lineBasicMaterial\r\n            color={backgroundTheme.burstLineColor}\r\n            transparent={true}\r\n            opacity={0.5}\r\n            fog={false}\r\n            precision={'lowp'}\r\n          />\r\n        </lineSegments>\r\n        <lineSegments\r\n          ref={secondLineRing}\r\n          position={[0, 0, -250]}\r\n          geometry={secondRingGeometry}\r\n        >\r\n          <lineBasicMaterial\r\n            color={backgroundTheme.burstLineColor}\r\n            transparent={true}\r\n            opacity={0.4}\r\n            fog={false}\r\n            precision={'lowp'}\r\n          />\r\n        </lineSegments>\r\n        <lineSegments\r\n          ref={thirdLineRing}\r\n          position={[0, 0, -250]}\r\n          geometry={thirdRingGeometry}\r\n        >\r\n          <lineBasicMaterial\r\n            color={backgroundTheme.burstLineColor}\r\n            transparent={true}\r\n            opacity={0.3}\r\n            fog={false}\r\n            precision={'lowp'}\r\n          />\r\n        </lineSegments>\r\n      </group>\r\n      <group>\r\n        <mesh\r\n          ref={firstStarGlowLayer}\r\n          position={[0, 0, -599]}\r\n          scale={[2, 2, 1]}\r\n          frustumCulled={false}\r\n          geometry={backdropGeometry}\r\n        >\r\n          <meshBasicMaterial\r\n            color={backgroundTheme.starFlashColor}\r\n            map={textures.star_first_glow}\r\n            transparent={true}\r\n            opacity={0.0}\r\n            fog={false}\r\n            depthWrite={false}\r\n            precision={'lowp'}\r\n          />\r\n        </mesh>\r\n        <mesh\r\n          ref={firstStarLayer}\r\n          position={[0, 0, -600]}\r\n          scale={[2, 2, 1]}\r\n          frustumCulled={false}\r\n          geometry={backdropGeometry}\r\n        >\r\n          <meshBasicMaterial\r\n            color={backgroundTheme.starColor}\r\n            map={textures.star_first}\r\n            transparent={true}\r\n            fog={false}\r\n            depthWrite={false}\r\n            precision={'lowp'}\r\n          />\r\n        </mesh>\r\n\r\n        <mesh\r\n          ref={secondStarGlowLayer}\r\n          position={[0, 0, -699]}\r\n          scale={[2, 2, 1]}\r\n          frustumCulled={false}\r\n          geometry={backdropGeometry}\r\n        >\r\n          <meshBasicMaterial\r\n            color={backgroundTheme.starFlashColor}\r\n            map={textures.star_second_glow}\r\n            transparent={true}\r\n            opacity={0.0}\r\n            fog={false}\r\n            depthWrite={false}\r\n            precision={'lowp'}\r\n          />\r\n        </mesh>\r\n        <mesh\r\n          ref={secondStarLayer}\r\n          position={[0, 0, -700]}\r\n          scale={[2, 2, 1]}\r\n          frustumCulled={false}\r\n          geometry={backdropGeometry}\r\n        >\r\n          <meshBasicMaterial\r\n            color={backgroundTheme.starColor}\r\n            map={textures.star_second}\r\n            transparent={true}\r\n            fog={false}\r\n            depthWrite={false}\r\n            precision={'lowp'}\r\n          />\r\n        </mesh>\r\n\r\n        <mesh\r\n          ref={thirdStarGlowLayer}\r\n          position={[0, 0, -799]}\r\n          scale={[2, 2, 1]}\r\n          frustumCulled={false}\r\n          geometry={backdropGeometry}\r\n        >\r\n          <meshBasicMaterial\r\n            color={backgroundTheme.starFlashColor}\r\n            map={textures.star_third_glow}\r\n            transparent={true}\r\n            opacity={0.0}\r\n            fog={false}\r\n            depthWrite={false}\r\n            precision={'lowp'}\r\n          />\r\n        </mesh>\r\n        <mesh\r\n          ref={thirdStarLayer}\r\n          position={[0, 0, -800]}\r\n          scale={[2, 2, 1]}\r\n          frustumCulled={false}\r\n          geometry={backdropGeometry}\r\n        >\r\n          <meshBasicMaterial\r\n            color={backgroundTheme.starColor}\r\n            map={textures.star_third}\r\n            transparent={true}\r\n            fog={false}\r\n            depthWrite={false}\r\n            precision={'lowp'}\r\n          />\r\n        </mesh>\r\n      </group>\r\n    </group>\r\n  );\r\n}\r\n\r\nexport default BackgroundManager;\r\n","import { RefObject, useRef } from 'react';\r\nimport * as THREE from 'three';\r\nimport { useFrame } from '@react-three/fiber';\r\nimport { EffectComposer, Bloom, GodRays } from '@react-three/postprocessing';\r\nimport { GodRaysEffect, BlendFunction, Resizer, KernelSize } from 'postprocessing';\r\n\r\nfunction VfxManager(props: { audio: RefObject<HTMLAudioElement>, analyser: RefObject<AnalyserNode>, sunMesh: THREE.Mesh }): JSX.Element {\r\n  const godRaysEffect = useRef<typeof GodRaysEffect>(null!);\r\n  \r\n  useFrame(() => {\r\n    if (props.audio.current === null || props.audio.current.currentTime <= 0 || props.analyser.current === null || godRaysEffect.current === null) {\r\n      return;\r\n    }\r\n\r\n    const frequencies = new Uint8Array(props.analyser.current.frequencyBinCount);\r\n    props.analyser.current.getByteFrequencyData(frequencies);\r\n\r\n    // Pulse the intensity of the god rays based on low-mid frequencies\r\n    // HACK: Party on the GodRaysMaterial and adjust values based on our frequency\r\n    // https://vanruesc.github.io/postprocessing/public/docs/file/src/effects/GodRaysEffect.js.html\r\n    const godRaysMaterial = godRaysEffect.current.godRaysPass.getFullscreenMaterial();\r\n    \r\n    if (Number.isFinite(frequencies[5])) {\r\n      const godRaysScale = frequencies[5] / 255.0;\r\n\r\n      godRaysMaterial.uniforms.decay.value = THREE.MathUtils.lerp(0.4, 0.93, godRaysScale);\r\n      godRaysMaterial.uniforms.exposure.value = THREE.MathUtils.lerp(0.4, 0.85, godRaysScale);\r\n    }\r\n    else {\r\n      godRaysMaterial.uniforms.decay.value = 0.4;\r\n      godRaysMaterial.uniforms.exposure.value = 0.4;\r\n    }\r\n  });\r\n\r\n  return (\r\n    <EffectComposer>\r\n      <Bloom\r\n        intensity={1}\r\n        width={Resizer.AUTO_SIZE}\r\n        height={Resizer.AUTO_SIZE}\r\n        kernelSize={KernelSize.MEDIUM}\r\n        luminanceThreshold={0.4}\r\n        luminanceSmoothing={0.1}\r\n      />\r\n      <GodRays\r\n        ref={godRaysEffect}\r\n        sun={props.sunMesh}\r\n        blur={10}\r\n        blendFunction={BlendFunction.Screen}\r\n        samples={60}\r\n        density={0.85}\r\n        decay={0.85}\r\n        weight={0.4}\r\n        exposure={0.4}\r\n        clampMax={1}\r\n        width={Resizer.AUTO_SIZE}\r\n        height={Resizer.AUTO_SIZE}\r\n        kernelSize={KernelSize.MEDIUM}\r\n      />\r\n    </EffectComposer>\r\n  )\r\n}\r\n\r\nexport default VfxManager;\r\n","import { RefObject, useEffect } from 'react';\r\nimport * as THREE from 'three';\r\nimport { Canvas } from '@react-three/fiber';\r\n\r\nimport { useStore } from '../store/visualizerStore';\r\n\r\nimport BassTunnel from './BassTunnel';\r\nimport BeatQueue from './BeatQueue';\r\nimport FrequencyGrid from './FrequencyGrid';\r\nimport TrebleQueue from './TrebleQueue';\r\nimport SceneryQueue from './SceneryQueue';\r\nimport BackgroundManager from './BackgroundManager';\r\nimport VfxManager from './VfxManager';\r\n\r\n/**\r\n * The material to use for the sun.\r\n */\r\nconst sunMaterial = new THREE.MeshBasicMaterial({ transparent: true, fog: false });\r\n\r\n/**\r\n * The mesh to use for the sun.\r\n * Used to simplify ref-passing for the VFX manager.\r\n */\r\nconst sunMesh = new THREE.Mesh(new THREE.SphereGeometry(5), sunMaterial);\r\nsunMesh.frustumCulled = false;\r\nsunMesh.position.set(0, 0, -200);\r\n\r\nfunction Visualizer(props: { audio: RefObject<HTMLAudioElement>, analyser: RefObject<AnalyserNode> }): JSX.Element {\r\n  // Ensure that the sun's color is updated in response to theme changes\r\n  sunMaterial.color = useStore.getState().theme.background.sunColor;\r\n\r\n  useEffect(() => useStore.subscribe(\r\n    (state) => state.theme.background.sunColor,\r\n    (newSunColor) => {\r\n      sunMaterial.color = newSunColor;\r\n    }),\r\n    []);\r\n\r\n  return (\r\n    <Canvas camera={{position: [0, 0, 15]}}>\r\n      <ambientLight intensity={0.1} />\r\n      <directionalLight position={[0, 0, 20]} />\r\n      <primitive object={sunMesh} />\r\n      <BassTunnel audio={props.audio} />\r\n      <BeatQueue audio={props.audio} />\r\n      <FrequencyGrid audio={props.audio} analyser={props.analyser} />\r\n      <TrebleQueue audio={props.audio} />\r\n      <SceneryQueue audio={props.audio} analyser={props.analyser} />\r\n      <BackgroundManager audio={props.audio} analyser={props.analyser} />\r\n      <VfxManager audio={props.audio} analyser={props.analyser} sunMesh={sunMesh} />\r\n    </Canvas>\r\n  );\r\n}\r\n\r\nexport default Visualizer;","import React, { useRef, useCallback, useEffect, Suspense, useState } from 'react';\r\nimport { Stats } from '@react-three/drei';\r\n\r\nimport { analyzeTrack } from '../store/analyzer';\r\nimport { useStore } from '../store/visualizerStore';\r\nimport { getNextTheme, getThemeForTrack } from '../store/themes';\r\n\r\nimport './App.css';\r\nimport AppStyles from './AppStyles';\r\nimport Visualizer from './Visualizer';\r\nimport ThemeReviewer from './ThemeReviewer';\r\n\r\nfunction isSafari(): boolean {\r\n  return navigator.userAgent.indexOf('AppleWebKit') > -1 && navigator.userAgent.indexOf('Chrome') === -1;\r\n}\r\n\r\nfunction getAllowedAudioFileTypes(): string {\r\n  // Work around Webkit bug https://bugs.webkit.org/show_bug.cgi?id=34442\r\n  if (isSafari()) {\r\n    return '.mp3,.m4a,.ogg,.aac,.flac';\r\n  }\r\n  else {\r\n    return 'audio/*';\r\n  }\r\n}\r\n\r\nfunction App(): JSX.Element {\r\n  // Keep track of what we played last so we can free the object URL when switching tracks\r\n  let playingFileUrl: string = '';\r\n\r\n  // Wire up store hooks\r\n  const setStoreAnalysis = useStore(store => store.setAnalysis);\r\n  const setStoreTheme = useStore(store => store.setTheme);\r\n  const setStoreAudioSeeked = useStore(store => store.indicateAudioSeeked);\r\n\r\n  // XXX: Investigate supprting webkitAudioContext\r\n  // audioContext is a ref so that we can try to preserve state during fast-refresh in Chrome\r\n  const audioContext = useRef(new AudioContext());\r\n  const introElement = useRef<HTMLDivElement>(null!);\r\n  const sourceFileElement = useRef<HTMLInputElement>(null!);\r\n  const dummyFileButtonElement = useRef<HTMLButtonElement>(null!);\r\n  const [fileError, setFileError] = useState('');\r\n\r\n  // These are indirect refs set up via audio player callback\r\n  const audioPlayerElement = useRef<HTMLAudioElement | null>(null);\r\n  const audioAnalyser = useRef<AnalyserNode | null>(null);\r\n\r\n  // Like audioContext, this is a ref so that we can preserve it during Chrome fast-refresh\r\n  const mediaElementSourceNodes = useRef(new WeakMap<HTMLMediaElement, MediaElementAudioSourceNode>());\r\n  \r\n  // Ensure that the audio player has an audio context/analyzer node set up\r\n  const audioPlayerRef = useCallback(\r\n    (node: HTMLAudioElement) => {\r\n      if (node != null) {\r\n        // HACK: Work around hot-reload issues in Chrome by ensuring we re-use media source nodes\r\n        // https://stackoverflow.com/a/39725071\r\n        let audioSource: MediaElementAudioSourceNode;\r\n\r\n        if (mediaElementSourceNodes.current.has(node)) {\r\n          audioSource = mediaElementSourceNodes.current.get(node)!;\r\n        }\r\n        else {\r\n          audioSource = new MediaElementAudioSourceNode(audioContext.current, { mediaElement: node });\r\n          mediaElementSourceNodes.current.set(node, audioSource);\r\n        }\r\n\r\n        const analyser = new AnalyserNode(audioContext.current, { fftSize: 128 });\r\n\r\n        audioSource.connect(analyser);\r\n        analyser.connect(audioContext.current.destination);\r\n\r\n        audioPlayerElement.current = node;\r\n        audioAnalyser.current = analyser;\r\n      }\r\n    },\r\n    [audioContext],\r\n  );\r\n\r\n  const dummyFilePickerClicked = () => {\r\n    // HACK: Work around Mobile Safari autoplay limitations:\r\n    // http://www.schillmania.com/projects/soundmanager2/doc/technotes/#mobile-device-limitations\r\n    // If we have an audio player but haven't wired up a source yet, set one and load\r\n    if (isSafari() && audioContext.current && audioPlayerElement.current && !audioPlayerElement.current.src) {\r\n      try {\r\n        audioContext.current.resume();\r\n        audioPlayerElement.current.play();\r\n      }\r\n      catch {\r\n      }\r\n    }\r\n\r\n    // Now open the file picker\r\n    sourceFileElement.current.click();\r\n  };\r\n\r\n  const selectedFileChange = () => {\r\n    if (sourceFileElement.current?.files?.length === 1)\r\n    {\r\n      // Disable the file picker while we analyze the track\r\n      dummyFileButtonElement.current.disabled = true;\r\n      dummyFileButtonElement.current.innerText = \"Analyzing...\";\r\n      sourceFileElement.current.disabled = true;\r\n      sourceFileElement.current.readOnly = true;\r\n\r\n      // Reset the file error message\r\n      setFileError('');\r\n\r\n      // Disable the audio player while we analyze - we don't want\r\n      // weird concurrency issues when we're updating the element\r\n      if (audioPlayerElement.current) {\r\n        audioPlayerElement.current.pause();\r\n        audioPlayerElement.current.controls = false;\r\n      }\r\n\r\n      const trackFile = sourceFileElement.current.files[0];\r\n\r\n      analyzeTrack(trackFile)\r\n        .then((analyzerResult) => {\r\n          if (process.env.NODE_ENV !== 'production') {\r\n            console.log(analyzerResult);\r\n          }\r\n\r\n          // Create a URL for the new file\r\n          const newAudioUrl = URL.createObjectURL(trackFile);\r\n\r\n          // Switch the audio over to that\r\n          if (audioPlayerElement.current !== null) {\r\n            audioPlayerElement.current.src = newAudioUrl;\r\n            audioPlayerElement.current.load();\r\n\r\n            // HACK: As needed, start the audio player in an event loop *after* we've finished handling the file selection.\r\n            // Even though the file selector has been clicked, we're still in the event handler for that\r\n            // so Chrome's auto-play blocking doesn't consider the interaction \"complete\".\r\n            const initialContextPromise = audioContext.current.resume();\r\n            const initialPlayerPromise = audioPlayerElement.current.play();\r\n\r\n            if (initialContextPromise !== undefined && initialPlayerPromise !== undefined) {\r\n\r\n              Promise.all([initialContextPromise, initialPlayerPromise])\r\n                .then(() => {\r\n                  // We're good!\r\n                })\r\n                .catch(() => {\r\n                  // We need to wait for the next event loop\r\n                  window.setTimeout(() => {\r\n                    if (audioContext.current && audioPlayerElement.current) {\r\n                      audioContext.current.resume();\r\n                      audioPlayerElement.current.play();\r\n                    }\r\n                  });\r\n                });\r\n            }\r\n          }\r\n\r\n          // Free the previously-playing URL over if we had one\r\n          if (playingFileUrl !== '') {\r\n            URL.revokeObjectURL(playingFileUrl);\r\n          }\r\n\r\n          playingFileUrl = newAudioUrl;\r\n          introElement.current.hidden = true;\r\n          const newTheme = getThemeForTrack(analyzerResult);\r\n\r\n          if (process.env.NODE_ENV !== 'production') {\r\n            console.debug(`switching to ${newTheme.name} theme`);\r\n          }\r\n\r\n          setStoreAnalysis(analyzerResult);\r\n          setStoreTheme(newTheme);\r\n          setStoreAudioSeeked();\r\n        })\r\n        .catch((reason: any) => {\r\n          console.error(reason);\r\n          setFileError(`Error opening \"${trackFile?.name}\":\\n${reason.toString()}`);\r\n        })\r\n        .finally(() => {\r\n          // Re-enable the file picker\r\n          if (sourceFileElement.current) {\r\n            sourceFileElement.current.disabled = false;\r\n            sourceFileElement.current.readOnly = false;\r\n          }\r\n\r\n          if (dummyFileButtonElement.current) {\r\n            dummyFileButtonElement.current.disabled = false;\r\n            dummyFileButtonElement.current.innerText = \"Choose a track\";\r\n          }\r\n\r\n          if (audioPlayerElement.current && audioPlayerElement.current.src) {\r\n            audioPlayerElement.current.controls = true;\r\n          }\r\n        })\r\n    }\r\n  };\r\n\r\n  const cycleTheme = () => {\r\n    const nextTheme = getNextTheme(useStore.getState().theme);\r\n    \r\n    if (process.env.NODE_ENV !== 'production') {\r\n      console.debug(`switching to ${nextTheme.name} theme`);\r\n    }\r\n\r\n    setStoreTheme(nextTheme);\r\n  };\r\n\r\n  // Update the page title based on the currently playing song\r\n  useEffect(() => useStore.subscribe(\r\n    (state) => state.analysis, \r\n    (newAnalysis) => {\r\n      if (newAnalysis !== null && !newAnalysis.isEmpty && newAnalysis.artist !== '' && newAnalysis.title !== '') {\r\n        document.title = `Edenator (${newAnalysis.artist} - ${newAnalysis.title})`;\r\n      }\r\n      else {\r\n        document.title = 'Edenator';\r\n      }\r\n    }),\r\n    []);\r\n\r\n  return (\r\n    <div>\r\n      <AppStyles />\r\n      <div\r\n        ref={introElement}\r\n        className='app-title'\r\n      > \r\n        <h1>\r\n          Edenator\r\n        </h1>\r\n        <p>\r\n          An in-browser audio visualizer.\r\n          Start by choosing a track.\r\n        </p>\r\n        <p>\r\n          <strong><em>The visuals used by this application may not be suitable for\r\n          people with photosensitive epilepsy.</em></strong>\r\n        </p>\r\n        <p>\r\n          This visualizer requires support for WebGL 2.0 and the Web Audio API.\r\n          All audio processing is performed in-browser and is not uploaded.\r\n        </p>\r\n      </div>\r\n      <div\r\n        className=\"app-error\"\r\n        hidden={!fileError}\r\n      >\r\n        {fileError}\r\n        <button\r\n          type=\"button\"\r\n          onClick={() => setFileError('')}\r\n        >\r\n          Dismiss\r\n        </button>\r\n      </div>\r\n      <div id=\"filePicker\">\r\n        <button\r\n          type=\"button\"\r\n          ref={dummyFileButtonElement}\r\n          id=\"dummyFilePicker\"\r\n          className=\"btn\"\r\n          onClick={dummyFilePickerClicked}\r\n        >\r\n          Choose a track\r\n        </button>\r\n        <input\r\n          type=\"file\"\r\n          ref={sourceFileElement}\r\n          id=\"sourceFile\"\r\n          aria-label=\"Choose an audio file\"\r\n          accept={getAllowedAudioFileTypes()}\r\n          onChange={selectedFileChange}\r\n        />\r\n      </div>\r\n      <button\r\n        type=\"button\"\r\n        id=\"themeCycler\"\r\n        className=\"btn\"\r\n        onClick={cycleTheme}\r\n      >\r\n        Switch theme\r\n      </button>\r\n      <audio\r\n        ref={audioPlayerRef}\r\n        id=\"audioPlayer\"\r\n        onSeeked={setStoreAudioSeeked}\r\n      >\r\n      </audio>\r\n      <div id=\"canvas-container\">\r\n        <Suspense fallback={null}>\r\n          <Visualizer\r\n            audio={audioPlayerElement}\r\n            analyser={audioAnalyser}\r\n          />\r\n        </Suspense>\r\n      </div>\r\n      {/* Only include stats and theme reviewer in development */}\r\n      {\r\n        process.env.NODE_ENV !== 'production'\r\n        &&\r\n        <Stats\r\n          showPanel={0}\r\n          className=\"stats\"\r\n        />\r\n      }\r\n      {\r\n        process.env.NODE_ENV !== 'production'\r\n        &&\r\n        <ThemeReviewer />\r\n      }\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport './index.css';\nimport App from './components/App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}